<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Everything you need to know to use Keras to build real-world machine learning solutions.">
<title>Introduction to Keras for Engineers • keras3</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../../apple-touch-icon-60x60.png">
<script src="../../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../../pkgdown.js"></script><meta property="og:title" content="Introduction to Keras for Engineers">
<meta property="og:description" content="Everything you need to know to use Keras to build real-world machine learning solutions.">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-inverse navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../../index.html">keras3</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.13.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../../index.html">Home</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-getting-started">Getting Started</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-getting-started">
    <a class="dropdown-item" href="../../articles/intro_to_keras_for_engineers.html">Introduction to Keras for engineers</a>
    <h6 class="dropdown-header" data-toc-skip>Tutorials</h6>
    <a class="dropdown-item" href="../../articles/getting_started.html">Getting Started</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_classification.html">Basic Classification</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_text_classification.html">Text Classification</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_regression.html">Basic Regression</a>
    <a class="dropdown-item" href="../../articles/tutorial_overfit_underfit.html">Overfitting and Underfitting</a>
    <a class="dropdown-item" href="../../articles/tutorial_save_and_restore.html">Save and Restore Models</a>
  </div>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-guides">Guides</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-guides">
    <h6 class="dropdown-header" data-toc-skip>Model definition</h6>
    <a class="dropdown-item" href="../../articles/functional_api.html">Functional API</a>
    <a class="dropdown-item" href="../../articles/sequential_model.html">Sequential Model</a>
    <h6 class="dropdown-header" data-toc-skip>Extending and customizing</h6>
    <a class="dropdown-item" href="../../articles/making_new_layers_and_models_via_subclassing.html">Making new layers and models via subclassing</a>
    <a class="dropdown-item" href="../../articles/training_with_built_in_methods.html">Training &amp; evaluation with the built-in methods</a>
    <a class="dropdown-item" href="../../articles/writing_a_custom_training_loop_in_tensorflow.html">Writing a training loop from scratch in TensorFlow</a>
    <a class="dropdown-item" href="../../articles/writing_your_own_callbacks.html">Writing Your Own Callbacks</a>
    <h6 class="dropdown-header" data-toc-skip>Other topics</h6>
    <a class="dropdown-item" href="../../articles/transfer_learning.html">Transfer learning and fine tuning</a>
    <a class="dropdown-item" href="../../articles/distributed_training_with_tensorflow.html">Distributed training with TensorFlow</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../articles/examples/index.html">Examples</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../news/index.html">News</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/rstudio/keras/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Introduction to Keras for Engineers</h1>
                        <h4 data-toc-skip class="author"><a href="https://twitter.com/fchollet" class="external-link">fchollet</a></h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/keras/blob/HEAD/vignettes/guides/intro_to_keras_for_engineers.Rmd" class="external-link"><code>vignettes/guides/intro_to_keras_for_engineers.Rmd</code></a></small>
      <div class="d-none name"><code>intro_to_keras_for_engineers.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> keras</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Are you a machine learning engineer looking to use Keras to ship
deep-learning powered features in real products? This guide will serve
as your first introduction to core Keras API concepts.</p>
<p>In this guide, you will learn how to:</p>
<ul>
<li>Prepare your data before training a model (by turning it into either
NumPy arrays or <code>tf.data.Dataset</code> objects).</li>
<li>Do data preprocessing, for instance feature normalization or
vocabulary indexing.</li>
<li>Build a model that turns your data into useful predictions, using
the Keras Functional API.</li>
<li>Train your model with the built-in Keras <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> method,
while being mindful of checkpointing, metrics monitoring, and fault
tolerance.</li>
<li>Evaluate your model on a test data and how to use it for inference
on new data.</li>
<li>Customize what <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> does, for instance to build a
GAN.</li>
<li>Speed up training by leveraging multiple GPUs.</li>
<li>Refine your model through hyperparameter tuning.</li>
</ul>
<p>At the end of this guide, you will get pointers to end-to-end
examples to solidify these concepts:</p>
<ul>
<li>Image classification</li>
<li>Text classification</li>
<li>Credit card fraud detection</li>
</ul>
</div>
<div class="section level2">
<h2 id="data-loading-preprocessing">Data loading &amp; preprocessing<a class="anchor" aria-label="anchor" href="#data-loading-preprocessing"></a>
</h2>
<p>Neural networks don’t process raw data, like text files, encoded JPEG
image files, or CSV files. They process <strong>vectorized</strong>
&amp; <strong>standardized</strong> representations.</p>
<ul>
<li>Text files need to be read into string tensors, then split into
words. Finally, the words need to be indexed &amp; turned into integer
tensors.</li>
<li>Images need to be read and decoded into integer tensors, then
converted to floating point and normalized to small values (usually
between 0 and 1).</li>
<li>CSV data needs to be parsed, with numerical features converted to
floating point tensors and categorical features indexed and converted to
integer tensors. Then each feature typically needs to be normalized to
zero-mean and unit-variance.</li>
<li>Etc.</li>
</ul>
<p>Let’s start with data loading.</p>
</div>
<div class="section level2">
<h2 id="data-loading">Data loading<a class="anchor" aria-label="anchor" href="#data-loading"></a>
</h2>
<p>Keras models accept three types of inputs:</p>
<ul>
<li>
<strong>NumPy arrays</strong>, just like Scikit-Learn and many other
Python-based libraries. This is a good option if your data fits in
memory.</li>
<li>
<strong><a href="https://www.tensorflow.org/guide/data" class="external-link">TensorFlow
<code>Dataset</code> objects</a></strong>. This is a high-performance
option that is more suitable for datasets that do not fit in memory and
that are streamed from disk or from a distributed filesystem.</li>
<li>
<strong>Python generators</strong> that yield batches of data (such
as custom subclasses of the <code>keras.utils.Sequence</code>
class).</li>
</ul>
<p>Before you start training a model, you will need to make your data
available as one of these formats. If you have a large dataset and you
are training on GPU(s), consider using <code>Dataset</code> objects,
since they will take care of performance-critical details, such as:</p>
<ul>
<li>Asynchronously preprocessing your data on CPU while your GPU is
busy, and buffering it into a queue.</li>
<li>Prefetching data on GPU memory so it’s immediately available when
the GPU has finished processing the previous batch, so you can reach
full GPU utilization.</li>
</ul>
<p>Keras features a range of utilities to help you turn raw data on disk
into a <code>Dataset</code>:</p>
<ul>
<li>
<code>keras.utils.image_dataset_from_directory</code> turns image
files sorted into class-specific folders into a labeled dataset of image
tensors.</li>
<li>
<code>keras.utils.text_dataset_from_directory</code> does the same
for text files.</li>
</ul>
<p>In addition, the TensorFlow <code>tf.data</code> includes other
similar utilities, such as
<code>tf.data.experimental.make_csv_dataset</code> to load structured
data from CSV files.</p>
<p><strong>Example: obtaining a labeled dataset from image files on
disk</strong></p>
<p>Supposed you have image files sorted by class in different folders,
like this:</p>
<pre><code><span><span class="va">main_directory</span><span class="op">/</span></span>
<span><span class="va">...class_a</span><span class="op">/</span></span>
<span><span class="va">......a_image_1.jpg</span></span>
<span><span class="va">......a_image_2.jpg</span></span>
<span><span class="va">...class_b</span><span class="op">/</span></span>
<span><span class="va">......b_image_1.jpg</span></span>
<span><span class="va">......b_image_2.jpg</span></span></code></pre>
<p>Then you can do:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Create a dataset.</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>dataset <span class="op">=</span> keras.utils.image_dataset_from_directory(</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="st">'path/to/main_directory'</span>, batch_size<span class="op">=</span><span class="dv">64</span>, image_size<span class="op">=</span>(<span class="dv">200</span>, <span class="dv">200</span>))</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co"># For demonstration, iterate over the batches yielded by the dataset.</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="cf">for</span> data, labels <span class="kw">in</span> dataset:</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>   <span class="bu">print</span>(data.shape)  <span class="co"># (64, 200, 200, 3)</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>   <span class="bu">print</span>(data.dtype)  <span class="co"># float32</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>   <span class="bu">print</span>(labels.shape)  <span class="co"># (64,)</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>   <span class="bu">print</span>(labels.dtype)  <span class="co"># int32</span></span></code></pre></div>
<p>The label of a sample is the rank of its folder in alphanumeric
order. Naturally, this can also be configured explicitly by passing,
e.g. <code>class_names=['class_a', 'class_b']</code>, in which cases
label <code>0</code> will be <code>class_a</code> and <code>1</code>
will be <code>class_b</code>.</p>
<p><strong>Example: obtaining a labeled dataset from text files on
disk</strong></p>
<p>Likewise for text: if you have <code>.txt</code> documents sorted by
class in different folders, you can do:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>dataset <span class="op">=</span> keras.utils.text_dataset_from_directory(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="st">'path/to/main_directory'</span>, batch_size<span class="op">=</span><span class="dv">64</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co"># For demonstration, iterate over the batches yielded by the dataset.</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="cf">for</span> data, labels <span class="kw">in</span> dataset:</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>   <span class="bu">print</span>(data.shape)  <span class="co"># (64,)</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>   <span class="bu">print</span>(data.dtype)  <span class="co"># string</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>   <span class="bu">print</span>(labels.shape)  <span class="co"># (64,)</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>   <span class="bu">print</span>(labels.dtype)  <span class="co"># int32</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="data-preprocessing-with-keras">Data preprocessing with Keras<a class="anchor" aria-label="anchor" href="#data-preprocessing-with-keras"></a>
</h2>
<p>Once your data is in the form of string/int/float NumPy arrays, or a
<code>Dataset</code> object (or Python generator) that yields batches of
string/int/float tensors, it is time to <strong>preprocess</strong> the
data. This can mean:</p>
<ul>
<li>Tokenization of string data, followed by token indexing.</li>
<li>Feature normalization.</li>
<li>Rescaling the data to small values (in general, input values to a
neural network should be close to zero – typically we expect either data
with zero-mean and unit-variance, or data in the <code>[0, 1]</code>
range.</li>
</ul>
<div class="section level3">
<h3 id="the-ideal-machine-learning-model-is-end-to-end">The ideal machine learning model is end-to-end<a class="anchor" aria-label="anchor" href="#the-ideal-machine-learning-model-is-end-to-end"></a>
</h3>
<p>In general, you should seek to do data preprocessing <strong>as part
of your model</strong> as much as possible, not via an external data
preprocessing pipeline. That’s because external data preprocessing makes
your models less portable when it’s time to use them in production.
Consider a model that processes text: it uses a specific tokenization
algorithm and a specific vocabulary index. When you want to ship your
model to a mobile app or a JavaScript app, you will need to recreate the
exact same preprocessing setup in the target language. This can get very
tricky: any small discrepancy between the original pipeline and the one
you recreate has the potential to completely invalidate your model, or
at least severely degrade its performance.</p>
<p>It would be much easier to be able to simply export an end-to-end
model that already includes preprocessing. <strong>The ideal model
should expect as input something as close as possible to raw data: an
image model should expect RGB pixel values in the <code>[0, 255]</code>
range, and a text model should accept strings of <code>utf-8</code>
characters.</strong> That way, the consumer of the exported model
doesn’t have to know about the preprocessing pipeline.</p>
</div>
<div class="section level3">
<h3 id="using-keras-preprocessing-layers">Using Keras preprocessing layers<a class="anchor" aria-label="anchor" href="#using-keras-preprocessing-layers"></a>
</h3>
<p>In Keras, you do in-model data preprocessing via
<strong>preprocessing layers</strong>. This includes:</p>
<ul>
<li>Vectorizing raw strings of text via the
<code>TextVectorization</code> layer</li>
<li>Feature normalization via the <code>Normalization</code> layer</li>
<li>Image rescaling, cropping, or image data augmentation</li>
</ul>
<p>The key advantage of using Keras preprocessing layers is that
<strong>they can be included directly into your model</strong>, either
during training or after training, which makes your models portable.</p>
<p>Some preprocessing layers have a state:</p>
<ul>
<li>
<code>TextVectorization</code> holds an index mapping words or
tokens to integer indices</li>
<li>
<code>Normalization</code> holds the mean and variance of your
features</li>
</ul>
<p>The state of a preprocessing layer is obtained by calling
<code>layer.adapt(data)</code> on a sample of the training data (or all
of it).</p>
<p><strong>Example: turning strings into sequences of integer word
indices</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">from</span> tensorflow.keras.layers <span class="im">import</span> TextVectorization</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co"># Example training data, of dtype `string`.</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>training_data <span class="op">=</span> np.array([[<span class="st">"This is the 1st sample."</span>], [<span class="st">"And here's the 2nd sample."</span>]])</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co"># Create a TextVectorization layer instance. It can be configured to either</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co"># return integer token indices, or a dense token representation (e.g. multi-hot</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co"># or TF-IDF). The text standardization and text splitting algorithms are fully</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co"># configurable.</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>vectorizer <span class="op">=</span> TextVectorization(output_mode<span class="op">=</span><span class="st">"int"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co"># Calling `adapt` on an array or dataset makes the layer generate a vocabulary</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co"># index for the data, which can then be reused when seeing new data.</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>vectorizer.adapt(training_data)</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co"># After calling adapt, the layer is able to encode any n-gram it has seen before</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co"># in the `adapt()` data. Unknown n-grams are encoded via an "out-of-vocabulary"</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="co"># token.</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>integer_data <span class="op">=</span> vectorizer(training_data)</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a><span class="bu">print</span>(integer_data)</span></code></pre></div>
<p><strong>Example: turning strings into sequences of one-hot encoded
bigrams</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">from</span> tensorflow.keras.layers <span class="im">import</span> TextVectorization</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># Example training data, of dtype `string`.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>training_data <span class="op">=</span> np.array([[<span class="st">"This is the 1st sample."</span>], [<span class="st">"And here's the 2nd sample."</span>]])</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># Create a TextVectorization layer instance. It can be configured to either</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co"># return integer token indices, or a dense token representation (e.g. multi-hot</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co"># or TF-IDF). The text standardization and text splitting algorithms are fully</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co"># configurable.</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>vectorizer <span class="op">=</span> TextVectorization(output_mode<span class="op">=</span><span class="st">"binary"</span>, ngrams<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co"># Calling `adapt` on an array or dataset makes the layer generate a vocabulary</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co"># index for the data, which can then be reused when seeing new data.</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>vectorizer.adapt(training_data)</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="co"># After calling adapt, the layer is able to encode any n-gram it has seen before</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a><span class="co"># in the `adapt()` data. Unknown n-grams are encoded via an "out-of-vocabulary"</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a><span class="co"># token.</span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>integer_data <span class="op">=</span> vectorizer(training_data)</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="bu">print</span>(integer_data)</span></code></pre></div>
<p><strong>Example: normalizing features</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">from</span> tensorflow.keras.layers <span class="im">import</span> Normalization</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co"># Example image data, with values in the [0, 255] range</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>training_data <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">256</span>, size<span class="op">=</span>(<span class="dv">64</span>, <span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">3</span>)).astype(<span class="st">"float32"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>normalizer <span class="op">=</span> Normalization(axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>normalizer.adapt(training_data)</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>normalized_data <span class="op">=</span> normalizer(training_data)</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"var: </span><span class="sc">%.4f</span><span class="st">"</span> <span class="op">%</span> np.var(normalized_data))</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"mean: </span><span class="sc">%.4f</span><span class="st">"</span> <span class="op">%</span> np.mean(normalized_data))</span></code></pre></div>
<p><strong>Example: rescaling &amp; center-cropping images</strong></p>
<p>Both the <code>Rescaling</code> layer and the <code>CenterCrop</code>
layer are stateless, so it isn’t necessary to call <code><a href="../../reference/adapt.html">adapt()</a></code>
in this case.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> tensorflow.keras.layers <span class="im">import</span> CenterCrop</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="im">from</span> tensorflow.keras.layers <span class="im">import</span> Rescaling</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co"># Example image data, with values in the [0, 255] range</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>training_data <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">256</span>, size<span class="op">=</span>(<span class="dv">64</span>, <span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">3</span>)).astype(<span class="st">"float32"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>cropper <span class="op">=</span> CenterCrop(height<span class="op">=</span><span class="dv">150</span>, width<span class="op">=</span><span class="dv">150</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>scaler <span class="op">=</span> Rescaling(scale<span class="op">=</span><span class="fl">1.0</span> <span class="op">/</span> <span class="dv">255</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>output_data <span class="op">=</span> scaler(cropper(training_data))</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"shape:"</span>, output_data.shape)</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"min:"</span>, np.<span class="bu">min</span>(output_data))</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"max:"</span>, np.<span class="bu">max</span>(output_data))</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="building-models-with-the-keras-functional-api">Building models with the Keras Functional API<a class="anchor" aria-label="anchor" href="#building-models-with-the-keras-functional-api"></a>
</h2>
<p>A “layer” is a simple input-output transformation (such as the
scaling &amp; center-cropping transformations above). For instance,
here’s a linear projection layer that maps its inputs to a
16-dimensional feature space:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>dense <span class="op">=</span> keras.layers.Dense(units<span class="op">=</span><span class="dv">16</span>)</span></code></pre></div>
<p>A “model” is a directed acyclic graph of layers. You can think of a
model as a “bigger layer” that encompasses multiple sublayers and that
can be trained via exposure to data.</p>
<p>The most common and most powerful way to build Keras models is the
Functional API. To build models with the Functional API, you start by
specifying the shape (and optionally the dtype) of your inputs. If any
dimension of your input can vary, you can specify it as
<code>None</code>. For instance, an input for 200x200 RGB image would
have shape <code>(200, 200, 3)</code>, but an input for RGB images of
any size would have shape <code>(None,  None, 3)</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Let's say we expect our inputs to be RGB images of arbitrary size</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="va">None</span>, <span class="va">None</span>, <span class="dv">3</span>))</span></code></pre></div>
<p>After defining your input(s), you can chain layer transformations on
top of your inputs, until your final output:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> tensorflow.keras <span class="im">import</span> layers</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># Center-crop images to 150x150</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>x <span class="op">=</span> CenterCrop(height<span class="op">=</span><span class="dv">150</span>, width<span class="op">=</span><span class="dv">150</span>)(inputs)</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co"># Rescale images to [0, 1]</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>x <span class="op">=</span> Rescaling(scale<span class="op">=</span><span class="fl">1.0</span> <span class="op">/</span> <span class="dv">255</span>)(x)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co"># Apply some convolution and pooling layers</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>x <span class="op">=</span> layers.Conv2D(filters<span class="op">=</span><span class="dv">32</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>), activation<span class="op">=</span><span class="st">"relu"</span>)(x)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>x <span class="op">=</span> layers.MaxPooling2D(pool_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))(x)</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>x <span class="op">=</span> layers.Conv2D(filters<span class="op">=</span><span class="dv">32</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>), activation<span class="op">=</span><span class="st">"relu"</span>)(x)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>x <span class="op">=</span> layers.MaxPooling2D(pool_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))(x)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>x <span class="op">=</span> layers.Conv2D(filters<span class="op">=</span><span class="dv">32</span>, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>), activation<span class="op">=</span><span class="st">"relu"</span>)(x)</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="co"># Apply global average pooling to get flat feature vectors</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>x <span class="op">=</span> layers.GlobalAveragePooling2D()(x)</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a><span class="co"># Add a dense classifier on top</span></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>num_classes <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(num_classes, activation<span class="op">=</span><span class="st">"softmax"</span>)(x)</span></code></pre></div>
<p>Once you have defined the directed acyclic graph of layers that turns
your input(s) into your outputs, instantiate a <code>Model</code>
object:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs<span class="op">=</span>inputs, outputs<span class="op">=</span>outputs)</span></code></pre></div>
<p>This model behaves basically like a bigger layer. You can call it on
batches of data, like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>data <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">256</span>, size<span class="op">=</span>(<span class="dv">64</span>, <span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">3</span>)).astype(<span class="st">"float32"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>processed_data <span class="op">=</span> model(data)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="bu">print</span>(processed_data.shape)</span></code></pre></div>
<p>You can print a summary of how your data gets transformed at each
stage of the model. This is useful for debugging.</p>
<p>Note that the output shape displayed for each layer includes the
<strong>batch size</strong>. Here the batch size is None, which
indicates our model can process batches of any size.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>model.summary()</span></code></pre></div>
<p>The Functional API also makes it easy to build models that have
multiple inputs (for instance, an image <em>and</em> its metadata) or
multiple outputs (for instance, predicting the class of the image
<em>and</em> the likelihood that a user will click on it). For a deeper
dive into what you can do, see our <a href="/guides/functional_api/">guide to the Functional API</a>.</p>
</div>
<div class="section level2">
<h2 id="training-models-with-fit">Training models with <code>fit()</code><a class="anchor" aria-label="anchor" href="#training-models-with-fit"></a>
</h2>
<p>At this point, you know:</p>
<ul>
<li>How to prepare your data (e.g. as a NumPy array or a
<code>tf.data.Dataset</code> object)</li>
<li>How to build a model that will process your data</li>
</ul>
<p>The next step is to train your model on your data. The
<code>Model</code> class features a built-in training loop, the
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> method. It accepts <code>Dataset</code> objects,
Python generators that yield batches of data, or NumPy arrays.</p>
<p>Before you can call <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, you need to specify an
optimizer and a loss function (we assume you are already familiar with
these concepts). This is the <code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code> step:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span>keras.optimizers.RMSprop(learning_rate<span class="op">=</span><span class="fl">1e-3</span>),</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>              loss<span class="op">=</span>keras.losses.CategoricalCrossentropy())</span></code></pre></div>
<p>Loss and optimizer can be specified via their string identifiers (in
this case their default constructor argument values are used):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">'rmsprop'</span>, loss<span class="op">=</span><span class="st">'categorical_crossentropy'</span>)</span></code></pre></div>
<p>Once your model is compiled, you can start “fitting” the model to the
data. Here’s what fitting a model looks like with NumPy data:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>model.fit(numpy_array_of_samples, numpy_array_of_labels,</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>          batch_size<span class="op">=</span><span class="dv">32</span>, epochs<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div>
<p>Besides the data, you have to specify two key parameters: the
<code>batch_size</code> and the number of epochs (iterations on the
data). Here our data will get sliced on batches of 32 samples, and the
model will iterate 10 times over the data during training.</p>
<p>Here’s what fitting a model looks like with a dataset:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>model.fit(dataset_of_samples_and_labels, epochs<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div>
<p>Since the data yielded by a dataset is expected to be already
batched, you don’t need to specify the batch size here.</p>
<p>Let’s look at it in practice with a toy example model that learns to
classify MNIST digits:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Get the data as Numpy arrays</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>(x_train, y_train), (x_test, y_test) <span class="op">=</span> keras.datasets.mnist.load_data()</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co"># Build a simple model</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">28</span>, <span class="dv">28</span>))</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>x <span class="op">=</span> layers.Rescaling(<span class="fl">1.0</span> <span class="op">/</span> <span class="dv">255</span>)(inputs)</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>x <span class="op">=</span> layers.Flatten()(x)</span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">128</span>, activation<span class="op">=</span><span class="st">"relu"</span>)(x)</span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">128</span>, activation<span class="op">=</span><span class="st">"relu"</span>)(x)</span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">"softmax"</span>)(x)</span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs, outputs)</span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>model.summary()</span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a><span class="co"># Compile the model</span></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">"adam"</span>, loss<span class="op">=</span><span class="st">"sparse_categorical_crossentropy"</span>)</span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a><span class="co"># Train the model for 1 epoch from Numpy data</span></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fit on NumPy data"</span>)</span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a>history <span class="op">=</span> model.fit(x_train, y_train, batch_size<span class="op">=</span>batch_size, epochs<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a><span class="co"># Train the model for 1 epoch using a dataset</span></span>
<span id="cb19-23"><a href="#cb19-23" tabindex="-1"></a>dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(batch_size)</span>
<span id="cb19-24"><a href="#cb19-24" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fit on Dataset"</span>)</span>
<span id="cb19-25"><a href="#cb19-25" tabindex="-1"></a>history <span class="op">=</span> model.fit(dataset, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<p>The <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> call returns a “history” object which records
what happened over the course of training. The
<code>history.history</code> dict contains per-epoch timeseries of
metrics values (here we have only one metric, the loss, and one epoch,
so we only get a single scalar):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="bu">print</span>(history.history)</span></code></pre></div>
<p>For a detailed overview of how to use <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, see the <a href="/guides/training_with_built_in_methods/">guide to training &amp;
evaluation with the built-in Keras methods</a>.</p>
<div class="section level3">
<h3 id="keeping-track-of-performance-metrics">Keeping track of performance metrics<a class="anchor" aria-label="anchor" href="#keeping-track-of-performance-metrics"></a>
</h3>
<p>As you’re training a model, you want to keep track of metrics such as
classification accuracy, precision, recall, AUC, etc. Besides, you want
to monitor these metrics not only on the training data, but also on a
validation set.</p>
<p><strong>Monitoring metrics</strong></p>
<p>You can pass a list of metric objects to <code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code>, like
this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>    optimizer<span class="op">=</span><span class="st">"adam"</span>,</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>    loss<span class="op">=</span><span class="st">"sparse_categorical_crossentropy"</span>,</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>    metrics<span class="op">=</span>[keras.metrics.SparseCategoricalAccuracy(name<span class="op">=</span><span class="st">"acc"</span>)],</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>history <span class="op">=</span> model.fit(dataset, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<p><strong>Passing validation data to <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code></strong></p>
<p>You can pass validation data to <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> to monitor your
validation loss &amp; validation metrics. Validation metrics get
reported at the end of each epoch.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>val_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(batch_size)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>history <span class="op">=</span> model.fit(dataset, epochs<span class="op">=</span><span class="dv">1</span>, validation_data<span class="op">=</span>val_dataset)</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="using-callbacks-for-checkpointing-and-more">Using callbacks for checkpointing (and more)<a class="anchor" aria-label="anchor" href="#using-callbacks-for-checkpointing-and-more"></a>
</h3>
<p>If training goes on for more than a few minutes, it’s important to
save your model at regular intervals during training. You can then use
your saved models to restart training in case your training process
crashes (this is important for multi-worker distributed training, since
with many workers at least one of them is bound to fail at some
point).</p>
<p>An important feature of Keras is <strong>callbacks</strong>,
configured in <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>. Callbacks are objects that get called
by the model at different point during training, in particular:</p>
<ul>
<li>At the beginning and end of each batch</li>
<li>At the beginning and end of each epoch</li>
</ul>
<p>Callbacks are a way to make model trainable entirely scriptable.</p>
<p>You can use callbacks to periodically save your model. Here’s a
simple example: a <code>ModelCheckpoint</code> callback configured to
save the model at the end of every epoch. The filename will include the
current epoch.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>callbacks <span class="op">=</span> [</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>    keras.callbacks.ModelCheckpoint(</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>        filepath<span class="op">=</span><span class="st">'path/to/my/model_</span><span class="sc">{epoch}</span><span class="st">'</span>,</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>        save_freq<span class="op">=</span><span class="st">'epoch'</span>)</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>]</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>model.fit(dataset, epochs<span class="op">=</span><span class="dv">2</span>, callbacks<span class="op">=</span>callbacks)</span></code></pre></div>
<p>You can also use callbacks to do things like periodically changing
the learning of your optimizer, streaming metrics to a Slack bot,
sending yourself an email notification when training is complete,
etc.</p>
<p>For detailed overview of what callbacks are available and how to
write your own, see the <a href="/api/callbacks/">callbacks API
documentation</a> and the <a href="/guides/writing_your_own_callbacks/">guide to writing custom
callbacks</a>.</p>
</div>
<div class="section level3">
<h3 id="monitoring-training-progress-with-tensorboard">Monitoring training progress with TensorBoard<a class="anchor" aria-label="anchor" href="#monitoring-training-progress-with-tensorboard"></a>
</h3>
<p>Staring at the Keras progress bar isn’t the most ergonomic way to
monitor how your loss and metrics are evolving over time. There’s a
better solution: <a href="https://www.tensorflow.org/tensorboard" class="external-link">TensorBoard</a>, a web
application that can display real-time graphs of your metrics (and
more).</p>
<p>To use TensorBoard with <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, simply pass a
<code>keras.callbacks.TensorBoard</code> callback specifying the
directory where to store TensorBoard logs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>callbacks <span class="op">=</span> [</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>    keras.callbacks.TensorBoard(log_dir<span class="op">=</span><span class="st">'./logs'</span>)</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>]</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>model.fit(dataset, epochs<span class="op">=</span><span class="dv">2</span>, callbacks<span class="op">=</span>callbacks)</span></code></pre></div>
<p>You can then launch a TensorBoard instance that you can open in your
browser to monitor the logs getting written to this location:</p>
<pre><code><span><span class="va">tensorboard</span> <span class="op">-</span><span class="op">-</span><span class="va">logdir</span><span class="op">=</span><span class="va">.</span><span class="op">/</span><span class="va">logs</span></span></code></pre>
<p>What’s more, you can launch an in-line TensorBoard tab when training
models in Jupyter / Colab notebooks. <a href="https://www.tensorflow.org/tensorboard/tensorboard_in_notebooks" class="external-link">Here’s
more information</a>.</p>
</div>
<div class="section level3">
<h3 id="after-fit-evaluating-test-performance-generating-predictions-on-new-data">After <code>fit()</code>: evaluating test performance &amp;
generating predictions on new data<a class="anchor" aria-label="anchor" href="#after-fit-evaluating-test-performance-generating-predictions-on-new-data"></a>
</h3>
<p>Once you have a trained model, you can evaluate its loss and metrics
on new data via <code><a href="https://rdrr.io/pkg/tensorflow/man/evaluate.html" class="external-link">evaluate()</a></code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>loss, acc <span class="op">=</span> model.evaluate(val_dataset)  <span class="co"># returns loss and metrics</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"loss: </span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span> loss)</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"acc: </span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span> acc)</span></code></pre></div>
<p>You can also generate NumPy arrays of predictions (the activations of
the output layer(s) in the model) via <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>predictions <span class="op">=</span> model.predict(val_dataset)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="bu">print</span>(predictions.shape)</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="using-fit-with-a-custom-training-step">Using <code>fit()</code> with a custom training step<a class="anchor" aria-label="anchor" href="#using-fit-with-a-custom-training-step"></a>
</h2>
<p>By default, <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> is configured for <strong>supervised
learning</strong>. If you need a different kind of training loop (for
instance, a GAN training loop), you can provide your own implementation
of the <code>Model.train_step()</code> method. This is the method that
is repeatedly called during <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>.</p>
<p>Metrics, callbacks, etc. will work as usual.</p>
<p>Here’s a simple example that reimplements what <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>
normally does:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="kw">class</span> CustomModel(keras.Model):</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>    <span class="kw">def</span> train_step(<span class="va">self</span>, data):</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>        <span class="co"># Unpack the data. Its structure depends on your model and</span></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>        <span class="co"># on what you pass to `fit()`.</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>        x, y <span class="op">=</span> data</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>        <span class="cf">with</span> tf.GradientTape() <span class="im">as</span> tape:</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>            y_pred <span class="op">=</span> <span class="va">self</span>(x, training<span class="op">=</span><span class="va">True</span>)  <span class="co"># Forward pass</span></span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>            <span class="co"># Compute the loss value</span></span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>            <span class="co"># (the loss function is configured in `compile()`)</span></span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>            loss <span class="op">=</span> <span class="va">self</span>.compute_loss(y<span class="op">=</span>y, y_pred<span class="op">=</span>y_pred)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>        <span class="co"># Compute gradients</span></span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>        trainable_vars <span class="op">=</span> <span class="va">self</span>.trainable_variables</span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>        gradients <span class="op">=</span> tape.gradient(loss, trainable_vars)</span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>        <span class="co"># Update weights</span></span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>        <span class="va">self</span>.optimizer.apply_gradients(<span class="bu">zip</span>(gradients, trainable_vars))</span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>        <span class="co"># Update metrics (includes the metric that tracks the loss)</span></span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>        <span class="cf">for</span> metric <span class="kw">in</span> <span class="va">self</span>.metrics:</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>            <span class="cf">if</span> metric.name <span class="op">==</span> <span class="st">"loss"</span>:</span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a>                metric.update_state(loss)</span>
<span id="cb28-20"><a href="#cb28-20" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb28-21"><a href="#cb28-21" tabindex="-1"></a>                metric.update_state(y, y_pred)</span>
<span id="cb28-22"><a href="#cb28-22" tabindex="-1"></a>        <span class="co"># Return a dict mapping metric names to current value</span></span>
<span id="cb28-23"><a href="#cb28-23" tabindex="-1"></a>        <span class="cf">return</span> {m.name: m.result() <span class="cf">for</span> m <span class="kw">in</span> <span class="va">self</span>.metrics}</span>
<span id="cb28-24"><a href="#cb28-24" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" tabindex="-1"></a><span class="co"># Construct and compile an instance of CustomModel</span></span>
<span id="cb28-26"><a href="#cb28-26" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">32</span>,))</span>
<span id="cb28-27"><a href="#cb28-27" tabindex="-1"></a>outputs <span class="op">=</span> keras.layers.Dense(<span class="dv">1</span>)(inputs)</span>
<span id="cb28-28"><a href="#cb28-28" tabindex="-1"></a>model <span class="op">=</span> CustomModel(inputs, outputs)</span>
<span id="cb28-29"><a href="#cb28-29" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">'adam'</span>, loss<span class="op">=</span><span class="st">'mse'</span>, metrics<span class="op">=</span>[...])</span>
<span id="cb28-30"><a href="#cb28-30" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" tabindex="-1"></a><span class="co"># Just use `fit` as usual</span></span>
<span id="cb28-32"><a href="#cb28-32" tabindex="-1"></a>model.fit(dataset, epochs<span class="op">=</span><span class="dv">3</span>, callbacks<span class="op">=</span>...)</span></code></pre></div>
<p>For a detailed overview of how you customize the built-in training
&amp; evaluation loops, see the guide: <a href="/guides/customizing_what_happens_in_fit/">“Customizing what
happens in <code>fit()</code>”</a>.</p>
</div>
<div class="section level2">
<h2 id="debugging-your-model-with-eager-execution">Debugging your model with eager execution<a class="anchor" aria-label="anchor" href="#debugging-your-model-with-eager-execution"></a>
</h2>
<p>If you write custom training steps or custom layers, you will need to
debug them. The debugging experience is an integral part of a framework:
with Keras, the debugging workflow is designed with the user in
mind.</p>
<p>By default, your Keras models are compiled to highly-optimized
computation graphs that deliver fast execution times. That means that
the Python code you write (e.g. in a custom <code>train_step</code>) is
not the code you are actually executing. This introduces a layer of
indirection that can make debugging hard.</p>
<p>Debugging is best done step by step. You want to be able to sprinkle
your code with <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> statement to see what your data
looks like after every operation, you want to be able to use
<code>pdb</code>. You can achieve this by <strong>running your model
eagerly</strong>. With eager execution, the Python code you write is the
code that gets executed.</p>
<p>Simply pass <code>run_eagerly=True</code> to
<code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">'adam'</span>, loss<span class="op">=</span><span class="st">'mse'</span>, run_eagerly<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>Of course, the downside is that it makes your model significantly
slower. Make sure to switch it back off to get the benefits of compiled
computation graphs once you are done debugging!</p>
<p>In general, you will use <code>run_eagerly=True</code> every time you
need to debug what’s happening inside your <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> call.</p>
</div>
<div class="section level2">
<h2 id="speeding-up-training-with-multiple-gpus">Speeding up training with multiple GPUs<a class="anchor" aria-label="anchor" href="#speeding-up-training-with-multiple-gpus"></a>
</h2>
<p>Keras has built-in industry-strength support for multi-GPU training
and distributed multi-worker training, via the
<code>tf.distribute</code> API.</p>
<p>If you have multiple GPUs on your machine, you can train your model
on all of them by:</p>
<ul>
<li>Creating a <code>tf.distribute.MirroredStrategy</code> object</li>
<li>Building &amp; compiling your model inside the strategy’s scope</li>
<li>Calling <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> and <code><a href="https://rdrr.io/pkg/tensorflow/man/evaluate.html" class="external-link">evaluate()</a></code> on a dataset
as usual</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co"># Create a MirroredStrategy.</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>strategy <span class="op">=</span> tf.distribute.MirroredStrategy()</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a><span class="co"># Open a strategy scope.</span></span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a><span class="cf">with</span> strategy.scope():</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>    <span class="co"># Everything that creates variables should be under the strategy scope.</span></span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>    <span class="co"># In general this is only model construction &amp; `compile()`.</span></span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>    model <span class="op">=</span> Model(...)</span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>    model.<span class="bu">compile</span>(...)</span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a><span class="co"># Train the model on all available devices.</span></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a>train_dataset, val_dataset, test_dataset <span class="op">=</span> get_dataset()</span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">2</span>, validation_data<span class="op">=</span>val_dataset)</span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a><span class="co"># Test the model on all available devices.</span></span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a>model.evaluate(test_dataset)</span></code></pre></div>
<p>For a detailed introduction to multi-GPU &amp; distributed training,
see <a href="/guides/distributed_training/">this guide</a>.</p>
</div>
<div class="section level2">
<h2 id="doing-preprocessing-synchronously-on-device-vs--asynchronously-on-host-cpu">Doing preprocessing synchronously on-device vs. asynchronously on
host CPU<a class="anchor" aria-label="anchor" href="#doing-preprocessing-synchronously-on-device-vs--asynchronously-on-host-cpu"></a>
</h2>
<p>You’ve learned about preprocessing, and you’ve seen example where we
put image preprocessing layers (<code>CenterCrop</code> and
<code>Rescaling</code>) directly inside our model.</p>
<p>Having preprocessing happen as part of the model during training is
great if you want to do on-device preprocessing, for instance,
GPU-accelerated feature normalization or image augmentation. But there
are kinds of preprocessing that are not suited to this setup: in
particular, text preprocessing with the <code>TextVectorization</code>
layer. Due to its sequential nature and due to the fact that it can only
run on CPU, it’s often a good idea to do <strong>asynchronous
preprocessing</strong>.</p>
<p>With asynchronous preprocessing, your preprocessing operations will
run on CPU, and the preprocessed samples will be buffered into a queue
while your GPU is busy with previous batch of data. The next batch of
preprocessed samples will then be fetched from the queue to the GPU
memory right before the GPU becomes available again (prefetching). This
ensures that preprocessing will not be blocking and that your GPU can
run at full utilization.</p>
<p>To do asynchronous preprocessing, simply use <code>dataset.map</code>
to inject a preprocessing operation into your data pipeline:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># Example training data, of dtype `string`.</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>samples <span class="op">=</span> np.array([[<span class="st">"This is the 1st sample."</span>], [<span class="st">"And here's the 2nd sample."</span>]])</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>labels <span class="op">=</span> [[<span class="dv">0</span>], [<span class="dv">1</span>]]</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co"># Prepare a TextVectorization layer.</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>vectorizer <span class="op">=</span> TextVectorization(output_mode<span class="op">=</span><span class="st">"int"</span>)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>vectorizer.adapt(samples)</span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co"># Asynchronous preprocessing: the text vectorization is part of the tf.data pipeline.</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a><span class="co"># First, create a dataset</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a>dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((samples, labels)).batch(<span class="dv">2</span>)</span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="co"># Apply text vectorization to the samples</span></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>dataset <span class="op">=</span> dataset.<span class="bu">map</span>(<span class="kw">lambda</span> x, y: (vectorizer(x), y))</span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a><span class="co"># Prefetch with a buffer size of 2 batches</span></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a>dataset <span class="op">=</span> dataset.prefetch(<span class="dv">2</span>)</span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a><span class="co"># Our model should expect sequences of integers as inputs</span></span>
<span id="cb31-18"><a href="#cb31-18" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="va">None</span>,), dtype<span class="op">=</span><span class="st">"int64"</span>)</span>
<span id="cb31-19"><a href="#cb31-19" tabindex="-1"></a>x <span class="op">=</span> layers.Embedding(input_dim<span class="op">=</span><span class="dv">10</span>, output_dim<span class="op">=</span><span class="dv">32</span>)(inputs)</span>
<span id="cb31-20"><a href="#cb31-20" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(<span class="dv">1</span>)(x)</span>
<span id="cb31-21"><a href="#cb31-21" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs, outputs)</span>
<span id="cb31-22"><a href="#cb31-22" tabindex="-1"></a></span>
<span id="cb31-23"><a href="#cb31-23" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">"adam"</span>, loss<span class="op">=</span><span class="st">"mse"</span>, run_eagerly<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-24"><a href="#cb31-24" tabindex="-1"></a>model.fit(dataset)</span></code></pre></div>
<p>Compare this to doing text vectorization as part of the model:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="co"># Our dataset will yield samples that are strings</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((samples, labels)).batch(<span class="dv">2</span>)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="co"># Our model should expect strings as inputs</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">1</span>,), dtype<span class="op">=</span><span class="st">"string"</span>)</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>x <span class="op">=</span> vectorizer(inputs)</span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>x <span class="op">=</span> layers.Embedding(input_dim<span class="op">=</span><span class="dv">10</span>, output_dim<span class="op">=</span><span class="dv">32</span>)(x)</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(<span class="dv">1</span>)(x)</span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs, outputs)</span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">"adam"</span>, loss<span class="op">=</span><span class="st">"mse"</span>, run_eagerly<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a>model.fit(dataset)</span></code></pre></div>
<p>When training text models on CPU, you will generally not see any
performance difference between the two setups. When training on GPU,
however, doing asynchronous buffered preprocessing on the host CPU while
the GPU is running the model itself can result in a significant
speedup.</p>
<p>After training, if you want to export an end-to-end model that
includes the preprocessing layer(s), this is easy to do, since
<code>TextVectorization</code> is a layer:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">1</span>,), dtype<span class="op">=</span><span class="st">'string'</span>)</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>x <span class="op">=</span> vectorizer(inputs)</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>outputs <span class="op">=</span> trained_model(x)</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>end_to_end_model <span class="op">=</span> keras.Model(inputs, outputs)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="finding-the-best-model-configuration-with-hyperparameter-tuning">Finding the best model configuration with hyperparameter tuning<a class="anchor" aria-label="anchor" href="#finding-the-best-model-configuration-with-hyperparameter-tuning"></a>
</h2>
<p>Once you have a working model, you’re going to want to optimize its
configuration – architecture choices, layer sizes, etc. Human intuition
can only go so far, so you’ll want to leverage a systematic approach:
hyperparameter search.</p>
<p>You can use <a href="https://keras.io/api/keras_tuner/tuners/" class="external-link">KerasTuner</a> to find
the best hyperparameter for your Keras models. It’s as easy as calling
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>.</p>
<p>Here how it works.</p>
<p>First, place your model definition in a function, that takes a single
<code>hp</code> argument. Inside this function, replace any value you
want to tune with a call to hyperparameter sampling methods,
e.g. <code>hp.Int()</code> or <code>hp.Choice()</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="kw">def</span> build_model(hp):</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>    inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">784</span>,))</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>    x <span class="op">=</span> layers.Dense(</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>        units<span class="op">=</span>hp.Int(<span class="st">'units'</span>, min_value<span class="op">=</span><span class="dv">32</span>, max_value<span class="op">=</span><span class="dv">512</span>, step<span class="op">=</span><span class="dv">32</span>),</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>        activation<span class="op">=</span><span class="st">'relu'</span>)(inputs)</span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>    outputs <span class="op">=</span> layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">'softmax'</span>)(x)</span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>    model <span class="op">=</span> keras.Model(inputs, outputs)</span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a>    model.<span class="bu">compile</span>(</span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a>        optimizer<span class="op">=</span>keras.optimizers.Adam(</span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a>            hp.Choice(<span class="st">'learning_rate'</span>,</span>
<span id="cb34-11"><a href="#cb34-11" tabindex="-1"></a>                      values<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-3</span>, <span class="fl">1e-4</span>])),</span>
<span id="cb34-12"><a href="#cb34-12" tabindex="-1"></a>        loss<span class="op">=</span><span class="st">'sparse_categorical_crossentropy'</span>,</span>
<span id="cb34-13"><a href="#cb34-13" tabindex="-1"></a>        metrics<span class="op">=</span>[<span class="st">'accuracy'</span>])</span>
<span id="cb34-14"><a href="#cb34-14" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre></div>
<p>The function should return a compiled model.</p>
<p>Next, instantiate a tuner object specifying your optimization
objective and other search parameters:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="im">import</span> keras_tuner</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>tuner <span class="op">=</span> keras_tuner.tuners.Hyperband(</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>    build_model,</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>    objective<span class="op">=</span><span class="st">'val_loss'</span>,</span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>    max_epochs<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>    max_trials<span class="op">=</span><span class="dv">200</span>,</span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a>    executions_per_trial<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a>    directory<span class="op">=</span><span class="st">'my_dir'</span>)</span></code></pre></div>
<p>Finally, start the search with the <code><a href="https://rdrr.io/r/base/search.html" class="external-link">search()</a></code> method,
which takes the same arguments as <code>Model.fit()</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>tuner.search(dataset, validation_data<span class="op">=</span>val_dataset)</span></code></pre></div>
<p>When search is over, you can retrieve the best model(s):</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>models <span class="op">=</span> tuner.get_best_models(num_models<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<p>Or print a summary of the results:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>tuner.results_summary()</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="end-to-end-examples">End-to-end examples<a class="anchor" aria-label="anchor" href="#end-to-end-examples"></a>
</h2>
<p>To familiarize yourself with the concepts in this introduction, see
the following end-to-end examples:</p>
<ul>
<li><a href="/examples/nlp/text_classification_from_scratch/">Text
classification</a></li>
<li><a href="/examples/vision/image_classification_from_scratch/">Image
classification</a></li>
<li><a href="/examples/structured_data/imbalanced_classification/">Credit card
fraud detection</a></li>
</ul>
</div>
<div class="section level2">
<h2 id="what-to-learn-next">What to learn next<a class="anchor" aria-label="anchor" href="#what-to-learn-next"></a>
</h2>
<ul>
<li>Learn more about the <a href="/guides/functional_api/">Functional
API</a>.</li>
<li>Learn more about the <a href="/guides/training_with_built_in_methods/">features of
<code>fit()</code> and <code>evaluate()</code></a>.</li>
<li>Learn more about <a href="/guides/writing_your_own_callbacks/">callbacks</a>.</li>
<li>Learn more about <a href="/guides/customizing_what_happens_in_fit/">creating your own custom
training steps</a>.</li>
<li>Learn more about <a href="/guides/distributed_training/">multi-GPU
and distributed training</a>.</li>
<li>Learn how to do <a href="/guides/transfer_learning/">transfer
learning</a>.</li>
</ul>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Tomasz Kalinowski, JJ Allaire, François Chollet, Posit Software, PBC, Google.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
