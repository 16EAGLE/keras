<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Complete guide to training &amp; evaluation with `fit()` and `evaluate()`.">
<title>Training &amp; evaluation with the built-in methods • keras3</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../../apple-touch-icon-60x60.png">
<script src="../../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../../pkgdown.js"></script><meta property="og:title" content="Training &amp; evaluation with the built-in methods">
<meta property="og:description" content="Complete guide to training &amp; evaluation with `fit()` and `evaluate()`.">
<meta property="og:image" content="https://keras.posit.co/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-inverse navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../../index.html">keras3</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.13.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../../index.html">Home</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-getting-started">Getting Started</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-getting-started">
    <a class="dropdown-item" href="../../articles/intro_to_keras_for_engineers.html">Introduction to Keras for engineers</a>
    <h6 class="dropdown-header" data-toc-skip>Tutorials</h6>
    <a class="dropdown-item" href="../../articles/getting_started.html">Getting Started</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_classification.html">Basic Classification</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_text_classification.html">Text Classification</a>
    <a class="dropdown-item" href="../../articles/tutorial_basic_regression.html">Basic Regression</a>
    <a class="dropdown-item" href="../../articles/tutorial_overfit_underfit.html">Overfitting and Underfitting</a>
    <a class="dropdown-item" href="../../articles/tutorial_save_and_restore.html">Save and Restore Models</a>
  </div>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-guides">Guides</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-guides">
    <h6 class="dropdown-header" data-toc-skip>Model definition</h6>
    <a class="dropdown-item" href="../../articles/functional_api.html">Functional API</a>
    <a class="dropdown-item" href="../../articles/sequential_model.html">Sequential Model</a>
    <h6 class="dropdown-header" data-toc-skip>Extending and customizing</h6>
    <a class="dropdown-item" href="../../articles/making_new_layers_and_models_via_subclassing.html">Making new layers and models via subclassing</a>
    <a class="dropdown-item" href="../../articles/training_with_built_in_methods.html">Training &amp; evaluation with the built-in methods</a>
    <a class="dropdown-item" href="../../articles/writing_a_custom_training_loop_in_tensorflow.html">Writing a training loop from scratch in TensorFlow</a>
    <a class="dropdown-item" href="../../articles/writing_your_own_callbacks.html">Writing Your Own Callbacks</a>
    <h6 class="dropdown-header" data-toc-skip>Other topics</h6>
    <a class="dropdown-item" href="../../articles/transfer_learning.html">Transfer learning and fine tuning</a>
    <a class="dropdown-item" href="../../articles/distributed_training_with_tensorflow.html">Distributed training with TensorFlow</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../articles/examples/index.html">Examples</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../news/index.html">News</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/rstudio/keras/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../../logo.png" class="logo" alt=""><h1>Training &amp; evaluation with the built-in methods</h1>
                        <h4 data-toc-skip class="author"><a href="https://twitter.com/fchollet" class="external-link">fchollet</a></h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/keras/blob/HEAD/vignettes/guides/training_with_built_in_methods.Rmd" class="external-link"><code>vignettes/guides/training_with_built_in_methods.Rmd</code></a></small>
      <div class="d-none name"><code>training_with_built_in_methods.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># We import torch &amp; TF so as to use torch Dataloaders &amp; tf.data.Datasets.</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">import</span> keras <span class="im">as</span> keras</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">from</span> keras <span class="im">import</span> layers</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> keras <span class="im">import</span> ops</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This guide covers training, evaluation, and prediction (inference)
models when using built-in APIs for training &amp; validation (such as
<code>Model.fit()</code>, <code>Model.evaluate()</code> and
<code>Model.predict()</code>).</p>
<p>If you are interested in leveraging <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> while
specifying your own training step function, see the <a href="/guides/customizing_what_happens_in_fit/">Customizing what happens
in <code>fit()</code> guide</a>.</p>
<p>If you are interested in writing your own training &amp; evaluation
loops from scratch, see the guide <a href="/guides/writing_a_training_loop_from_scratch/">“writing a training
loop from scratch”</a>.</p>
<p>In general, whether you are using built-in loops or writing your own,
model training &amp; evaluation works strictly in the same way across
every kind of Keras model – Sequential models, models built with the
Functional API, and models written from scratch via model
subclassing.</p>
<p>This guide doesn’t cover distributed training, which is covered in
our <a href="https://keras.io/guides/distributed_training/" class="external-link">guide to
multi-GPU &amp; distributed training</a>.</p>
</div>
<div class="section level2">
<h2 id="api-overview-a-first-end-to-end-example">API overview: a first end-to-end example<a class="anchor" aria-label="anchor" href="#api-overview-a-first-end-to-end-example"></a>
</h2>
<p>When passing data to the built-in training loops of a model, you
should either use:</p>
<ul>
<li>NumPy arrays (if your data is small and fits in memory)</li>
<li>Subclasses of <code>keras.utils.PyDataset</code>
</li>
<li>
<code>tf.data.Dataset</code> objects</li>
<li>PyTorch <code>DataLoader</code> instances</li>
</ul>
<p>In the next few paragraphs, we’ll use the MNIST dataset as NumPy
arrays, in order to demonstrate how to use optimizers, losses, and
metrics. Afterwards, we’ll take a close look at each of the other
options.</p>
<p>Let’s consider the following model (here, we build in with the
Functional API, but it could be a Sequential model or a subclassed model
as well):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">784</span>,), name<span class="op">=</span><span class="st">"digits"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_1"</span>)(inputs)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_2"</span>)(x)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">"softmax"</span>, name<span class="op">=</span><span class="st">"predictions"</span>)(x)</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs<span class="op">=</span>inputs, outputs<span class="op">=</span>outputs)</span></code></pre></div>
<p>Here’s what the typical end-to-end workflow looks like, consisting
of:</p>
<ul>
<li>Training</li>
<li>Validation on a holdout set generated from the original training
data</li>
<li>Evaluation on the test data</li>
</ul>
<p>We’ll use MNIST data for this example.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>(x_train, y_train), (x_test, y_test) <span class="op">=</span> keras.datasets.mnist.load_data()</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># Preprocess the data (these are NumPy arrays)</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>x_train <span class="op">=</span> x_train.reshape(<span class="dv">60000</span>, <span class="dv">784</span>).astype(<span class="st">"float32"</span>) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>x_test <span class="op">=</span> x_test.reshape(<span class="dv">10000</span>, <span class="dv">784</span>).astype(<span class="st">"float32"</span>) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>y_train <span class="op">=</span> y_train.astype(<span class="st">"float32"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>y_test <span class="op">=</span> y_test.astype(<span class="st">"float32"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co"># Reserve 10,000 samples for validation</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>x_val <span class="op">=</span> x_train[<span class="op">-</span><span class="dv">10000</span>:]</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>y_val <span class="op">=</span> y_train[<span class="op">-</span><span class="dv">10000</span>:]</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>x_train <span class="op">=</span> x_train[:<span class="op">-</span><span class="dv">10000</span>]</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>y_train <span class="op">=</span> y_train[:<span class="op">-</span><span class="dv">10000</span>]</span></code></pre></div>
<p>We specify the training configuration (optimizer, loss, metrics):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(),  <span class="co"># Optimizer</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    <span class="co"># Loss function to minimize</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    loss<span class="op">=</span>keras.losses.SparseCategoricalCrossentropy(),</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="co"># List of metrics to monitor</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    metrics<span class="op">=</span>[keras.metrics.SparseCategoricalAccuracy()],</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>)</span></code></pre></div>
<p>We call <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, which will train the model by slicing the
data into “batches” of size <code>batch_size</code>, and repeatedly
iterating over the entire dataset for a given number of
<code>epochs</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fit model on training data"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>history <span class="op">=</span> model.fit(</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    x_train,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    y_train,</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">64</span>,</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    <span class="co"># We pass some validation for</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    <span class="co"># monitoring validation loss and metrics</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    <span class="co"># at the end of each epoch</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    validation_data<span class="op">=</span>(x_val, y_val),</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>)</span></code></pre></div>
<p>The returned <code>history</code> object holds a record of the loss
values and metric values during training:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>history.history</span></code></pre></div>
<p>We evaluate the model on the test data via
<code><a href="https://rdrr.io/pkg/tensorflow/man/evaluate.html" class="external-link">evaluate()</a></code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Evaluate the model on the test data using `evaluate`</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Evaluate on test data"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>results <span class="op">=</span> model.evaluate(x_test, y_test, batch_size<span class="op">=</span><span class="dv">128</span>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"test loss, test acc:"</span>, results)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co"># Generate predictions (probabilities -- the output of the last layer)</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co"># on new data using `predict`</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Generate predictions for 3 samples"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>predictions <span class="op">=</span> model.predict(x_test[:<span class="dv">3</span>])</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"predictions shape:"</span>, predictions.shape)</span></code></pre></div>
<p>Now, let’s review each piece of this workflow in detail.</p>
</div>
<div class="section level2">
<h2 id="the-compile-method-specifying-a-loss-metrics-and-an-optimizer">The <code>compile()</code> method: specifying a loss, metrics, and
an optimizer<a class="anchor" aria-label="anchor" href="#the-compile-method-specifying-a-loss-metrics-and-an-optimizer"></a>
</h2>
<p>To train a model with <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, you need to specify a loss
function, an optimizer, and optionally, some metrics to monitor.</p>
<p>You pass these to the model as arguments to the
<code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code> method:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(learning_rate<span class="op">=</span><span class="fl">1e-3</span>),</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    loss<span class="op">=</span>keras.losses.SparseCategoricalCrossentropy(),</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    metrics<span class="op">=</span>[keras.metrics.SparseCategoricalAccuracy()],</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>)</span></code></pre></div>
<p>The <code>metrics</code> argument should be a list – your model can
have any number of metrics.</p>
<p>If your model has multiple outputs, you can specify different losses
and metrics for each output, and you can modulate the contribution of
each output to the total loss of the model. You will find more details
about this in the <strong>Passing data to multi-input, multi-output
models</strong> section.</p>
<p>Note that if you’re satisfied with the default settings, in many
cases the optimizer, loss, and metrics can be specified via string
identifiers as a shortcut:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>    optimizer<span class="op">=</span><span class="st">"rmsprop"</span>,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>    loss<span class="op">=</span><span class="st">"sparse_categorical_crossentropy"</span>,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>    metrics<span class="op">=</span>[<span class="st">"sparse_categorical_accuracy"</span>],</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>)</span></code></pre></div>
<p>For later reuse, let’s put our model definition and compile step in
functions; we will call them several times across different examples in
this guide.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> get_uncompiled_model():</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">784</span>,), name<span class="op">=</span><span class="st">"digits"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_1"</span>)(inputs)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_2"</span>)(x)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    outputs <span class="op">=</span> layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">"softmax"</span>, name<span class="op">=</span><span class="st">"predictions"</span>)(x)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>    model <span class="op">=</span> keras.Model(inputs<span class="op">=</span>inputs, outputs<span class="op">=</span>outputs)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    <span class="cf">return</span> model</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="kw">def</span> get_compiled_model():</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>    model <span class="op">=</span> get_uncompiled_model()</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>    model.<span class="bu">compile</span>(</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>        optimizer<span class="op">=</span><span class="st">"rmsprop"</span>,</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>        loss<span class="op">=</span><span class="st">"sparse_categorical_crossentropy"</span>,</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>        metrics<span class="op">=</span>[<span class="st">"sparse_categorical_accuracy"</span>],</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>    )</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre></div>
<div class="section level3">
<h3 id="many-built-in-optimizers-losses-and-metrics-are-available">Many built-in optimizers, losses, and metrics are available<a class="anchor" aria-label="anchor" href="#many-built-in-optimizers-losses-and-metrics-are-available"></a>
</h3>
<p>In general, you won’t have to create your own losses, metrics, or
optimizers from scratch, because what you need is likely to be already
part of the Keras API:</p>
<p>Optimizers:</p>
<ul>
<li>
<code>SGD()</code> (with or without momentum)</li>
<li><code>RMSprop()</code></li>
<li><code>Adam()</code></li>
<li>etc.</li>
</ul>
<p>Losses:</p>
<ul>
<li><code>MeanSquaredError()</code></li>
<li><code>KLDivergence()</code></li>
<li><code>CosineSimilarity()</code></li>
<li>etc.</li>
</ul>
<p>Metrics:</p>
<ul>
<li><code>AUC()</code></li>
<li><code>Precision()</code></li>
<li><code><a href="https://rdrr.io/r/base/Recall.html" class="external-link">Recall()</a></code></li>
<li>etc.</li>
</ul>
</div>
<div class="section level3">
<h3 id="custom-losses">Custom losses<a class="anchor" aria-label="anchor" href="#custom-losses"></a>
</h3>
<p>If you need to create a custom loss, Keras provides three ways to do
so.</p>
<p>The first method involves creating a function that accepts inputs
<code>y_true</code> and <code>y_pred</code>. The following example shows
a loss function that computes the mean squared error between the real
data and the predictions:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">def</span> custom_mean_squared_error(y_true, y_pred):</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="cf">return</span> ops.mean(ops.square(y_true <span class="op">-</span> y_pred), axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>model <span class="op">=</span> get_uncompiled_model()</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span>keras.optimizers.Adam(), loss<span class="op">=</span>custom_mean_squared_error)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co"># We need to one-hot encode the labels to use MSE</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>y_train_one_hot <span class="op">=</span> ops.one_hot(y_train, num_classes<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>model.fit(x_train, y_train_one_hot, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<p>If you need a loss function that takes in parameters beside
<code>y_true</code> and <code>y_pred</code>, you can subclass the
<code>keras.losses.Loss</code> class and implement the following two
methods:</p>
<ul>
<li>
<code>__init__(self)</code>: accept parameters to pass during the
call of your loss function</li>
<li>
<code>call(self, y_true, y_pred)</code>: use the targets (y_true)
and the model predictions (y_pred) to compute the model’s loss</li>
</ul>
<p>Let’s say you want to use mean squared error, but with an added term
that will de-incentivize prediction values far from 0.5 (we assume that
the categorical targets are one-hot encoded and take values between 0
and 1). This creates an incentive for the model not to be too confident,
which may help reduce overfitting (we won’t know if it works until we
try!).</p>
<p>Here’s how you would do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">class</span> CustomMSE(keras.losses.Loss):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, regularization_factor<span class="op">=</span><span class="fl">0.1</span>, name<span class="op">=</span><span class="st">"custom_mse"</span>):</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name<span class="op">=</span>name)</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>        <span class="va">self</span>.regularization_factor <span class="op">=</span> regularization_factor</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    <span class="kw">def</span> call(<span class="va">self</span>, y_true, y_pred):</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>        mse <span class="op">=</span> ops.mean(ops.square(y_true <span class="op">-</span> y_pred), axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>        reg <span class="op">=</span> ops.mean(ops.square(<span class="fl">0.5</span> <span class="op">-</span> y_pred), axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>        <span class="cf">return</span> mse <span class="op">+</span> reg <span class="op">*</span> <span class="va">self</span>.regularization_factor</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>model <span class="op">=</span> get_uncompiled_model()</span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span>keras.optimizers.Adam(), loss<span class="op">=</span>CustomMSE())</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>y_train_one_hot <span class="op">=</span> ops.one_hot(y_train, num_classes<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>model.fit(x_train, y_train_one_hot, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="custom-metrics">Custom metrics<a class="anchor" aria-label="anchor" href="#custom-metrics"></a>
</h3>
<p>If you need a metric that isn’t part of the API, you can easily
create custom metrics by subclassing the
<code>keras.metrics.Metric</code> class. You will need to implement 4
methods:</p>
<ul>
<li>
<code>__init__(self)</code>, in which you will create state
variables for your metric.</li>
<li>
<code>update_state(self, y_true, y_pred, sample_weight=None)</code>,
which uses the targets y_true and the model predictions y_pred to update
the state variables.</li>
<li>
<code>result(self)</code>, which uses the state variables to compute
the final results.</li>
<li>
<code>reset_state(self)</code>, which reinitializes the state of the
metric.</li>
</ul>
<p>State update and results computation are kept separate (in
<code>update_state()</code> and <code>result()</code>, respectively)
because in some cases, the results computation might be very expensive
and would only be done periodically.</p>
<p>Here’s a simple example showing how to implement a
<code>CategoricalTruePositives</code> metric that counts how many
samples were correctly classified as belonging to a given class:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="kw">class</span> CategoricalTruePositives(keras.metrics.Metric):</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name<span class="op">=</span><span class="st">"categorical_true_positives"</span>, <span class="op">**</span>kwargs):</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name<span class="op">=</span>name, <span class="op">**</span>kwargs)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>        <span class="va">self</span>.true_positives <span class="op">=</span> <span class="va">self</span>.add_variable(</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>            shape<span class="op">=</span>(), name<span class="op">=</span><span class="st">"ctp"</span>, initializer<span class="op">=</span><span class="st">"zeros"</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>        )</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>    <span class="kw">def</span> update_state(<span class="va">self</span>, y_true, y_pred, sample_weight<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>        y_pred <span class="op">=</span> ops.reshape(ops.argmax(y_pred, axis<span class="op">=</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>        values <span class="op">=</span> ops.cast(y_true, <span class="st">"int32"</span>) <span class="op">==</span> ops.cast(y_pred, <span class="st">"int32"</span>)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>        values <span class="op">=</span> ops.cast(values, <span class="st">"float32"</span>)</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>        <span class="cf">if</span> sample_weight <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>            sample_weight <span class="op">=</span> ops.cast(sample_weight, <span class="st">"float32"</span>)</span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>            values <span class="op">=</span> ops.multiply(values, sample_weight)</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>        <span class="va">self</span>.true_positives.assign_add(ops.<span class="bu">sum</span>(values))</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a>    <span class="kw">def</span> result(<span class="va">self</span>):</span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.true_positives</span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>    <span class="kw">def</span> reset_state(<span class="va">self</span>):</span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>        <span class="co"># The state of the metric will be reset at the start of each epoch.</span></span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>        <span class="va">self</span>.true_positives.assign(<span class="fl">0.0</span>)</span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>model <span class="op">=</span> get_uncompiled_model()</span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(learning_rate<span class="op">=</span><span class="fl">1e-3</span>),</span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a>    loss<span class="op">=</span>keras.losses.SparseCategoricalCrossentropy(),</span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a>    metrics<span class="op">=</span>[CategoricalTruePositives()],</span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a>)</span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a>model.fit(x_train, y_train, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="handling-losses-and-metrics-that-dont-fit-the-standard-signature">Handling losses and metrics that don’t fit the standard
signature<a class="anchor" aria-label="anchor" href="#handling-losses-and-metrics-that-dont-fit-the-standard-signature"></a>
</h3>
<p>The overwhelming majority of losses and metrics can be computed from
<code>y_true</code> and <code>y_pred</code>, where <code>y_pred</code>
is an output of your model – but not all of them. For instance, a
regularization loss may only require the activation of a layer (there
are no targets in this case), and this activation may not be a model
output.</p>
<p>In such cases, you can call <code>self.add_loss(loss_value)</code>
from inside the call method of a custom layer. Losses added in this way
get added to the “main” loss during training (the one passed to
<code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code>). Here’s a simple example that adds activity
regularization (note that activity regularization is built-in in all
Keras layers – this layer is just for the sake of providing a concrete
example):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="kw">class</span> ActivityRegularizationLayer(layers.Layer):</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>    <span class="kw">def</span> call(<span class="va">self</span>, inputs):</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>        <span class="va">self</span>.add_loss(ops.<span class="bu">sum</span>(inputs) <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>        <span class="cf">return</span> inputs  <span class="co"># Pass-through layer.</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">784</span>,), name<span class="op">=</span><span class="st">"digits"</span>)</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_1"</span>)(inputs)</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a><span class="co"># Insert activity regularization as a layer</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>x <span class="op">=</span> ActivityRegularizationLayer()(x)</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>x <span class="op">=</span> layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">"relu"</span>, name<span class="op">=</span><span class="st">"dense_2"</span>)(x)</span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>outputs <span class="op">=</span> layers.Dense(<span class="dv">10</span>, name<span class="op">=</span><span class="st">"predictions"</span>)(x)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs<span class="op">=</span>inputs, outputs<span class="op">=</span>outputs)</span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(learning_rate<span class="op">=</span><span class="fl">1e-3</span>),</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    loss<span class="op">=</span>keras.losses.SparseCategoricalCrossentropy(from_logits<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>)</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a><span class="co"># The displayed loss will be much higher than before</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a><span class="co"># due to the regularization component.</span></span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>model.fit(x_train, y_train, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<p>Note that when you pass losses via <code>add_loss()</code>, it
becomes possible to call <code><a href="https://generics.r-lib.org/reference/compile.html" class="external-link">compile()</a></code> without a loss function,
since the model already has a loss to minimize.</p>
<p>Consider the following <code>LogisticEndpoint</code> layer: it takes
as inputs targets &amp; logits, and it tracks a crossentropy loss via
<code>add_loss()</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">class</span> LogisticEndpoint(keras.layers.Layer):</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name<span class="op">=</span>name)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>        <span class="va">self</span>.loss_fn <span class="op">=</span> keras.losses.BinaryCrossentropy(from_logits<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>    <span class="kw">def</span> call(<span class="va">self</span>, targets, logits, sample_weights<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>        <span class="co"># Compute the training-time loss value and add it</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>        <span class="co"># to the layer using `self.add_loss()`.</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>        loss <span class="op">=</span> <span class="va">self</span>.loss_fn(targets, logits, sample_weights)</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>        <span class="va">self</span>.add_loss(loss)</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>        <span class="co"># Return the inference-time prediction tensor (for `.predict()`).</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>        <span class="cf">return</span> ops.softmax(logits)</span></code></pre></div>
<p>You can use it in a model with two inputs (input data &amp; targets),
compiled without a <code>loss</code> argument, like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>inputs <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">3</span>,), name<span class="op">=</span><span class="st">"inputs"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>targets <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">10</span>,), name<span class="op">=</span><span class="st">"targets"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>logits <span class="op">=</span> keras.layers.Dense(<span class="dv">10</span>)(inputs)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>predictions <span class="op">=</span> LogisticEndpoint(name<span class="op">=</span><span class="st">"predictions"</span>)(targets, logits)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>model <span class="op">=</span> keras.Model(inputs<span class="op">=</span>[inputs, targets], outputs<span class="op">=</span>predictions)</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">"adam"</span>)  <span class="co"># No loss argument!</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>    <span class="st">"inputs"</span>: np.random.random((<span class="dv">3</span>, <span class="dv">3</span>)),</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>    <span class="st">"targets"</span>: np.random.random((<span class="dv">3</span>, <span class="dv">10</span>)),</span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>}</span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>model.fit(data)</span></code></pre></div>
<p>For more information about training multi-input models, see the
section <strong>Passing data to multi-input, multi-output
models</strong>.</p>
</div>
<div class="section level3">
<h3 id="automatically-setting-apart-a-validation-holdout-set">Automatically setting apart a validation holdout set<a class="anchor" aria-label="anchor" href="#automatically-setting-apart-a-validation-holdout-set"></a>
</h3>
<p>In the first end-to-end example you saw, we used the
<code>validation_data</code> argument to pass a tuple of NumPy arrays
<code>(x_val, y_val)</code> to the model for evaluating a validation
loss and validation metrics at the end of each epoch.</p>
<p>Here’s another option: the argument <code>validation_split</code>
allows you to automatically reserve part of your training data for
validation. The argument value represents the fraction of the data to be
reserved for validation, so it should be set to a number higher than 0
and lower than 1. For instance, <code>validation_split=0.2</code> means
“use 20% of the data for validation”, and
<code>validation_split=0.6</code> means “use 60% of the data for
validation”.</p>
<p>The way the validation is computed is by taking the last x% samples
of the arrays received by the <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> call, before any
shuffling.</p>
<p>Note that you can only use <code>validation_split</code> when
training with NumPy data.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>model.fit(x_train, y_train, batch_size<span class="op">=</span><span class="dv">64</span>, validation_split<span class="op">=</span><span class="fl">0.2</span>, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="training-evaluation-using-tf-data-datasets">Training &amp; evaluation using <code>tf.data</code> Datasets<a class="anchor" aria-label="anchor" href="#training-evaluation-using-tf-data-datasets"></a>
</h2>
<p>In the past few paragraphs, you’ve seen how to handle losses,
metrics, and optimizers, and you’ve seen how to use the
<code>validation_data</code> and <code>validation_split</code> arguments
in <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, when your data is passed as NumPy arrays.</p>
<p>Another option is to use an iterator-like, such as a
<code>tf.data.Dataset</code>, a PyTorch <code>DataLoader</code>, or a
Keras <code>PyDataset</code>. Let’s take look at the former.</p>
<p>The <code>tf.data</code> API is a set of utilities in TensorFlow 2.0
for loading and preprocessing data in a way that’s fast and scalable.
For a complete guide about creating <code>Datasets</code>, see the <a href="https://www.tensorflow.org/guide/data" class="external-link">tf.data
documentation</a>.</p>
<p><strong>You can use <code>tf.data</code> to train your Keras models
regardless of the backend you’re using – whether it’s JAX, PyTorch, or
TensorFlow.</strong> You can pass a <code>Dataset</code> instance
directly to the methods <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>, <code><a href="https://rdrr.io/pkg/tensorflow/man/evaluate.html" class="external-link">evaluate()</a></code>, and
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co"># First, let's create a training Dataset instance.</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co"># For the sake of our example, we'll use the same MNIST data as before.</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_train, y_train))</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co"># Shuffle and slice the dataset.</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co"># Now we get a test dataset.</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a>test_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_test, y_test))</span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a>test_dataset <span class="op">=</span> test_dataset.batch(<span class="dv">64</span>)</span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co"># Since the dataset already takes care of batching,</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co"># we don't pass a `batch_size` argument.</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a><span class="co"># You can also evaluate or predict on a dataset.</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Evaluate"</span>)</span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a>result <span class="op">=</span> model.evaluate(test_dataset)</span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a><span class="bu">dict</span>(<span class="bu">zip</span>(model.metrics_names, result))</span></code></pre></div>
<p>Note that the Dataset is reset at the end of each epoch, so it can be
reused of the next epoch.</p>
<p>If you want to run training only on a specific number of batches from
this Dataset, you can pass the <code>steps_per_epoch</code> argument,
which specifies how many training steps the model should run using this
Dataset before moving on to the next epoch.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co"># Prepare the training dataset</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_train, y_train))</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co"># Only use the 100 batches per epoch (that's 64 * 100 samples)</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">3</span>, steps_per_epoch<span class="op">=</span><span class="dv">100</span>)</span></code></pre></div>
<p>You can also pass a <code>Dataset</code> instance as the
<code>validation_data</code> argument in <code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co"># Prepare the training dataset</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_train, y_train))</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co"># Prepare the validation dataset</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>val_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_val, y_val))</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>val_dataset <span class="op">=</span> val_dataset.batch(<span class="dv">64</span>)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">1</span>, validation_data<span class="op">=</span>val_dataset)</span></code></pre></div>
<p>At the end of each epoch, the model will iterate over the validation
dataset and compute the validation loss and validation metrics.</p>
<p>If you want to run validation only on a specific number of batches
from this dataset, you can pass the <code>validation_steps</code>
argument, which specifies how many validation steps the model should run
with the validation dataset before interrupting validation and moving on
to the next epoch:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a><span class="co"># Prepare the training dataset</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_train, y_train))</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a><span class="co"># Prepare the validation dataset</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>val_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices((x_val, y_val))</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>val_dataset <span class="op">=</span> val_dataset.batch(<span class="dv">64</span>)</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>model.fit(</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>    train_dataset,</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>    <span class="co"># Only run validation using the first 10 batches of the dataset</span></span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>    <span class="co"># using the `validation_steps` argument</span></span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>    validation_data<span class="op">=</span>val_dataset,</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a>    validation_steps<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a>)</span></code></pre></div>
<p>Note that the validation dataset will be reset after each use (so
that you will always be evaluating on the same samples from epoch to
epoch).</p>
<p>The argument <code>validation_split</code> (generating a holdout set
from the training data) is not supported when training from
<code>Dataset</code> objects, since this feature requires the ability to
index the samples of the datasets, which is not possible in general with
the <code>Dataset</code> API.</p>
</div>
<div class="section level2">
<h2 id="training-evaluation-using-pydataset-instances">Training &amp; evaluation using <code>PyDataset</code>
instances<a class="anchor" aria-label="anchor" href="#training-evaluation-using-pydataset-instances"></a>
</h2>
<p><code>keras.utils.PyDataset</code> is a utility that you can subclass
to obtain a Python generator with two important properties:</p>
<ul>
<li>It works well with multiprocessing.</li>
<li>It can be shuffled (e.g. when passing <code>shuffle=True</code> in
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>).</li>
</ul>
<p>A <code>PyDataset</code> must implement two methods:</p>
<ul>
<li><code>__getitem__</code></li>
<li><code>__len__</code></li>
</ul>
<p>The method <code>__getitem__</code> should return a complete batch.
If you want to modify your dataset between epochs, you may implement
<code>on_epoch_end</code>.</p>
<p>Here’s a quick example:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="kw">class</span> ExamplePyDataset(keras.utils.PyDataset):</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, y, batch_size, <span class="op">**</span>kwargs):</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(<span class="op">**</span>kwargs)</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>        <span class="va">self</span>.batch_size <span class="op">=</span> batch_size</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(np.ceil(<span class="bu">len</span>(<span class="va">self</span>.x) <span class="op">/</span> <span class="bu">float</span>(<span class="va">self</span>.batch_size)))</span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>        batch_x <span class="op">=</span> <span class="va">self</span>.x[idx <span class="op">*</span> <span class="va">self</span>.batch_size : (idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="va">self</span>.batch_size]</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>        batch_y <span class="op">=</span> <span class="va">self</span>.y[idx <span class="op">*</span> <span class="va">self</span>.batch_size : (idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="va">self</span>.batch_size]</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>        <span class="cf">return</span> batch_x, batch_y</span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>train_py_dataset <span class="op">=</span> ExamplePyDataset(x_train, y_train, batch_size<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>val_py_dataset <span class="op">=</span> ExamplePyDataset(x_val, y_val, batch_size<span class="op">=</span><span class="dv">32</span>)</span></code></pre></div>
<p>To fit the model, pass the dataset instead as the <code>x</code>
argument (no need for a <code>y</code> argument since the dataset
includes the targets), and pass the validation dataset as the
<code>validation_data</code> argument. And no need for the
<code>batch_size</code> argument, since the dataset is already
batched!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>model.fit(</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>    train_py_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, validation_data<span class="op">=</span>val_py_dataset, epochs<span class="op">=</span><span class="dv">1</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>)</span></code></pre></div>
<p>Evaluating the model is just as easy:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>model.evaluate(val_py_dataset)</span></code></pre></div>
<p>Importantly, <code>PyDataset</code> objects support three common
constructor arguments that handle the parallel processing
configuration:</p>
<ul>
<li>
<code>workers</code>: Number of workers to use in multithreading or
multiprocessing. Typically, you’d set it to the number of cores on your
CPU.</li>
<li>
<code>use_multiprocessing</code>: Whether to use Python
multiprocessing for parallelism. Setting this to <code>True</code> means
that your dataset will be replicated in multiple forked processes. This
is necessary to gain compute-level (rather than I/O level) benefits from
parallelism. However it can only be set to <code>True</code> if your
dataset can be safely pickled.</li>
<li>
<code>max_queue_size</code>: Maximum number of batches to keep in
the queue when iterating over the dataset in a multithreaded or
multipricessed setting. You can reduce this value to reduce the CPU
memory consumption of your dataset. It defaults to 10.</li>
</ul>
<p>By default, multiprocessing is disabled
(<code>use_multiprocessing=False</code>) and only one thread is used.
You should make sure to only turn on <code>use_multiprocessing</code> if
your code is running inside a Python
<code>if __name__ == "__main__":</code> block in order to avoid
issues.</p>
<p>Here’s a 4-thread, non-multiprocessed example:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>train_py_dataset <span class="op">=</span> ExamplePyDataset(x_train, y_train, batch_size<span class="op">=</span><span class="dv">32</span>, workers<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>val_py_dataset <span class="op">=</span> ExamplePyDataset(x_val, y_val, batch_size<span class="op">=</span><span class="dv">32</span>, workers<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>model.fit(</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>    train_py_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, validation_data<span class="op">=</span>val_py_dataset, epochs<span class="op">=</span><span class="dv">1</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="training-evaluation-using-pytorch-dataloader-objects">Training &amp; evaluation using PyTorch <code>DataLoader</code>
objects<a class="anchor" aria-label="anchor" href="#training-evaluation-using-pytorch-dataloader-objects"></a>
</h2>
<p>All built-in training and evaluation APIs are also compatible with
<code>torch.utils.data.Dataset</code> and
<code>torch.utils.data.DataLoader</code> objects – regardless of whether
you’re using the PyTorch backend, or the JAX or TensorFlow backends.
Let’s take a look at a simple example.</p>
<p>Unlike <code>PyDataset</code> which are batch-centric, PyTorch
<code>Dataset</code> objects are sample-centric: the
<code>__len__</code> method returns the number of samples, and the
<code>__getitem__</code> method returns a specific sample.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="kw">class</span> ExampleTorchDataset(torch.utils.data.Dataset):</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, y):</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.x)</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.x[idx], <span class="va">self</span>.y[idx]</span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a>train_torch_dataset <span class="op">=</span> ExampleTorchDataset(x_train, y_train)</span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a>val_torch_dataset <span class="op">=</span> ExampleTorchDataset(x_val, y_val)</span></code></pre></div>
<p>To use a PyTorch Dataset, you need to wrap it into a
<code>Dataloader</code> which takes care of batching and shuffling:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>train_dataloader <span class="op">=</span> torch.utils.data.DataLoader(</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>    train_torch_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">True</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>)</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>val_dataloader <span class="op">=</span> torch.utils.data.DataLoader(</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>    val_torch_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">True</span></span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>)</span></code></pre></div>
<p>Now you can use them in the Keras API just like any other
iterator:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>model.fit(</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>    train_dataloader, batch_size<span class="op">=</span><span class="dv">64</span>, validation_data<span class="op">=</span>val_dataloader, epochs<span class="op">=</span><span class="dv">1</span></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>)</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>model.evaluate(val_dataloader)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="using-sample-weighting-and-class-weighting">Using sample weighting and class weighting<a class="anchor" aria-label="anchor" href="#using-sample-weighting-and-class-weighting"></a>
</h2>
<p>With the default settings the weight of a sample is decided by its
frequency in the dataset. There are two methods to weight the data,
independent of sample frequency:</p>
<ul>
<li>Class weights</li>
<li>Sample weights</li>
</ul>
<div class="section level3">
<h3 id="class-weights">Class weights<a class="anchor" aria-label="anchor" href="#class-weights"></a>
</h3>
<p>This is set by passing a dictionary to the <code>class_weight</code>
argument to <code>Model.fit()</code>. This dictionary maps class indices
to the weight that should be used for samples belonging to this
class.</p>
<p>This can be used to balance classes without resampling, or to train a
model that gives more importance to a particular class.</p>
<p>For instance, if class “0” is half as represented as class “1” in
your data, you could use
<code>Model.fit(..., class_weight={0: 1., 1: 0.5})</code>.</p>
<p>Here’s a NumPy example where we use class weights or sample weights
to give more importance to the correct classification of class #5 (which
is the digit “5” in the MNIST dataset).</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>class_weight <span class="op">=</span> {</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>    <span class="dv">0</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>    <span class="dv">1</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>    <span class="dv">2</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>    <span class="dv">3</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>    <span class="dv">4</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>    <span class="co"># Set weight "2" for class "5",</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>    <span class="co"># making this class 2x more important</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>    <span class="dv">5</span>: <span class="fl">2.0</span>,</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>    <span class="dv">6</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>    <span class="dv">7</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>    <span class="dv">8</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>    <span class="dv">9</span>: <span class="fl">1.0</span>,</span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>}</span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fit with class weight"</span>)</span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a>model.fit(x_train, y_train, class_weight<span class="op">=</span>class_weight, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="sample-weights">Sample weights<a class="anchor" aria-label="anchor" href="#sample-weights"></a>
</h3>
<p>For fine grained control, or if you are not building a classifier,
you can use “sample weights”.</p>
<ul>
<li>When training from NumPy data: Pass the <code>sample_weight</code>
argument to <code>Model.fit()</code>.</li>
<li>When training from <code>tf.data</code> or any other sort of
iterator: Yield
<code>(input_batch, label_batch, sample_weight_batch)</code>
tuples.</li>
</ul>
<p>A “sample weights” array is an array of numbers that specify how much
weight each sample in a batch should have in computing the total loss.
It is commonly used in imbalanced classification problems (the idea
being to give more weight to rarely-seen classes).</p>
<p>When the weights used are ones and zeros, the array can be used as a
<em>mask</em> for the loss function (entirely discarding the
contribution of certain samples to the total loss).</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>sample_weight <span class="op">=</span> np.ones(shape<span class="op">=</span>(<span class="bu">len</span>(y_train),))</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>sample_weight[y_train <span class="op">==</span> <span class="dv">5</span>] <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fit with sample weight"</span>)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>model.fit(</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>    x_train, y_train, sample_weight<span class="op">=</span>sample_weight, batch_size<span class="op">=</span><span class="dv">64</span>, epochs<span class="op">=</span><span class="dv">1</span></span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>)</span></code></pre></div>
<p>Here’s a matching <code>Dataset</code> example:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>sample_weight <span class="op">=</span> np.ones(shape<span class="op">=</span>(<span class="bu">len</span>(y_train),))</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>sample_weight[y_train <span class="op">==</span> <span class="dv">5</span>] <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co"># Create a Dataset that includes sample weights</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co"># (3rd element in the return tuple).</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices(</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>    (x_train, y_train, sample_weight)</span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>)</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a><span class="co"># Shuffle and slice the dataset.</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="passing-data-to-multi-input-multi-output-models">Passing data to multi-input, multi-output models<a class="anchor" aria-label="anchor" href="#passing-data-to-multi-input-multi-output-models"></a>
</h2>
<p>In the previous examples, we were considering a model with a single
input (a tensor of shape <code>(764,)</code>) and a single output (a
prediction tensor of shape <code>(10,)</code>). But what about models
that have multiple inputs or outputs?</p>
<p>Consider the following model, which has an image input of shape
<code>(32, 32, 3)</code> (that’s <code>(height, width, channels)</code>)
and a time series input of shape <code>(None, 10)</code> (that’s
<code>(timesteps, features)</code>). Our model will have two outputs
computed from the combination of these inputs: a “score” (of shape
<code>(1,)</code>) and a probability distribution over five classes (of
shape <code>(5,)</code>).</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>image_input <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">32</span>, <span class="dv">32</span>, <span class="dv">3</span>), name<span class="op">=</span><span class="st">"img_input"</span>)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>timeseries_input <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="va">None</span>, <span class="dv">10</span>), name<span class="op">=</span><span class="st">"ts_input"</span>)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>x1 <span class="op">=</span> layers.Conv2D(<span class="dv">3</span>, <span class="dv">3</span>)(image_input)</span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>x1 <span class="op">=</span> layers.GlobalMaxPooling2D()(x1)</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>x2 <span class="op">=</span> layers.Conv1D(<span class="dv">3</span>, <span class="dv">3</span>)(timeseries_input)</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>x2 <span class="op">=</span> layers.GlobalMaxPooling1D()(x2)</span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a>x <span class="op">=</span> layers.concatenate([x1, x2])</span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a>score_output <span class="op">=</span> layers.Dense(<span class="dv">1</span>, name<span class="op">=</span><span class="st">"score_output"</span>)(x)</span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a>class_output <span class="op">=</span> layers.Dense(<span class="dv">5</span>, name<span class="op">=</span><span class="st">"class_output"</span>)(x)</span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a>model <span class="op">=</span> keras.Model(</span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a>    inputs<span class="op">=</span>[image_input, timeseries_input], outputs<span class="op">=</span>[score_output, class_output]</span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a>)</span></code></pre></div>
<p>Let’s plot this model, so you can clearly see what we’re doing here
(note that the shapes shown in the plot are batch shapes, rather than
per-sample shapes).</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>keras.utils.plot_model(</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>    model, <span class="st">"multi_input_and_output_model.png"</span>, show_shapes<span class="op">=</span><span class="va">True</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>)</span></code></pre></div>
<p>At compilation time, we can specify different losses to different
outputs, by passing the loss functions as a list:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>    loss<span class="op">=</span>[</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>        keras.losses.MeanSquaredError(),</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>        keras.losses.CategoricalCrossentropy(),</span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>    ],</span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>)</span></code></pre></div>
<p>If we only passed a single loss function to the model, the same loss
function would be applied to every output (which is not appropriate
here).</p>
<p>Likewise for metrics:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>    loss<span class="op">=</span>[</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>        keras.losses.MeanSquaredError(),</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>        keras.losses.CategoricalCrossentropy(),</span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>    ],</span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>    metrics<span class="op">=</span>[</span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a>        [</span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a>            keras.metrics.MeanAbsolutePercentageError(),</span>
<span id="cb35-10"><a href="#cb35-10" tabindex="-1"></a>            keras.metrics.MeanAbsoluteError(),</span>
<span id="cb35-11"><a href="#cb35-11" tabindex="-1"></a>        ],</span>
<span id="cb35-12"><a href="#cb35-12" tabindex="-1"></a>        [keras.metrics.CategoricalAccuracy()],</span>
<span id="cb35-13"><a href="#cb35-13" tabindex="-1"></a>    ],</span>
<span id="cb35-14"><a href="#cb35-14" tabindex="-1"></a>)</span></code></pre></div>
<p>Since we gave names to our output layers, we could also specify
per-output losses and metrics via a dict:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>    loss<span class="op">=</span>{</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>        <span class="st">"score_output"</span>: keras.losses.MeanSquaredError(),</span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>        <span class="st">"class_output"</span>: keras.losses.CategoricalCrossentropy(),</span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>    },</span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>    metrics<span class="op">=</span>{</span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>        <span class="st">"score_output"</span>: [</span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>            keras.metrics.MeanAbsolutePercentageError(),</span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a>            keras.metrics.MeanAbsoluteError(),</span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a>        ],</span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a>        <span class="st">"class_output"</span>: [keras.metrics.CategoricalAccuracy()],</span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>    },</span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a>)</span></code></pre></div>
<p>We recommend the use of explicit names and dicts if you have more
than 2 outputs.</p>
<p>It’s possible to give different weights to different output-specific
losses (for instance, one might wish to privilege the “score” loss in
our example, by giving to 2x the importance of the class loss), using
the <code>loss_weights</code> argument:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>    loss<span class="op">=</span>{</span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>        <span class="st">"score_output"</span>: keras.losses.MeanSquaredError(),</span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>        <span class="st">"class_output"</span>: keras.losses.CategoricalCrossentropy(),</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>    },</span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a>    metrics<span class="op">=</span>{</span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>        <span class="st">"score_output"</span>: [</span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>            keras.metrics.MeanAbsolutePercentageError(),</span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>            keras.metrics.MeanAbsoluteError(),</span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a>        ],</span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a>        <span class="st">"class_output"</span>: [keras.metrics.CategoricalAccuracy()],</span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a>    },</span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a>    loss_weights<span class="op">=</span>{<span class="st">"score_output"</span>: <span class="fl">2.0</span>, <span class="st">"class_output"</span>: <span class="fl">1.0</span>},</span>
<span id="cb37-15"><a href="#cb37-15" tabindex="-1"></a>)</span></code></pre></div>
<p>You could also choose not to compute a loss for certain outputs, if
these outputs are meant for prediction but not for training:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="co"># List loss version</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>    loss<span class="op">=</span>[<span class="va">None</span>, keras.losses.CategoricalCrossentropy()],</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a>)</span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="co"># Or dict loss version</span></span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a>    loss<span class="op">=</span>{<span class="st">"class_output"</span>: keras.losses.CategoricalCrossentropy()},</span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a>)</span></code></pre></div>
<p>Passing data to a multi-input or multi-output model in
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> works in a similar way as specifying a loss function
in compile: you can pass <strong>lists of NumPy arrays</strong> (with
1:1 mapping to the outputs that received a loss function) or
<strong>dicts mapping output names to NumPy arrays</strong>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.RMSprop(<span class="fl">1e-3</span>),</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>    loss<span class="op">=</span>[</span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>        keras.losses.MeanSquaredError(),</span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>        keras.losses.CategoricalCrossentropy(),</span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a>    ],</span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a>)</span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" tabindex="-1"></a><span class="co"># Generate dummy NumPy data</span></span>
<span id="cb39-10"><a href="#cb39-10" tabindex="-1"></a>img_data <span class="op">=</span> np.random.random_sample(size<span class="op">=</span>(<span class="dv">100</span>, <span class="dv">32</span>, <span class="dv">32</span>, <span class="dv">3</span>))</span>
<span id="cb39-11"><a href="#cb39-11" tabindex="-1"></a>ts_data <span class="op">=</span> np.random.random_sample(size<span class="op">=</span>(<span class="dv">100</span>, <span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb39-12"><a href="#cb39-12" tabindex="-1"></a>score_targets <span class="op">=</span> np.random.random_sample(size<span class="op">=</span>(<span class="dv">100</span>, <span class="dv">1</span>))</span>
<span id="cb39-13"><a href="#cb39-13" tabindex="-1"></a>class_targets <span class="op">=</span> np.random.random_sample(size<span class="op">=</span>(<span class="dv">100</span>, <span class="dv">5</span>))</span>
<span id="cb39-14"><a href="#cb39-14" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" tabindex="-1"></a><span class="co"># Fit on lists</span></span>
<span id="cb39-16"><a href="#cb39-16" tabindex="-1"></a>model.fit(</span>
<span id="cb39-17"><a href="#cb39-17" tabindex="-1"></a>    [img_data, ts_data], [score_targets, class_targets], batch_size<span class="op">=</span><span class="dv">32</span>, epochs<span class="op">=</span><span class="dv">1</span></span>
<span id="cb39-18"><a href="#cb39-18" tabindex="-1"></a>)</span>
<span id="cb39-19"><a href="#cb39-19" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" tabindex="-1"></a><span class="co"># Alternatively, fit on dicts</span></span>
<span id="cb39-21"><a href="#cb39-21" tabindex="-1"></a>model.fit(</span>
<span id="cb39-22"><a href="#cb39-22" tabindex="-1"></a>    {<span class="st">"img_input"</span>: img_data, <span class="st">"ts_input"</span>: ts_data},</span>
<span id="cb39-23"><a href="#cb39-23" tabindex="-1"></a>    {<span class="st">"score_output"</span>: score_targets, <span class="st">"class_output"</span>: class_targets},</span>
<span id="cb39-24"><a href="#cb39-24" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">32</span>,</span>
<span id="cb39-25"><a href="#cb39-25" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb39-26"><a href="#cb39-26" tabindex="-1"></a>)</span></code></pre></div>
<p>Here’s the <code>Dataset</code> use case: similarly as what we did
for NumPy arrays, the <code>Dataset</code> should return a tuple of
dicts.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>train_dataset <span class="op">=</span> tf.data.Dataset.from_tensor_slices(</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>    (</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>        {<span class="st">"img_input"</span>: img_data, <span class="st">"ts_input"</span>: ts_data},</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>        {<span class="st">"score_output"</span>: score_targets, <span class="st">"class_output"</span>: class_targets},</span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>    )</span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>)</span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>train_dataset <span class="op">=</span> train_dataset.shuffle(buffer_size<span class="op">=</span><span class="dv">1024</span>).batch(<span class="dv">64</span>)</span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a>model.fit(train_dataset, epochs<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="using-callbacks">Using callbacks<a class="anchor" aria-label="anchor" href="#using-callbacks"></a>
</h2>
<p>Callbacks in Keras are objects that are called at different points
during training (at the start of an epoch, at the end of a batch, at the
end of an epoch, etc.). They can be used to implement certain behaviors,
such as:</p>
<ul>
<li>Doing validation at different points during training (beyond the
built-in per-epoch validation)</li>
<li>Checkpointing the model at regular intervals or when it exceeds a
certain accuracy threshold</li>
<li>Changing the learning rate of the model when training seems to be
plateauing</li>
<li>Doing fine-tuning of the top layers when training seems to be
plateauing</li>
<li>Sending email or instant message notifications when training ends or
where a certain performance threshold is exceeded</li>
<li>Etc.</li>
</ul>
<p>Callbacks can be passed as a list to your call to
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a>callbacks <span class="op">=</span> [</span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a>    keras.callbacks.EarlyStopping(</span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a>        <span class="co"># Stop training when `val_loss` is no longer improving</span></span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a>        monitor<span class="op">=</span><span class="st">"val_loss"</span>,</span>
<span id="cb41-7"><a href="#cb41-7" tabindex="-1"></a>        <span class="co"># "no longer improving" being defined as "no better than 1e-2 less"</span></span>
<span id="cb41-8"><a href="#cb41-8" tabindex="-1"></a>        min_delta<span class="op">=</span><span class="fl">1e-2</span>,</span>
<span id="cb41-9"><a href="#cb41-9" tabindex="-1"></a>        <span class="co"># "no longer improving" being further defined as "for at least 2 epochs"</span></span>
<span id="cb41-10"><a href="#cb41-10" tabindex="-1"></a>        patience<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb41-11"><a href="#cb41-11" tabindex="-1"></a>        verbose<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb41-12"><a href="#cb41-12" tabindex="-1"></a>    )</span>
<span id="cb41-13"><a href="#cb41-13" tabindex="-1"></a>]</span>
<span id="cb41-14"><a href="#cb41-14" tabindex="-1"></a>model.fit(</span>
<span id="cb41-15"><a href="#cb41-15" tabindex="-1"></a>    x_train,</span>
<span id="cb41-16"><a href="#cb41-16" tabindex="-1"></a>    y_train,</span>
<span id="cb41-17"><a href="#cb41-17" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb41-18"><a href="#cb41-18" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">64</span>,</span>
<span id="cb41-19"><a href="#cb41-19" tabindex="-1"></a>    callbacks<span class="op">=</span>callbacks,</span>
<span id="cb41-20"><a href="#cb41-20" tabindex="-1"></a>    validation_split<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb41-21"><a href="#cb41-21" tabindex="-1"></a>)</span></code></pre></div>
<div class="section level3">
<h3 id="many-built-in-callbacks-are-available">Many built-in callbacks are available<a class="anchor" aria-label="anchor" href="#many-built-in-callbacks-are-available"></a>
</h3>
<p>There are many built-in callbacks already available in Keras, such
as:</p>
<ul>
<li>
<code>ModelCheckpoint</code>: Periodically save the model.</li>
<li>
<code>EarlyStopping</code>: Stop training when training is no longer
improving the validation metrics.</li>
<li>
<code>TensorBoard</code>: periodically write model logs that can be
visualized in <a href="https://www.tensorflow.org/tensorboard" class="external-link">TensorBoard</a> (more
details in the section “Visualization”).</li>
<li>
<code>CSVLogger</code>: streams loss and metrics data to a CSV
file.</li>
<li>etc.</li>
</ul>
<p>See the <a href="/api/callbacks/">callbacks documentation</a> for the
complete list.</p>
</div>
<div class="section level3">
<h3 id="writing-your-own-callback">Writing your own callback<a class="anchor" aria-label="anchor" href="#writing-your-own-callback"></a>
</h3>
<p>You can create a custom callback by extending the base class
<code>keras.callbacks.Callback</code>. A callback has access to its
associated model through the class property <code>self.model</code>.</p>
<p>Make sure to read the <a href="/guides/writing_your_own_callbacks/">complete guide to writing
custom callbacks</a>.</p>
<p>Here’s a simple example saving a list of per-batch loss values during
training:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="kw">class</span> LossHistory(keras.callbacks.Callback):</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>    <span class="kw">def</span> on_train_begin(<span class="va">self</span>, logs):</span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>        <span class="va">self</span>.per_batch_losses <span class="op">=</span> []</span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a>    <span class="kw">def</span> on_batch_end(<span class="va">self</span>, batch, logs):</span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a>        <span class="va">self</span>.per_batch_losses.append(logs.get(<span class="st">"loss"</span>))</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="checkpointing-models">Checkpointing models<a class="anchor" aria-label="anchor" href="#checkpointing-models"></a>
</h2>
<p>When you’re training model on relatively large datasets, it’s crucial
to save checkpoints of your model at frequent intervals.</p>
<p>The easiest way to achieve this is with the
<code>ModelCheckpoint</code> callback:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>model <span class="op">=</span> get_compiled_model()</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>callbacks <span class="op">=</span> [</span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>    keras.callbacks.ModelCheckpoint(</span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a>        <span class="co"># Path where to save the model</span></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a>        <span class="co"># The two parameters below mean that we will overwrite</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a>        <span class="co"># the current checkpoint if and only if</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a>        <span class="co"># the `val_loss` score has improved.</span></span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a>        <span class="co"># The saved model name will include the current epoch.</span></span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a>        filepath<span class="op">=</span><span class="st">"mymodel_</span><span class="sc">{epoch}</span><span class="st">.keras"</span>,</span>
<span id="cb43-11"><a href="#cb43-11" tabindex="-1"></a>        save_best_only<span class="op">=</span><span class="va">True</span>,  <span class="co"># Only save a model if `val_loss` has improved.</span></span>
<span id="cb43-12"><a href="#cb43-12" tabindex="-1"></a>        monitor<span class="op">=</span><span class="st">"val_loss"</span>,</span>
<span id="cb43-13"><a href="#cb43-13" tabindex="-1"></a>        verbose<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb43-14"><a href="#cb43-14" tabindex="-1"></a>    )</span>
<span id="cb43-15"><a href="#cb43-15" tabindex="-1"></a>]</span>
<span id="cb43-16"><a href="#cb43-16" tabindex="-1"></a>model.fit(</span>
<span id="cb43-17"><a href="#cb43-17" tabindex="-1"></a>    x_train,</span>
<span id="cb43-18"><a href="#cb43-18" tabindex="-1"></a>    y_train,</span>
<span id="cb43-19"><a href="#cb43-19" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb43-20"><a href="#cb43-20" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">64</span>,</span>
<span id="cb43-21"><a href="#cb43-21" tabindex="-1"></a>    callbacks<span class="op">=</span>callbacks,</span>
<span id="cb43-22"><a href="#cb43-22" tabindex="-1"></a>    validation_split<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb43-23"><a href="#cb43-23" tabindex="-1"></a>)</span></code></pre></div>
<p>The <code>ModelCheckpoint</code> callback can be used to implement
fault-tolerance: the ability to restart training from the last saved
state of the model in case training gets randomly interrupted. Here’s a
basic example:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="co"># Prepare a directory to store all the checkpoints.</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>checkpoint_dir <span class="op">=</span> <span class="st">"./ckpt"</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(checkpoint_dir):</span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>    os.makedirs(checkpoint_dir)</span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a><span class="kw">def</span> make_or_restore_model():</span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a>    <span class="co"># Either restore the latest model, or create a fresh one</span></span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a>    <span class="co"># if there is no checkpoint available.</span></span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a>    checkpoints <span class="op">=</span> [</span>
<span id="cb44-11"><a href="#cb44-11" tabindex="-1"></a>        checkpoint_dir <span class="op">+</span> <span class="st">"/"</span> <span class="op">+</span> name <span class="cf">for</span> name <span class="kw">in</span> os.listdir(checkpoint_dir)</span>
<span id="cb44-12"><a href="#cb44-12" tabindex="-1"></a>    ]</span>
<span id="cb44-13"><a href="#cb44-13" tabindex="-1"></a>    <span class="cf">if</span> checkpoints:</span>
<span id="cb44-14"><a href="#cb44-14" tabindex="-1"></a>        latest_checkpoint <span class="op">=</span> <span class="bu">max</span>(checkpoints, key<span class="op">=</span>os.path.getctime)</span>
<span id="cb44-15"><a href="#cb44-15" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Restoring from"</span>, latest_checkpoint)</span>
<span id="cb44-16"><a href="#cb44-16" tabindex="-1"></a>        <span class="cf">return</span> keras.models.load_model(latest_checkpoint)</span>
<span id="cb44-17"><a href="#cb44-17" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Creating a new model"</span>)</span>
<span id="cb44-18"><a href="#cb44-18" tabindex="-1"></a>    <span class="cf">return</span> get_compiled_model()</span>
<span id="cb44-19"><a href="#cb44-19" tabindex="-1"></a></span>
<span id="cb44-20"><a href="#cb44-20" tabindex="-1"></a></span>
<span id="cb44-21"><a href="#cb44-21" tabindex="-1"></a>model <span class="op">=</span> make_or_restore_model()</span>
<span id="cb44-22"><a href="#cb44-22" tabindex="-1"></a>callbacks <span class="op">=</span> [</span>
<span id="cb44-23"><a href="#cb44-23" tabindex="-1"></a>    <span class="co"># This callback saves the model every 100 batches.</span></span>
<span id="cb44-24"><a href="#cb44-24" tabindex="-1"></a>    <span class="co"># We include the training loss in the saved model name.</span></span>
<span id="cb44-25"><a href="#cb44-25" tabindex="-1"></a>    keras.callbacks.ModelCheckpoint(</span>
<span id="cb44-26"><a href="#cb44-26" tabindex="-1"></a>        filepath<span class="op">=</span>checkpoint_dir <span class="op">+</span> <span class="st">"/model-loss=</span><span class="sc">{loss:.2f}</span><span class="st">.keras"</span>, save_freq<span class="op">=</span><span class="dv">100</span></span>
<span id="cb44-27"><a href="#cb44-27" tabindex="-1"></a>    )</span>
<span id="cb44-28"><a href="#cb44-28" tabindex="-1"></a>]</span>
<span id="cb44-29"><a href="#cb44-29" tabindex="-1"></a>model.fit(x_train, y_train, epochs<span class="op">=</span><span class="dv">1</span>, callbacks<span class="op">=</span>callbacks)</span></code></pre></div>
<p>You call also write your own callback for saving and restoring
models.</p>
<p>For a complete guide on serialization and saving, see the <a href="/guides/serialization_and_saving/">guide to saving and serializing
Models</a>.</p>
</div>
<div class="section level2">
<h2 id="using-learning-rate-schedules">Using learning rate schedules<a class="anchor" aria-label="anchor" href="#using-learning-rate-schedules"></a>
</h2>
<p>A common pattern when training deep learning models is to gradually
reduce the learning as training progresses. This is generally known as
“learning rate decay”.</p>
<p>The learning decay schedule could be static (fixed in advance, as a
function of the current epoch or the current batch index), or dynamic
(responding to the current behavior of the model, in particular the
validation loss).</p>
<div class="section level3">
<h3 id="passing-a-schedule-to-an-optimizer">Passing a schedule to an optimizer<a class="anchor" aria-label="anchor" href="#passing-a-schedule-to-an-optimizer"></a>
</h3>
<p>You can easily use a static learning rate decay schedule by passing a
schedule object as the <code>learning_rate</code> argument in your
optimizer:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a>initial_learning_rate <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>lr_schedule <span class="op">=</span> keras.optimizers.schedules.ExponentialDecay(</span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a>    initial_learning_rate, decay_steps<span class="op">=</span><span class="dv">100000</span>, decay_rate<span class="op">=</span><span class="fl">0.96</span>, staircase<span class="op">=</span><span class="va">True</span></span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a>)</span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" tabindex="-1"></a>optimizer <span class="op">=</span> keras.optimizers.RMSprop(learning_rate<span class="op">=</span>lr_schedule)</span></code></pre></div>
<p>Several built-in schedules are available:
<code>ExponentialDecay</code>, <code>PiecewiseConstantDecay</code>,
<code>PolynomialDecay</code>, and <code>InverseTimeDecay</code>.</p>
</div>
<div class="section level3">
<h3 id="using-callbacks-to-implement-a-dynamic-learning-rate-schedule">Using callbacks to implement a dynamic learning rate schedule<a class="anchor" aria-label="anchor" href="#using-callbacks-to-implement-a-dynamic-learning-rate-schedule"></a>
</h3>
<p>A dynamic learning rate schedule (for instance, decreasing the
learning rate when the validation loss is no longer improving) cannot be
achieved with these schedule objects, since the optimizer does not have
access to validation metrics.</p>
<p>However, callbacks do have access to all metrics, including
validation metrics! You can thus achieve this pattern by using a
callback that modifies the current learning rate on the optimizer. In
fact, this is even built-in as the <code>ReduceLROnPlateau</code>
callback.</p>
</div>
</div>
<div class="section level2">
<h2 id="visualizing-loss-and-metrics-during-training-with-tensorboard">Visualizing loss and metrics during training with TensorBoard<a class="anchor" aria-label="anchor" href="#visualizing-loss-and-metrics-during-training-with-tensorboard"></a>
</h2>
<p>The best way to keep an eye on your model during training is to use
<a href="https://www.tensorflow.org/tensorboard" class="external-link">TensorBoard</a> – a
browser-based application that you can run locally that provides you
with:</p>
<ul>
<li>Live plots of the loss and metrics for training and evaluation</li>
<li>(optionally) Visualizations of the histograms of your layer
activations</li>
<li>(optionally) 3D visualizations of the embedding spaces learned by
your <code>Embedding</code> layers</li>
</ul>
<p>If you have installed TensorFlow with pip, you should be able to
launch TensorBoard from the command line:</p>
<pre><code>tensorboard --logdir=/full_path_to_your_logs</code></pre>
<div class="section level3">
<h3 id="using-the-tensorboard-callback">Using the TensorBoard callback<a class="anchor" aria-label="anchor" href="#using-the-tensorboard-callback"></a>
</h3>
<p>The easiest way to use TensorBoard with a Keras model and the
<code><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit()</a></code> method is the <code>TensorBoard</code> callback.</p>
<p>In the simplest case, just specify where you want the callback to
write logs, and you’re good to go:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a>keras.callbacks.TensorBoard(</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>    log_dir<span class="op">=</span><span class="st">"/full_path_to_your_logs"</span>,</span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a>    histogram_freq<span class="op">=</span><span class="dv">0</span>,  <span class="co"># How often to log histogram visualizations</span></span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>    embeddings_freq<span class="op">=</span><span class="dv">0</span>,  <span class="co"># How often to log embedding visualizations</span></span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a>    update_freq<span class="op">=</span><span class="st">"epoch"</span>,</span>
<span id="cb47-6"><a href="#cb47-6" tabindex="-1"></a>)  <span class="co"># How often to write logs (default: once per epoch)</span></span></code></pre></div>
<p>For more information, see the <a href="https://keras.io/api/callbacks/tensorboard/" class="external-link">documentation for the
<code>TensorBoard</code> callback</a>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Tomasz Kalinowski, JJ Allaire, François Chollet, RStudio, Google.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.9000.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
