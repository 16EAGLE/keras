<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Denoising Diffusion Implicit Models • keras</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../../bootstrap-toc.css">
<script src="../../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><link href="../../extra.css" rel="stylesheet">
<script src="../../extra.js"></script><meta property="og:title" content="Denoising Diffusion Implicit Models">
<meta property="og:description" content="Generating images of flowers with denoising diffusion implicit models.">
<meta property="og:image" content="https://keras.posit.co/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">keras</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.13.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Tutorials
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/getting_started.html">Getting Started</a>
    </li>
    <li>
      <a href="../../articles/tutorial_basic_classification.html">Basic Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial_basic_text_classification.html">Text Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial_basic_regression.html">Basic Regression</a>
    </li>
    <li>
      <a href="../../articles/tutorial_overfit_underfit.html">Overfitting and Underfitting</a>
    </li>
    <li>
      <a href="../../articles/tutorial_save_and_restore.html">Save and Restore Models</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Guides
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/writing_your_own_callbacks.html">Writing Your Own Callbacks</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Guides (New for TF 2.6)</li>
    <li>
      <a href="../../articles/new-guides/python_subclasses.html">Python Subclasses</a>
    </li>
    <li>
      <a href="../../articles/new-guides/making_new_layers_and_models_via_subclassing.html">Making New Layers and Models via Subclassing</a>
    </li>
    <li>
      <a href="../../articles/new-guides/customizing_what_happens_in_fit.html">Customizing What Happens in Fit</a>
    </li>
    <li>
      <a href="../../articles/new-guides/writing_your_own_callbacks.html">Writing Your Own Callbacks</a>
    </li>
    <li>
      <a href="../../articles/new-guides/preprocessing_layers.html">Working with Preprocessing Layers</a>
    </li>
    <li>
      <a href="../../argicles/new-guides/working_with_rnns.html">Working with RNNs</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Using Keras</li>
    <li>
      <a href="../../articles/guide_keras.html">Guide to Keras Basics</a>
    </li>
    <li>
      <a href="../../articles/sequential_model.html">Sequential Model in Depth</a>
    </li>
    <li>
      <a href="../../articles/functional_api.html">Functional API in Depth</a>
    </li>
    <li>
      <a href="../../articles/about_keras_models.html">About Keras Models</a>
    </li>
    <li>
      <a href="../../articles/about_keras_layers.html">About Keras Layers</a>
    </li>
    <li>
      <a href="../../articles/training_visualization.html">Training Visualization</a>
    </li>
    <li>
      <a href="../../articles/applications.html">Pre-Trained Models</a>
    </li>
    <li>
      <a href="../../articles/faq.html">Frequently Asked Questions</a>
    </li>
    <li>
      <a href="../../articles/why_use_keras.html">Why Use Keras?</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Advanced</li>
    <li>
      <a href="../../articles/eager_guide.html">Eager Execution</a>
    </li>
    <li>
      <a href="../../articles/training_callbacks.html">Training Callbacks</a>
    </li>
    <li>
      <a href="../../articles/backend.html">Keras Backend</a>
    </li>
    <li>
      <a href="../../articles/custom_layers.html">Custom Layers</a>
    </li>
    <li>
      <a href="../../articles/custom_models.html">Custom Models</a>
    </li>
    <li>
      <a href="../../articles/saving_serializing.html">Saving and serializing</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../articles/learn.html">Learn</a>
</li>
<li>
  <a href="../../articles/tools.html">Tools</a>
</li>
<li>
  <a href="../../articles/examples/index.html">Examples</a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li>
  <a href="../../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/rstudio/keras/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Denoising Diffusion Implicit Models</h1>
                        <h4 data-toc-skip class="author"><a href="https://www.linkedin.com/in/andras-beres-789190210" class="external-link">András
Béres</a></h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/keras/blob/HEAD/vignettes/examples/ddim.Rmd" class="external-link"><code>vignettes/examples/ddim.Rmd</code></a></small>
      <div class="hidden name"><code>ddim.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<div class="section level3">
<h3 id="what-are-diffusion-models">What are diffusion models?<a class="anchor" aria-label="anchor" href="#what-are-diffusion-models"></a>
</h3>
<p>Recently, <a href="https://arxiv.org/abs/2006.11239" class="external-link">denoising
diffusion models</a>, including <a href="https://arxiv.org/abs/1907.05600" class="external-link">score-based generative
models</a>, gained popularity as a powerful class of generative models,
that can <a href="https://arxiv.org/abs/2105.05233" class="external-link">rival</a> even <a href="https://arxiv.org/abs/1406.2661" class="external-link">generative adversarial networks
(GANs)</a> in image synthesis quality. They tend to generate more
diverse samples, while being stable to train and easy to scale. Recent
large diffusion models, such as <a href="https://openai.com/dall-e-2/" class="external-link">DALL-E 2</a> and <a href="https://imagen.research.google/" class="external-link">Imagen</a>, have shown incredible
text-to-image generation capability. One of their drawbacks is however,
that they are slower to sample from, because they require multiple
forward passes for generating an image.</p>
<p>Diffusion refers to the process of turning a structured signal (an
image) into noise step-by-step. By simulating diffusion, we can generate
noisy images from our training images, and can train a neural network to
try to denoise them. Using the trained network we can simulate the
opposite of diffusion, reverse diffusion, which is the process of an
image emerging from noise.</p>
<div class="float">
<img src="https://i.imgur.com/dipPOfa.gif" alt="diffusion process gif"><div class="figcaption">diffusion process gif</div>
</div>
<p>One-sentence summary: <strong>diffusion models are trained to denoise
noisy images, and can generate images by iteratively denoising pure
noise.</strong></p>
</div>
<div class="section level3">
<h3 id="goal-of-this-example">Goal of this example<a class="anchor" aria-label="anchor" href="#goal-of-this-example"></a>
</h3>
<p>This code example intends to be a minimal but feature-complete (with
a generation quality metric) implementation of diffusion models, with
modest compute requirements and reasonable performance. My
implementation choices and hyperparameter tuning were done with these
goals in mind.</p>
<p>Since currently the literature of diffusion models is <a href="https://arxiv.org/abs/2206.00364" class="external-link">mathematically quite complex</a>
with multiple theoretical frameworks (<a href="https://arxiv.org/abs/1907.05600" class="external-link">score matching</a>, <a href="https://arxiv.org/abs/2011.13456" class="external-link">differential equations</a>, <a href="https://arxiv.org/abs/2006.11239" class="external-link">Markov chains</a>) and sometimes
even <a href="https://arxiv.org/abs/2010.02502" class="external-link">conflicting notations
(see Appendix C.2)</a>, it can be daunting trying to understand them. My
view of these models in this example will be that they learn to separate
a noisy image into its image and Gaussian noise components.</p>
<p>In this example I made effort to break down all long mathematical
expressions into digestible pieces and gave all variables explanatory
names. I also included numerous links to relevant literature to help
interested readers dive deeper into the topic, in the hope that this
code example will become a good starting point for practitioners
learning about diffusion models.</p>
<p>In the following sections, we will implement a continuous time
version of <a href="https://arxiv.org/abs/2010.02502" class="external-link">Denoising
Diffusion Implicit Models (DDIMs)</a> with deterministic sampling.</p>
</div>
</div>
<div class="section level2">
<h2 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> tensorflow_datasets <span class="im">as</span> tfds</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> keras <span class="im">as</span> keras</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> keras <span class="im">import</span> layers</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">from</span> keras <span class="im">import</span> ops</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="hyperparameters">Hyperparameters<a class="anchor" aria-label="anchor" href="#hyperparameters"></a>
</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># data</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>dataset_name <span class="op">=</span> <span class="st">"oxford_flowers102"</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>dataset_repetitions <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>num_epochs <span class="op">=</span> <span class="dv">1</span>  <span class="co"># train for at least 50 epochs for good results</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>image_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co"># KID = Kernel Inception Distance, see related section</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>kid_image_size <span class="op">=</span> <span class="dv">75</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>kid_diffusion_steps <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>plot_diffusion_steps <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co"># sampling</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>min_signal_rate <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>max_signal_rate <span class="op">=</span> <span class="fl">0.95</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co"># architecture</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>embedding_dims <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>embedding_max_frequency <span class="op">=</span> <span class="fl">1000.0</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>widths <span class="op">=</span> [<span class="dv">32</span>, <span class="dv">64</span>, <span class="dv">96</span>, <span class="dv">128</span>]</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>block_depth <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a><span class="co"># optimization</span></span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>ema <span class="op">=</span> <span class="fl">0.999</span></span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>learning_rate <span class="op">=</span> <span class="fl">1e-3</span></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>weight_decay <span class="op">=</span> <span class="fl">1e-4</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="data-pipeline">Data pipeline<a class="anchor" aria-label="anchor" href="#data-pipeline"></a>
</h2>
<p>We will use the <a href="https://www.tensorflow.org/datasets/catalog/oxford_flowers102" class="external-link">Oxford
Flowers 102</a> dataset for generating images of flowers, which is a
diverse natural dataset containing around 8,000 images. Unfortunately
the official splits are imbalanced, as most of the images are contained
in the test split. We create new splits (80% train, 20% validation)
using the <a href="https://www.tensorflow.org/datasets/splits" class="external-link">Tensorflow Datasets
slicing API</a>. We apply center crops as preprocessing, and repeat the
dataset multiple times (reason given in the next section).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="kw">def</span> preprocess_image(data):</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    <span class="co"># center crop image</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    height <span class="op">=</span> ops.shape(data[<span class="st">"image"</span>])[<span class="dv">0</span>]</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    width <span class="op">=</span> ops.shape(data[<span class="st">"image"</span>])[<span class="dv">1</span>]</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    crop_size <span class="op">=</span> ops.minimum(height, width)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    image <span class="op">=</span> tf.image.crop_to_bounding_box(</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>        data[<span class="st">"image"</span>],</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>        (height <span class="op">-</span> crop_size) <span class="op">//</span> <span class="dv">2</span>,</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        (width <span class="op">-</span> crop_size) <span class="op">//</span> <span class="dv">2</span>,</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>        crop_size,</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>        crop_size,</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    )</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>    <span class="co"># resize and clip</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>    <span class="co"># for image downsampling it is important to turn on antialiasing</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>    image <span class="op">=</span> tf.image.resize(</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>        image, size<span class="op">=</span>[image_size, image_size], antialias<span class="op">=</span><span class="va">True</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    )</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>    <span class="cf">return</span> ops.clip(image <span class="op">/</span> <span class="fl">255.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="kw">def</span> prepare_dataset(split):</span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>    <span class="co"># the validation dataset is shuffled as well, because data order matters</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>    <span class="co"># for the KID estimation</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a>        tfds.load(dataset_name, split<span class="op">=</span>split, shuffle_files<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>        .<span class="bu">map</span>(preprocess_image, num_parallel_calls<span class="op">=</span>tf.data.AUTOTUNE)</span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a>        .cache()</span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a>        .repeat(dataset_repetitions)</span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a>        .shuffle(<span class="dv">10</span> <span class="op">*</span> batch_size)</span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a>        .batch(batch_size, drop_remainder<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a>        .prefetch(buffer_size<span class="op">=</span>tf.data.AUTOTUNE)</span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a>    )</span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" tabindex="-1"></a></span>
<span id="cb3-36"><a href="#cb3-36" tabindex="-1"></a><span class="co"># load dataset</span></span>
<span id="cb3-37"><a href="#cb3-37" tabindex="-1"></a>train_dataset <span class="op">=</span> prepare_dataset(<span class="st">"train[:80%]+validation[:80%]+test[:80%]"</span>)</span>
<span id="cb3-38"><a href="#cb3-38" tabindex="-1"></a>val_dataset <span class="op">=</span> prepare_dataset(<span class="st">"train[80%:]+validation[80%:]+test[80%:]"</span>)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="kernel-inception-distance">Kernel inception distance<a class="anchor" aria-label="anchor" href="#kernel-inception-distance"></a>
</h2>
<p><a href="https://arxiv.org/abs/1801.01401" class="external-link">Kernel Inception Distance
(KID)</a> is an image quality metric which was proposed as a replacement
for the popular <a href="https://arxiv.org/abs/1706.08500" class="external-link">Frechet
Inception Distance (FID)</a>. I prefer KID to FID because it is simpler
to implement, can be estimated per-batch, and is computationally
lighter. More details <a href="https://keras.io/examples/generative/gan_ada/#kernel-inception-distance" class="external-link">here</a>.</p>
<p>In this example, the images are evaluated at the minimal possible
resolution of the Inception network (75x75 instead of 299x299), and the
metric is only measured on the validation set for computational
efficiency. We also limit the number of sampling steps at evaluation to
5 for the same reason.</p>
<p>Since the dataset is relatively small, we go over the train and
validation splits multiple times per epoch, because the KID estimation
is noisy and compute-intensive, so we want to evaluate only after many
iterations, but for many iterations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="at">@keras.saving.register_keras_serializable</span>()</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="kw">class</span> KID(keras.metrics.Metric):</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, <span class="op">**</span>kwargs):</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name<span class="op">=</span>name, <span class="op">**</span>kwargs)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>        <span class="co"># KID is estimated per batch and is averaged across batches</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>        <span class="va">self</span>.kid_tracker <span class="op">=</span> keras.metrics.Mean(name<span class="op">=</span><span class="st">"kid_tracker"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>        <span class="co"># a pretrained InceptionV3 is used without its classification layer</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>        <span class="co"># transform the pixel values to the 0-255 range, then use the same</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>        <span class="co"># preprocessing as during pretraining</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>        <span class="va">self</span>.encoder <span class="op">=</span> keras.Sequential(</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>            [</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>                keras.Input(shape<span class="op">=</span>(image_size, image_size, <span class="dv">3</span>)),</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>                layers.Rescaling(<span class="fl">255.0</span>),</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>                layers.Resizing(height<span class="op">=</span>kid_image_size, width<span class="op">=</span>kid_image_size),</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>                layers.Lambda(keras.applications.inception_v3.preprocess_input),</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>                keras.applications.InceptionV3(</span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>                    include_top<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a>                    input_shape<span class="op">=</span>(kid_image_size, kid_image_size, <span class="dv">3</span>),</span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a>                    weights<span class="op">=</span><span class="st">"imagenet"</span>,</span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a>                ),</span>
<span id="cb4-23"><a href="#cb4-23" tabindex="-1"></a>                layers.GlobalAveragePooling2D(),</span>
<span id="cb4-24"><a href="#cb4-24" tabindex="-1"></a>            ],</span>
<span id="cb4-25"><a href="#cb4-25" tabindex="-1"></a>            name<span class="op">=</span><span class="st">"inception_encoder"</span>,</span>
<span id="cb4-26"><a href="#cb4-26" tabindex="-1"></a>        )</span>
<span id="cb4-27"><a href="#cb4-27" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" tabindex="-1"></a>    <span class="kw">def</span> polynomial_kernel(<span class="va">self</span>, features_1, features_2):</span>
<span id="cb4-29"><a href="#cb4-29" tabindex="-1"></a>        feature_dimensions <span class="op">=</span> ops.cast(ops.shape(features_1)[<span class="dv">1</span>], dtype<span class="op">=</span><span class="st">"float32"</span>)</span>
<span id="cb4-30"><a href="#cb4-30" tabindex="-1"></a>        <span class="cf">return</span> (</span>
<span id="cb4-31"><a href="#cb4-31" tabindex="-1"></a>            features_1 <span class="op">@</span> ops.transpose(features_2) <span class="op">/</span> feature_dimensions <span class="op">+</span> <span class="fl">1.0</span></span>
<span id="cb4-32"><a href="#cb4-32" tabindex="-1"></a>        ) <span class="op">**</span> <span class="fl">3.0</span></span>
<span id="cb4-33"><a href="#cb4-33" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" tabindex="-1"></a>    <span class="kw">def</span> update_state(<span class="va">self</span>, real_images, generated_images, sample_weight<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb4-35"><a href="#cb4-35" tabindex="-1"></a>        real_features <span class="op">=</span> <span class="va">self</span>.encoder(real_images, training<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-36"><a href="#cb4-36" tabindex="-1"></a>        generated_features <span class="op">=</span> <span class="va">self</span>.encoder(generated_images, training<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-37"><a href="#cb4-37" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" tabindex="-1"></a>        <span class="co"># compute polynomial kernels using the two sets of features</span></span>
<span id="cb4-39"><a href="#cb4-39" tabindex="-1"></a>        kernel_real <span class="op">=</span> <span class="va">self</span>.polynomial_kernel(real_features, real_features)</span>
<span id="cb4-40"><a href="#cb4-40" tabindex="-1"></a>        kernel_generated <span class="op">=</span> <span class="va">self</span>.polynomial_kernel(</span>
<span id="cb4-41"><a href="#cb4-41" tabindex="-1"></a>            generated_features, generated_features</span>
<span id="cb4-42"><a href="#cb4-42" tabindex="-1"></a>        )</span>
<span id="cb4-43"><a href="#cb4-43" tabindex="-1"></a>        kernel_cross <span class="op">=</span> <span class="va">self</span>.polynomial_kernel(real_features, generated_features)</span>
<span id="cb4-44"><a href="#cb4-44" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" tabindex="-1"></a>        <span class="co"># estimate the squared maximum mean discrepancy using the average kernel values</span></span>
<span id="cb4-46"><a href="#cb4-46" tabindex="-1"></a>        batch_size <span class="op">=</span> real_features.shape[<span class="dv">0</span>]</span>
<span id="cb4-47"><a href="#cb4-47" tabindex="-1"></a>        batch_size_f <span class="op">=</span> ops.cast(batch_size, dtype<span class="op">=</span><span class="st">"float32"</span>)</span>
<span id="cb4-48"><a href="#cb4-48" tabindex="-1"></a>        mean_kernel_real <span class="op">=</span> ops.<span class="bu">sum</span>(</span>
<span id="cb4-49"><a href="#cb4-49" tabindex="-1"></a>            kernel_real <span class="op">*</span> (<span class="fl">1.0</span> <span class="op">-</span> ops.eye(batch_size))</span>
<span id="cb4-50"><a href="#cb4-50" tabindex="-1"></a>        ) <span class="op">/</span> (batch_size_f <span class="op">*</span> (batch_size_f <span class="op">-</span> <span class="fl">1.0</span>))</span>
<span id="cb4-51"><a href="#cb4-51" tabindex="-1"></a>        mean_kernel_generated <span class="op">=</span> ops.<span class="bu">sum</span>(</span>
<span id="cb4-52"><a href="#cb4-52" tabindex="-1"></a>            kernel_generated <span class="op">*</span> (<span class="fl">1.0</span> <span class="op">-</span> ops.eye(batch_size))</span>
<span id="cb4-53"><a href="#cb4-53" tabindex="-1"></a>        ) <span class="op">/</span> (batch_size_f <span class="op">*</span> (batch_size_f <span class="op">-</span> <span class="fl">1.0</span>))</span>
<span id="cb4-54"><a href="#cb4-54" tabindex="-1"></a>        mean_kernel_cross <span class="op">=</span> ops.mean(kernel_cross)</span>
<span id="cb4-55"><a href="#cb4-55" tabindex="-1"></a>        kid <span class="op">=</span> mean_kernel_real <span class="op">+</span> mean_kernel_generated <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> mean_kernel_cross</span>
<span id="cb4-56"><a href="#cb4-56" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" tabindex="-1"></a>        <span class="co"># update the average KID estimate</span></span>
<span id="cb4-58"><a href="#cb4-58" tabindex="-1"></a>        <span class="va">self</span>.kid_tracker.update_state(kid)</span>
<span id="cb4-59"><a href="#cb4-59" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" tabindex="-1"></a>    <span class="kw">def</span> result(<span class="va">self</span>):</span>
<span id="cb4-61"><a href="#cb4-61" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.kid_tracker.result()</span>
<span id="cb4-62"><a href="#cb4-62" tabindex="-1"></a></span>
<span id="cb4-63"><a href="#cb4-63" tabindex="-1"></a>    <span class="kw">def</span> reset_state(<span class="va">self</span>):</span>
<span id="cb4-64"><a href="#cb4-64" tabindex="-1"></a>        <span class="va">self</span>.kid_tracker.reset_state()</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="network-architecture">Network architecture<a class="anchor" aria-label="anchor" href="#network-architecture"></a>
</h2>
<p>Here we specify the architecture of the neural network that we will
use for denoising. We build a <a href="https://arxiv.org/abs/1505.04597" class="external-link">U-Net</a> with identical input
and output dimensions. U-Net is a popular semantic segmentation
architecture, whose main idea is that it progressively downsamples and
then upsamples its input image, and adds skip connections between layers
having the same resolution. These help with gradient flow and avoid
introducing a representation bottleneck, unlike usual <a href="https://www.deeplearningbook.org/contents/autoencoders.html" class="external-link">autoencoders</a>.
Based on this, one can view <a href="https://benanne.github.io/2022/01/31/diffusion.html" class="external-link">diffusion
models as denoising autoencoders</a> without a bottleneck.</p>
<p>The network takes two inputs, the noisy images and the variances of
their noise components. The latter is required since denoising a signal
requires different operations at different levels of noise. We transform
the noise variances using sinusoidal embeddings, similarly to positional
encodings used both in <a href="https://arxiv.org/abs/1706.03762" class="external-link">transformers</a> and <a href="https://arxiv.org/abs/2003.08934" class="external-link">NeRF</a>. This helps the network
to be <a href="https://arxiv.org/abs/2006.10739" class="external-link">highly sensitive</a> to
the noise level, which is crucial for good performance. We implement
sinusoidal embeddings using a <a href="https://keras.io/api/layers/core_layers/lambda/" class="external-link">Lambda
layer</a>.</p>
<p>Some other considerations:</p>
<ul>
<li>We build the network using the <a href="https://keras.io/guides/functional_api/" class="external-link">Keras Functional API</a>,
and use <a href="https://twitter.com/fchollet/status/1441927912836321280" class="external-link">closures</a>
to build blocks of layers in a consistent style.</li>
<li>
<a href="https://arxiv.org/abs/2006.11239" class="external-link">Diffusion models</a>
embed the index of the timestep of the diffusion process instead of the
noise variance, while <a href="https://arxiv.org/abs/2206.00364" class="external-link">score-based models (Table 1)</a>
usually use some function of the noise level. I prefer the latter so
that we can change the sampling schedule at inference time, without
retraining the network.</li>
<li>
<a href="https://arxiv.org/abs/2006.11239" class="external-link">Diffusion models</a>
input the embedding to each convolution block separately. We only input
it at the start of the network for simplicity, which in my experience
barely decreases performance, because the skip and residual connections
help the information propagate through the network properly.</li>
<li>In the literature it is common to use <a href="https://keras.io/api/layers/attention_layers/multi_head_attention/" class="external-link">attention
layers</a> at lower resolutions for better global coherence. I omitted
it for simplicity.</li>
<li>We disable the learnable center and scale parameters of the batch
normalization layers, since the following convolution layers make them
redundant.</li>
<li>We initialize the last convolution’s kernel to all zeros as a good
practice, making the network predict only zeros after initialization,
which is the mean of its targets. This will improve behaviour at the
start of training and make the mean squared error loss start at exactly
1.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="at">@keras.saving.register_keras_serializable</span>()</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="kw">def</span> sinusoidal_embedding(x):</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    embedding_min_frequency <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    frequencies <span class="op">=</span> ops.exp(</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>        ops.linspace(</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>            ops.log(embedding_min_frequency),</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>            ops.log(embedding_max_frequency),</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>            embedding_dims <span class="op">//</span> <span class="dv">2</span>,</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>        )</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    )</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>    angular_speeds <span class="op">=</span> ops.cast(<span class="fl">2.0</span> <span class="op">*</span> math.pi <span class="op">*</span> frequencies, <span class="st">"float32"</span>)</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>    embeddings <span class="op">=</span> ops.concatenate(</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>        [ops.sin(angular_speeds <span class="op">*</span> x), ops.cos(angular_speeds <span class="op">*</span> x)], axis<span class="op">=</span><span class="dv">3</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>    )</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>    <span class="cf">return</span> embeddings</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="kw">def</span> ResidualBlock(width):</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">apply</span>(x):</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>        input_width <span class="op">=</span> x.shape[<span class="dv">3</span>]</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>        <span class="cf">if</span> input_width <span class="op">==</span> width:</span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>            residual <span class="op">=</span> x</span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a>            residual <span class="op">=</span> layers.Conv2D(width, kernel_size<span class="op">=</span><span class="dv">1</span>)(x)</span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a>        x <span class="op">=</span> layers.BatchNormalization(center<span class="op">=</span><span class="va">False</span>, scale<span class="op">=</span><span class="va">False</span>)(x)</span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a>        x <span class="op">=</span> layers.Conv2D(</span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a>            width, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="st">"same"</span>, activation<span class="op">=</span><span class="st">"swish"</span></span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a>        )(x)</span>
<span id="cb5-29"><a href="#cb5-29" tabindex="-1"></a>        x <span class="op">=</span> layers.Conv2D(width, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="st">"same"</span>)(x)</span>
<span id="cb5-30"><a href="#cb5-30" tabindex="-1"></a>        x <span class="op">=</span> layers.Add()([x, residual])</span>
<span id="cb5-31"><a href="#cb5-31" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb5-32"><a href="#cb5-32" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">apply</span></span>
<span id="cb5-34"><a href="#cb5-34" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" tabindex="-1"></a><span class="kw">def</span> DownBlock(width, block_depth):</span>
<span id="cb5-37"><a href="#cb5-37" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">apply</span>(x):</span>
<span id="cb5-38"><a href="#cb5-38" tabindex="-1"></a>        x, skips <span class="op">=</span> x</span>
<span id="cb5-39"><a href="#cb5-39" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(block_depth):</span>
<span id="cb5-40"><a href="#cb5-40" tabindex="-1"></a>            x <span class="op">=</span> ResidualBlock(width)(x)</span>
<span id="cb5-41"><a href="#cb5-41" tabindex="-1"></a>            skips.append(x)</span>
<span id="cb5-42"><a href="#cb5-42" tabindex="-1"></a>        x <span class="op">=</span> layers.AveragePooling2D(pool_size<span class="op">=</span><span class="dv">2</span>)(x)</span>
<span id="cb5-43"><a href="#cb5-43" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb5-44"><a href="#cb5-44" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">apply</span></span>
<span id="cb5-46"><a href="#cb5-46" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" tabindex="-1"></a></span>
<span id="cb5-48"><a href="#cb5-48" tabindex="-1"></a><span class="kw">def</span> UpBlock(width, block_depth):</span>
<span id="cb5-49"><a href="#cb5-49" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">apply</span>(x):</span>
<span id="cb5-50"><a href="#cb5-50" tabindex="-1"></a>        x, skips <span class="op">=</span> x</span>
<span id="cb5-51"><a href="#cb5-51" tabindex="-1"></a>        x <span class="op">=</span> layers.UpSampling2D(size<span class="op">=</span><span class="dv">2</span>, interpolation<span class="op">=</span><span class="st">"bilinear"</span>)(x)</span>
<span id="cb5-52"><a href="#cb5-52" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(block_depth):</span>
<span id="cb5-53"><a href="#cb5-53" tabindex="-1"></a>            x <span class="op">=</span> layers.Concatenate()([x, skips.pop()])</span>
<span id="cb5-54"><a href="#cb5-54" tabindex="-1"></a>            x <span class="op">=</span> ResidualBlock(width)(x)</span>
<span id="cb5-55"><a href="#cb5-55" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb5-56"><a href="#cb5-56" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">apply</span></span>
<span id="cb5-58"><a href="#cb5-58" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" tabindex="-1"></a><span class="kw">def</span> get_network(image_size, widths, block_depth):</span>
<span id="cb5-61"><a href="#cb5-61" tabindex="-1"></a>    noisy_images <span class="op">=</span> keras.Input(shape<span class="op">=</span>(image_size, image_size, <span class="dv">3</span>))</span>
<span id="cb5-62"><a href="#cb5-62" tabindex="-1"></a>    noise_variances <span class="op">=</span> keras.Input(shape<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-63"><a href="#cb5-63" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" tabindex="-1"></a>    e <span class="op">=</span> layers.Lambda(sinusoidal_embedding, output_shape<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">32</span>))(</span>
<span id="cb5-65"><a href="#cb5-65" tabindex="-1"></a>        noise_variances</span>
<span id="cb5-66"><a href="#cb5-66" tabindex="-1"></a>    )</span>
<span id="cb5-67"><a href="#cb5-67" tabindex="-1"></a>    e <span class="op">=</span> layers.UpSampling2D(size<span class="op">=</span>image_size, interpolation<span class="op">=</span><span class="st">"nearest"</span>)(e)</span>
<span id="cb5-68"><a href="#cb5-68" tabindex="-1"></a></span>
<span id="cb5-69"><a href="#cb5-69" tabindex="-1"></a>    x <span class="op">=</span> layers.Conv2D(widths[<span class="dv">0</span>], kernel_size<span class="op">=</span><span class="dv">1</span>)(noisy_images)</span>
<span id="cb5-70"><a href="#cb5-70" tabindex="-1"></a>    x <span class="op">=</span> layers.Concatenate()([x, e])</span>
<span id="cb5-71"><a href="#cb5-71" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" tabindex="-1"></a>    skips <span class="op">=</span> []</span>
<span id="cb5-73"><a href="#cb5-73" tabindex="-1"></a>    <span class="cf">for</span> width <span class="kw">in</span> widths[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb5-74"><a href="#cb5-74" tabindex="-1"></a>        x <span class="op">=</span> DownBlock(width, block_depth)([x, skips])</span>
<span id="cb5-75"><a href="#cb5-75" tabindex="-1"></a></span>
<span id="cb5-76"><a href="#cb5-76" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(block_depth):</span>
<span id="cb5-77"><a href="#cb5-77" tabindex="-1"></a>        x <span class="op">=</span> ResidualBlock(widths[<span class="op">-</span><span class="dv">1</span>])(x)</span>
<span id="cb5-78"><a href="#cb5-78" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" tabindex="-1"></a>    <span class="cf">for</span> width <span class="kw">in</span> <span class="bu">reversed</span>(widths[:<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb5-80"><a href="#cb5-80" tabindex="-1"></a>        x <span class="op">=</span> UpBlock(width, block_depth)([x, skips])</span>
<span id="cb5-81"><a href="#cb5-81" tabindex="-1"></a></span>
<span id="cb5-82"><a href="#cb5-82" tabindex="-1"></a>    x <span class="op">=</span> layers.Conv2D(<span class="dv">3</span>, kernel_size<span class="op">=</span><span class="dv">1</span>, kernel_initializer<span class="op">=</span><span class="st">"zeros"</span>)(x)</span>
<span id="cb5-83"><a href="#cb5-83" tabindex="-1"></a></span>
<span id="cb5-84"><a href="#cb5-84" tabindex="-1"></a>    <span class="cf">return</span> keras.Model([noisy_images, noise_variances], x, name<span class="op">=</span><span class="st">"residual_unet"</span>)</span></code></pre></div>
<p>This showcases the power of the Functional API. Note how we built a
relatively complex U-Net with skip connections, residual blocks,
multiple inputs, and sinusoidal embeddings in 80 lines of code!</p>
</div>
<div class="section level2">
<h2 id="diffusion-model">Diffusion model<a class="anchor" aria-label="anchor" href="#diffusion-model"></a>
</h2>
<div class="section level3">
<h3 id="diffusion-schedule">Diffusion schedule<a class="anchor" aria-label="anchor" href="#diffusion-schedule"></a>
</h3>
<p>Let us say, that a diffusion process starts at time = 0, and ends at
time = 1. This variable will be called diffusion time, and can be either
discrete (common in diffusion models) or continuous (common in
score-based models). I choose the latter, so that the number of sampling
steps can be changed at inference time.</p>
<p>We need to have a function that tells us at each point in the
diffusion process the noise levels and signal levels of the noisy image
corresponding to the actual diffusion time. This will be called the
diffusion schedule (see <code>diffusion_schedule()</code>).</p>
<p>This schedule outputs two quantities: the <code>noise_rate</code> and
the <code>signal_rate</code> (corresponding to sqrt(1 - alpha) and
sqrt(alpha) in the DDIM paper, respectively). We generate the noisy
image by weighting the random noise and the training image by their
corresponding rates and adding them together.</p>
<p>Since the (standard normal) random noises and the (normalized) images
both have zero mean and unit variance, the noise rate and signal rate
can be interpreted as the standard deviation of their components in the
noisy image, while the squares of their rates can be interpreted as
their variance (or their power in the signal processing sense). The
rates will always be set so that their squared sum is 1, meaning that
the noisy images will always have unit variance, just like its unscaled
components.</p>
<p>We will use a simplified, continuous version of the <a href="https://arxiv.org/abs/2102.09672" class="external-link">cosine schedule (Section
3.2)</a>, that is quite commonly used in the literature. This schedule
is symmetric, slow towards the start and end of the diffusion process,
and it also has a nice geometric interpretation, using the <a href="https://en.wikipedia.org/wiki/Unit_circle#/media/File:Circle-trig6.svg" class="external-link">trigonometric
properties of the unit circle</a>:</p>
<div class="float">
<img src="https://i.imgur.com/JW9W0fA.gif" alt="diffusion schedule gif"><div class="figcaption">diffusion schedule gif</div>
</div>
</div>
<div class="section level3">
<h3 id="training-process">Training process<a class="anchor" aria-label="anchor" href="#training-process"></a>
</h3>
<p>The training procedure (see <code>train_step()</code> and
<code>denoise()</code>) of denoising diffusion models is the following:
we sample random diffusion times uniformly, and mix the training images
with random gaussian noises at rates corresponding to the diffusion
times. Then, we train the model to separate the noisy image to its two
components.</p>
<p>Usually, the neural network is trained to predict the unscaled noise
component, from which the predicted image component can be calculated
using the signal and noise rates. Pixelwise <a href="https://keras.io/api/losses/regression_losses/#mean_squared_error-function" class="external-link">mean
squared error</a> should be used theoretically, however I recommend
using <a href="https://keras.io/api/losses/regression_losses/#mean_absolute_error-function" class="external-link">mean
absolute error</a> instead (similarly to <a href="https://github.com/lucidrains/denoising-diffusion-pytorch/blob/master/denoising_diffusion_pytorch/denoising_diffusion_pytorch.py#L371" class="external-link">this</a>
implementation), which produces better results on this dataset.</p>
</div>
<div class="section level3">
<h3 id="sampling-reverse-diffusion">Sampling (reverse diffusion)<a class="anchor" aria-label="anchor" href="#sampling-reverse-diffusion"></a>
</h3>
<p>When sampling (see <code>reverse_diffusion()</code>), at each step we
take the previous estimate of the noisy image and separate it into image
and noise using our network. Then we recombine these components using
the signal and noise rate of the following step.</p>
<p>Though a similar view is shown in <a href="https://arxiv.org/abs/2010.02502" class="external-link">Equation 12 of DDIMs</a>, I
believe the above explanation of the sampling equation is not widely
known.</p>
<p>This example only implements the deterministic sampling procedure
from DDIM, which corresponds to <em>eta = 0</em> in the paper. One can
also use stochastic sampling (in which case the model becomes a <a href="https://arxiv.org/abs/2006.11239" class="external-link">Denoising Diffusion
Probabilistic Model (DDPM)</a>), where a part of the predicted noise is
replaced with the same or larger amount of random noise (<a href="https://arxiv.org/abs/2010.02502" class="external-link">see Equation 16 and
below</a>).</p>
<p>Stochastic sampling can be used without retraining the network (since
both models are trained the same way), and it can improve sample
quality, while on the other hand requiring more sampling steps
usually.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="at">@keras.saving.register_keras_serializable</span>()</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="kw">class</span> DiffusionModel(keras.Model):</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, image_size, widths, block_depth):</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>        <span class="va">self</span>.normalizer <span class="op">=</span> layers.Normalization()</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        <span class="va">self</span>.network <span class="op">=</span> get_network(image_size, widths, block_depth)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        <span class="va">self</span>.ema_network <span class="op">=</span> keras.models.clone_model(<span class="va">self</span>.network)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">compile</span>(<span class="va">self</span>, <span class="op">**</span>kwargs):</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        <span class="bu">super</span>().<span class="bu">compile</span>(<span class="op">**</span>kwargs)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>        <span class="va">self</span>.noise_loss_tracker <span class="op">=</span> keras.metrics.Mean(name<span class="op">=</span><span class="st">"n_loss"</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>        <span class="va">self</span>.image_loss_tracker <span class="op">=</span> keras.metrics.Mean(name<span class="op">=</span><span class="st">"i_loss"</span>)</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>        <span class="va">self</span>.kid <span class="op">=</span> KID(name<span class="op">=</span><span class="st">"kid"</span>)</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>    <span class="kw">def</span> metrics(<span class="va">self</span>):</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>        <span class="cf">return</span> [<span class="va">self</span>.noise_loss_tracker, <span class="va">self</span>.image_loss_tracker, <span class="va">self</span>.kid]</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>    <span class="kw">def</span> denormalize(<span class="va">self</span>, images):</span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>        <span class="co"># convert the pixel values back to 0-1 range</span></span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>        images <span class="op">=</span> <span class="va">self</span>.normalizer.mean <span class="op">+</span> images <span class="op">*</span> <span class="va">self</span>.normalizer.variance<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a>        <span class="cf">return</span> ops.clip(images, <span class="fl">0.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a>    <span class="kw">def</span> diffusion_schedule(<span class="va">self</span>, diffusion_times):</span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a>        <span class="co"># diffusion times -&gt; angles</span></span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a>        start_angle <span class="op">=</span> ops.cast(ops.arccos(max_signal_rate), <span class="st">"float32"</span>)</span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a>        end_angle <span class="op">=</span> ops.cast(ops.arccos(min_signal_rate), <span class="st">"float32"</span>)</span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a>        diffusion_angles <span class="op">=</span> start_angle <span class="op">+</span> diffusion_times <span class="op">*</span> (</span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a>            end_angle <span class="op">-</span> start_angle</span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a>        )</span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" tabindex="-1"></a>        <span class="co"># angles -&gt; signal and noise rates</span></span>
<span id="cb6-36"><a href="#cb6-36" tabindex="-1"></a>        signal_rates <span class="op">=</span> ops.cos(diffusion_angles)</span>
<span id="cb6-37"><a href="#cb6-37" tabindex="-1"></a>        noise_rates <span class="op">=</span> ops.sin(diffusion_angles)</span>
<span id="cb6-38"><a href="#cb6-38" tabindex="-1"></a>        <span class="co"># note that their squared sum is always: sin^2(x) + cos^2(x) = 1</span></span>
<span id="cb6-39"><a href="#cb6-39" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" tabindex="-1"></a>        <span class="cf">return</span> noise_rates, signal_rates</span>
<span id="cb6-41"><a href="#cb6-41" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" tabindex="-1"></a>    <span class="kw">def</span> denoise(<span class="va">self</span>, noisy_images, noise_rates, signal_rates, training):</span>
<span id="cb6-43"><a href="#cb6-43" tabindex="-1"></a>        <span class="co"># the exponential moving average weights are used at evaluation</span></span>
<span id="cb6-44"><a href="#cb6-44" tabindex="-1"></a>        <span class="cf">if</span> training:</span>
<span id="cb6-45"><a href="#cb6-45" tabindex="-1"></a>            network <span class="op">=</span> <span class="va">self</span>.network</span>
<span id="cb6-46"><a href="#cb6-46" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-47"><a href="#cb6-47" tabindex="-1"></a>            network <span class="op">=</span> <span class="va">self</span>.ema_network</span>
<span id="cb6-48"><a href="#cb6-48" tabindex="-1"></a></span>
<span id="cb6-49"><a href="#cb6-49" tabindex="-1"></a>        <span class="co"># predict noise component and calculate the image component using it</span></span>
<span id="cb6-50"><a href="#cb6-50" tabindex="-1"></a>        pred_noises <span class="op">=</span> network(</span>
<span id="cb6-51"><a href="#cb6-51" tabindex="-1"></a>            [noisy_images, noise_rates<span class="op">**</span><span class="dv">2</span>], training<span class="op">=</span>training</span>
<span id="cb6-52"><a href="#cb6-52" tabindex="-1"></a>        )</span>
<span id="cb6-53"><a href="#cb6-53" tabindex="-1"></a>        pred_images <span class="op">=</span> (noisy_images <span class="op">-</span> noise_rates <span class="op">*</span> pred_noises) <span class="op">/</span> signal_rates</span>
<span id="cb6-54"><a href="#cb6-54" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" tabindex="-1"></a>        <span class="cf">return</span> pred_noises, pred_images</span>
<span id="cb6-56"><a href="#cb6-56" tabindex="-1"></a></span>
<span id="cb6-57"><a href="#cb6-57" tabindex="-1"></a>    <span class="kw">def</span> reverse_diffusion(<span class="va">self</span>, initial_noise, diffusion_steps):</span>
<span id="cb6-58"><a href="#cb6-58" tabindex="-1"></a>        <span class="co"># reverse diffusion = sampling</span></span>
<span id="cb6-59"><a href="#cb6-59" tabindex="-1"></a>        num_images <span class="op">=</span> initial_noise.shape[<span class="dv">0</span>]</span>
<span id="cb6-60"><a href="#cb6-60" tabindex="-1"></a>        step_size <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> diffusion_steps</span>
<span id="cb6-61"><a href="#cb6-61" tabindex="-1"></a></span>
<span id="cb6-62"><a href="#cb6-62" tabindex="-1"></a>        <span class="co"># important line:</span></span>
<span id="cb6-63"><a href="#cb6-63" tabindex="-1"></a>        <span class="co"># at the first sampling step, the "noisy image" is pure noise</span></span>
<span id="cb6-64"><a href="#cb6-64" tabindex="-1"></a>        <span class="co"># but its signal rate is assumed to be nonzero (min_signal_rate)</span></span>
<span id="cb6-65"><a href="#cb6-65" tabindex="-1"></a>        next_noisy_images <span class="op">=</span> initial_noise</span>
<span id="cb6-66"><a href="#cb6-66" tabindex="-1"></a>        <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(diffusion_steps):</span>
<span id="cb6-67"><a href="#cb6-67" tabindex="-1"></a>            noisy_images <span class="op">=</span> next_noisy_images</span>
<span id="cb6-68"><a href="#cb6-68" tabindex="-1"></a></span>
<span id="cb6-69"><a href="#cb6-69" tabindex="-1"></a>            <span class="co"># separate the current noisy image to its components</span></span>
<span id="cb6-70"><a href="#cb6-70" tabindex="-1"></a>            diffusion_times <span class="op">=</span> ops.ones((num_images, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">-</span> step <span class="op">*</span> step_size</span>
<span id="cb6-71"><a href="#cb6-71" tabindex="-1"></a>            noise_rates, signal_rates <span class="op">=</span> <span class="va">self</span>.diffusion_schedule(diffusion_times)</span>
<span id="cb6-72"><a href="#cb6-72" tabindex="-1"></a>            pred_noises, pred_images <span class="op">=</span> <span class="va">self</span>.denoise(</span>
<span id="cb6-73"><a href="#cb6-73" tabindex="-1"></a>                noisy_images, noise_rates, signal_rates, training<span class="op">=</span><span class="va">False</span></span>
<span id="cb6-74"><a href="#cb6-74" tabindex="-1"></a>            )</span>
<span id="cb6-75"><a href="#cb6-75" tabindex="-1"></a>            <span class="co"># network used in eval mode</span></span>
<span id="cb6-76"><a href="#cb6-76" tabindex="-1"></a></span>
<span id="cb6-77"><a href="#cb6-77" tabindex="-1"></a>            <span class="co"># remix the predicted components using the next signal and noise rates</span></span>
<span id="cb6-78"><a href="#cb6-78" tabindex="-1"></a>            next_diffusion_times <span class="op">=</span> diffusion_times <span class="op">-</span> step_size</span>
<span id="cb6-79"><a href="#cb6-79" tabindex="-1"></a>            next_noise_rates, next_signal_rates <span class="op">=</span> <span class="va">self</span>.diffusion_schedule(</span>
<span id="cb6-80"><a href="#cb6-80" tabindex="-1"></a>                next_diffusion_times</span>
<span id="cb6-81"><a href="#cb6-81" tabindex="-1"></a>            )</span>
<span id="cb6-82"><a href="#cb6-82" tabindex="-1"></a>            next_noisy_images <span class="op">=</span> (</span>
<span id="cb6-83"><a href="#cb6-83" tabindex="-1"></a>                next_signal_rates <span class="op">*</span> pred_images <span class="op">+</span> next_noise_rates <span class="op">*</span> pred_noises</span>
<span id="cb6-84"><a href="#cb6-84" tabindex="-1"></a>            )</span>
<span id="cb6-85"><a href="#cb6-85" tabindex="-1"></a>            <span class="co"># this new noisy image will be used in the next step</span></span>
<span id="cb6-86"><a href="#cb6-86" tabindex="-1"></a></span>
<span id="cb6-87"><a href="#cb6-87" tabindex="-1"></a>        <span class="cf">return</span> pred_images</span>
<span id="cb6-88"><a href="#cb6-88" tabindex="-1"></a></span>
<span id="cb6-89"><a href="#cb6-89" tabindex="-1"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, num_images, diffusion_steps):</span>
<span id="cb6-90"><a href="#cb6-90" tabindex="-1"></a>        <span class="co"># noise -&gt; images -&gt; denormalized images</span></span>
<span id="cb6-91"><a href="#cb6-91" tabindex="-1"></a>        initial_noise <span class="op">=</span> keras.random.normal(</span>
<span id="cb6-92"><a href="#cb6-92" tabindex="-1"></a>            shape<span class="op">=</span>(num_images, image_size, image_size, <span class="dv">3</span>)</span>
<span id="cb6-93"><a href="#cb6-93" tabindex="-1"></a>        )</span>
<span id="cb6-94"><a href="#cb6-94" tabindex="-1"></a>        generated_images <span class="op">=</span> <span class="va">self</span>.reverse_diffusion(</span>
<span id="cb6-95"><a href="#cb6-95" tabindex="-1"></a>            initial_noise, diffusion_steps</span>
<span id="cb6-96"><a href="#cb6-96" tabindex="-1"></a>        )</span>
<span id="cb6-97"><a href="#cb6-97" tabindex="-1"></a>        generated_images <span class="op">=</span> <span class="va">self</span>.denormalize(generated_images)</span>
<span id="cb6-98"><a href="#cb6-98" tabindex="-1"></a>        <span class="cf">return</span> generated_images</span>
<span id="cb6-99"><a href="#cb6-99" tabindex="-1"></a></span>
<span id="cb6-100"><a href="#cb6-100" tabindex="-1"></a>    <span class="kw">def</span> train_step(<span class="va">self</span>, images):</span>
<span id="cb6-101"><a href="#cb6-101" tabindex="-1"></a>        <span class="co"># normalize images to have standard deviation of 1, like the noises</span></span>
<span id="cb6-102"><a href="#cb6-102" tabindex="-1"></a>        images <span class="op">=</span> <span class="va">self</span>.normalizer(images, training<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-103"><a href="#cb6-103" tabindex="-1"></a>        noises <span class="op">=</span> keras.random.normal(</span>
<span id="cb6-104"><a href="#cb6-104" tabindex="-1"></a>            shape<span class="op">=</span>(batch_size, image_size, image_size, <span class="dv">3</span>)</span>
<span id="cb6-105"><a href="#cb6-105" tabindex="-1"></a>        )</span>
<span id="cb6-106"><a href="#cb6-106" tabindex="-1"></a></span>
<span id="cb6-107"><a href="#cb6-107" tabindex="-1"></a>        <span class="co"># sample uniform random diffusion times</span></span>
<span id="cb6-108"><a href="#cb6-108" tabindex="-1"></a>        diffusion_times <span class="op">=</span> keras.random.uniform(</span>
<span id="cb6-109"><a href="#cb6-109" tabindex="-1"></a>            shape<span class="op">=</span>(batch_size, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb6-110"><a href="#cb6-110" tabindex="-1"></a>        )</span>
<span id="cb6-111"><a href="#cb6-111" tabindex="-1"></a>        noise_rates, signal_rates <span class="op">=</span> <span class="va">self</span>.diffusion_schedule(diffusion_times)</span>
<span id="cb6-112"><a href="#cb6-112" tabindex="-1"></a>        <span class="co"># mix the images with noises accordingly</span></span>
<span id="cb6-113"><a href="#cb6-113" tabindex="-1"></a>        noisy_images <span class="op">=</span> signal_rates <span class="op">*</span> images <span class="op">+</span> noise_rates <span class="op">*</span> noises</span>
<span id="cb6-114"><a href="#cb6-114" tabindex="-1"></a></span>
<span id="cb6-115"><a href="#cb6-115" tabindex="-1"></a>        <span class="cf">with</span> tf.GradientTape() <span class="im">as</span> tape:</span>
<span id="cb6-116"><a href="#cb6-116" tabindex="-1"></a>            <span class="co"># train the network to separate noisy images to their components</span></span>
<span id="cb6-117"><a href="#cb6-117" tabindex="-1"></a>            pred_noises, pred_images <span class="op">=</span> <span class="va">self</span>.denoise(</span>
<span id="cb6-118"><a href="#cb6-118" tabindex="-1"></a>                noisy_images, noise_rates, signal_rates, training<span class="op">=</span><span class="va">True</span></span>
<span id="cb6-119"><a href="#cb6-119" tabindex="-1"></a>            )</span>
<span id="cb6-120"><a href="#cb6-120" tabindex="-1"></a></span>
<span id="cb6-121"><a href="#cb6-121" tabindex="-1"></a>            noise_loss <span class="op">=</span> <span class="va">self</span>.loss(noises, pred_noises)  <span class="co"># used for training</span></span>
<span id="cb6-122"><a href="#cb6-122" tabindex="-1"></a>            image_loss <span class="op">=</span> <span class="va">self</span>.loss(images, pred_images)  <span class="co"># only used as metric</span></span>
<span id="cb6-123"><a href="#cb6-123" tabindex="-1"></a></span>
<span id="cb6-124"><a href="#cb6-124" tabindex="-1"></a>        gradients <span class="op">=</span> tape.gradient(noise_loss, <span class="va">self</span>.network.trainable_weights)</span>
<span id="cb6-125"><a href="#cb6-125" tabindex="-1"></a>        <span class="va">self</span>.optimizer.apply_gradients(</span>
<span id="cb6-126"><a href="#cb6-126" tabindex="-1"></a>            <span class="bu">zip</span>(gradients, <span class="va">self</span>.network.trainable_weights)</span>
<span id="cb6-127"><a href="#cb6-127" tabindex="-1"></a>        )</span>
<span id="cb6-128"><a href="#cb6-128" tabindex="-1"></a></span>
<span id="cb6-129"><a href="#cb6-129" tabindex="-1"></a>        <span class="va">self</span>.noise_loss_tracker.update_state(noise_loss)</span>
<span id="cb6-130"><a href="#cb6-130" tabindex="-1"></a>        <span class="va">self</span>.image_loss_tracker.update_state(image_loss)</span>
<span id="cb6-131"><a href="#cb6-131" tabindex="-1"></a></span>
<span id="cb6-132"><a href="#cb6-132" tabindex="-1"></a>        <span class="co"># track the exponential moving averages of weights</span></span>
<span id="cb6-133"><a href="#cb6-133" tabindex="-1"></a>        <span class="cf">for</span> weight, ema_weight <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb6-134"><a href="#cb6-134" tabindex="-1"></a>            <span class="va">self</span>.network.weights, <span class="va">self</span>.ema_network.weights</span>
<span id="cb6-135"><a href="#cb6-135" tabindex="-1"></a>        ):</span>
<span id="cb6-136"><a href="#cb6-136" tabindex="-1"></a>            ema_weight.assign(ema <span class="op">*</span> ema_weight <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> ema) <span class="op">*</span> weight)</span>
<span id="cb6-137"><a href="#cb6-137" tabindex="-1"></a></span>
<span id="cb6-138"><a href="#cb6-138" tabindex="-1"></a>        <span class="co"># KID is not measured during the training phase for computational efficiency</span></span>
<span id="cb6-139"><a href="#cb6-139" tabindex="-1"></a>        <span class="cf">return</span> {m.name: m.result() <span class="cf">for</span> m <span class="kw">in</span> <span class="va">self</span>.metrics[:<span class="op">-</span><span class="dv">1</span>]}</span>
<span id="cb6-140"><a href="#cb6-140" tabindex="-1"></a></span>
<span id="cb6-141"><a href="#cb6-141" tabindex="-1"></a>    <span class="kw">def</span> test_step(<span class="va">self</span>, images):</span>
<span id="cb6-142"><a href="#cb6-142" tabindex="-1"></a>        <span class="co"># normalize images to have standard deviation of 1, like the noises</span></span>
<span id="cb6-143"><a href="#cb6-143" tabindex="-1"></a>        images <span class="op">=</span> <span class="va">self</span>.normalizer(images, training<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-144"><a href="#cb6-144" tabindex="-1"></a>        noises <span class="op">=</span> keras.random.normal(</span>
<span id="cb6-145"><a href="#cb6-145" tabindex="-1"></a>            shape<span class="op">=</span>(batch_size, image_size, image_size, <span class="dv">3</span>)</span>
<span id="cb6-146"><a href="#cb6-146" tabindex="-1"></a>        )</span>
<span id="cb6-147"><a href="#cb6-147" tabindex="-1"></a></span>
<span id="cb6-148"><a href="#cb6-148" tabindex="-1"></a>        <span class="co"># sample uniform random diffusion times</span></span>
<span id="cb6-149"><a href="#cb6-149" tabindex="-1"></a>        diffusion_times <span class="op">=</span> keras.random.uniform(</span>
<span id="cb6-150"><a href="#cb6-150" tabindex="-1"></a>            shape<span class="op">=</span>(batch_size, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb6-151"><a href="#cb6-151" tabindex="-1"></a>        )</span>
<span id="cb6-152"><a href="#cb6-152" tabindex="-1"></a>        noise_rates, signal_rates <span class="op">=</span> <span class="va">self</span>.diffusion_schedule(diffusion_times)</span>
<span id="cb6-153"><a href="#cb6-153" tabindex="-1"></a>        <span class="co"># mix the images with noises accordingly</span></span>
<span id="cb6-154"><a href="#cb6-154" tabindex="-1"></a>        noisy_images <span class="op">=</span> signal_rates <span class="op">*</span> images <span class="op">+</span> noise_rates <span class="op">*</span> noises</span>
<span id="cb6-155"><a href="#cb6-155" tabindex="-1"></a></span>
<span id="cb6-156"><a href="#cb6-156" tabindex="-1"></a>        <span class="co"># use the network to separate noisy images to their components</span></span>
<span id="cb6-157"><a href="#cb6-157" tabindex="-1"></a>        pred_noises, pred_images <span class="op">=</span> <span class="va">self</span>.denoise(</span>
<span id="cb6-158"><a href="#cb6-158" tabindex="-1"></a>            noisy_images, noise_rates, signal_rates, training<span class="op">=</span><span class="va">False</span></span>
<span id="cb6-159"><a href="#cb6-159" tabindex="-1"></a>        )</span>
<span id="cb6-160"><a href="#cb6-160" tabindex="-1"></a></span>
<span id="cb6-161"><a href="#cb6-161" tabindex="-1"></a>        noise_loss <span class="op">=</span> <span class="va">self</span>.loss(noises, pred_noises)</span>
<span id="cb6-162"><a href="#cb6-162" tabindex="-1"></a>        image_loss <span class="op">=</span> <span class="va">self</span>.loss(images, pred_images)</span>
<span id="cb6-163"><a href="#cb6-163" tabindex="-1"></a></span>
<span id="cb6-164"><a href="#cb6-164" tabindex="-1"></a>        <span class="va">self</span>.image_loss_tracker.update_state(image_loss)</span>
<span id="cb6-165"><a href="#cb6-165" tabindex="-1"></a>        <span class="va">self</span>.noise_loss_tracker.update_state(noise_loss)</span>
<span id="cb6-166"><a href="#cb6-166" tabindex="-1"></a></span>
<span id="cb6-167"><a href="#cb6-167" tabindex="-1"></a>        <span class="co"># measure KID between real and generated images</span></span>
<span id="cb6-168"><a href="#cb6-168" tabindex="-1"></a>        <span class="co"># this is computationally demanding, kid_diffusion_steps has to be small</span></span>
<span id="cb6-169"><a href="#cb6-169" tabindex="-1"></a>        images <span class="op">=</span> <span class="va">self</span>.denormalize(images)</span>
<span id="cb6-170"><a href="#cb6-170" tabindex="-1"></a>        generated_images <span class="op">=</span> <span class="va">self</span>.generate(</span>
<span id="cb6-171"><a href="#cb6-171" tabindex="-1"></a>            num_images<span class="op">=</span>batch_size, diffusion_steps<span class="op">=</span>kid_diffusion_steps</span>
<span id="cb6-172"><a href="#cb6-172" tabindex="-1"></a>        )</span>
<span id="cb6-173"><a href="#cb6-173" tabindex="-1"></a>        <span class="va">self</span>.kid.update_state(images, generated_images)</span>
<span id="cb6-174"><a href="#cb6-174" tabindex="-1"></a></span>
<span id="cb6-175"><a href="#cb6-175" tabindex="-1"></a>        <span class="cf">return</span> {m.name: m.result() <span class="cf">for</span> m <span class="kw">in</span> <span class="va">self</span>.metrics}</span>
<span id="cb6-176"><a href="#cb6-176" tabindex="-1"></a></span>
<span id="cb6-177"><a href="#cb6-177" tabindex="-1"></a>    <span class="kw">def</span> plot_images(<span class="va">self</span>, epoch<span class="op">=</span><span class="va">None</span>, logs<span class="op">=</span><span class="va">None</span>, num_rows<span class="op">=</span><span class="dv">3</span>, num_cols<span class="op">=</span><span class="dv">6</span>):</span>
<span id="cb6-178"><a href="#cb6-178" tabindex="-1"></a>        <span class="co"># plot random generated images for visual evaluation of generation quality</span></span>
<span id="cb6-179"><a href="#cb6-179" tabindex="-1"></a>        generated_images <span class="op">=</span> <span class="va">self</span>.generate(</span>
<span id="cb6-180"><a href="#cb6-180" tabindex="-1"></a>            num_images<span class="op">=</span>num_rows <span class="op">*</span> num_cols,</span>
<span id="cb6-181"><a href="#cb6-181" tabindex="-1"></a>            diffusion_steps<span class="op">=</span>plot_diffusion_steps,</span>
<span id="cb6-182"><a href="#cb6-182" tabindex="-1"></a>        )</span>
<span id="cb6-183"><a href="#cb6-183" tabindex="-1"></a></span>
<span id="cb6-184"><a href="#cb6-184" tabindex="-1"></a>        plt.figure(figsize<span class="op">=</span>(num_cols <span class="op">*</span> <span class="fl">2.0</span>, num_rows <span class="op">*</span> <span class="fl">2.0</span>))</span>
<span id="cb6-185"><a href="#cb6-185" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(num_rows):</span>
<span id="cb6-186"><a href="#cb6-186" tabindex="-1"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(num_cols):</span>
<span id="cb6-187"><a href="#cb6-187" tabindex="-1"></a>                index <span class="op">=</span> row <span class="op">*</span> num_cols <span class="op">+</span> col</span>
<span id="cb6-188"><a href="#cb6-188" tabindex="-1"></a>                plt.subplot(num_rows, num_cols, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-189"><a href="#cb6-189" tabindex="-1"></a>                plt.imshow(generated_images[index])</span>
<span id="cb6-190"><a href="#cb6-190" tabindex="-1"></a>                plt.axis(<span class="st">"off"</span>)</span>
<span id="cb6-191"><a href="#cb6-191" tabindex="-1"></a>        plt.tight_layout()</span>
<span id="cb6-192"><a href="#cb6-192" tabindex="-1"></a>        plt.show()</span>
<span id="cb6-193"><a href="#cb6-193" tabindex="-1"></a>        plt.close()</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="training">Training<a class="anchor" aria-label="anchor" href="#training"></a>
</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># create and compile the model</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>model <span class="op">=</span> DiffusionModel(image_size, widths, block_depth)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co"># below tensorflow 2.9:</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co"># pip install tensorflow_addons</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co"># import tensorflow_addons as tfa</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co"># optimizer=tfa.optimizers.AdamW</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>    optimizer<span class="op">=</span>keras.optimizers.AdamW(</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>        learning_rate<span class="op">=</span>learning_rate, weight_decay<span class="op">=</span>weight_decay</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>    ),</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>    loss<span class="op">=</span>keras.losses.mean_absolute_error,</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>)</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co"># pixelwise mean absolute error is used as loss</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co"># save the best model based on the validation KID metric</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>checkpoint_path <span class="op">=</span> <span class="st">"checkpoints/diffusion_model.weights.h5"</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>checkpoint_callback <span class="op">=</span> keras.callbacks.ModelCheckpoint(</span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    filepath<span class="op">=</span>checkpoint_path,</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>    save_weights_only<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>    monitor<span class="op">=</span><span class="st">"val_kid"</span>,</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"min"</span>,</span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>    save_best_only<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>)</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co"># calculate mean and variance of training dataset for normalization</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>model.normalizer.adapt(train_dataset)</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a><span class="co"># run training and plot generated images periodically</span></span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a>model.fit(</span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>    train_dataset,</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>    epochs<span class="op">=</span>num_epochs,</span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>    validation_data<span class="op">=</span>val_dataset,</span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a>    callbacks<span class="op">=</span>[</span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a>        keras.callbacks.LambdaCallback(on_epoch_end<span class="op">=</span>model.plot_images),</span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>        checkpoint_callback,</span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a>    ],</span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="inference">Inference<a class="anchor" aria-label="anchor" href="#inference"></a>
</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># load the best model and generate images</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>model.load_weights(checkpoint_path)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>model.plot_images()</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="results">Results<a class="anchor" aria-label="anchor" href="#results"></a>
</h2>
<p>By running the training for at least 50 epochs (takes 2 hours on a T4
GPU and 30 minutes on an A100 GPU), one can get high quality image
generations using this code example.</p>
<p>The evolution of a batch of images over a 80 epoch training (color
artifacts are due to GIF compression):</p>
<div class="float">
<img src="https://i.imgur.com/FSCKtZq.gif" alt="flowers training gif"><div class="figcaption">flowers training gif</div>
</div>
<p>Images generated using between 1 and 20 sampling steps from the same
initial noise:</p>
<div class="float">
<img src="https://i.imgur.com/tM5LyH3.gif" alt="flowers sampling steps gif"><div class="figcaption">flowers sampling steps gif</div>
</div>
<p>Interpolation (spherical) between initial noise samples:</p>
<div class="float">
<img src="https://i.imgur.com/hk5Hd5o.gif" alt="flowers interpolation gif"><div class="figcaption">flowers interpolation gif</div>
</div>
<p>Deterministic sampling process (noisy images on top, predicted images
on bottom, 40 steps):</p>
<div class="float">
<img src="https://i.imgur.com/wCvzynh.gif" alt="flowers deterministic generation gif"><div class="figcaption">flowers deterministic generation gif</div>
</div>
<p>Stochastic sampling process (noisy images on top, predicted images on
bottom, 80 steps):</p>
<div class="float">
<img src="https://i.imgur.com/kRXOGzd.gif" alt="flowers stochastic generation gif"><div class="figcaption">flowers stochastic generation gif</div>
</div>
<p>Trained model and demo available on HuggingFace:</p>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th align="center">Trained Model</th>
<th align="center">Demo</th>
</tr></thead>
<tbody><tr class="odd">
<td align="center"><a href="https://huggingface.co/keras-io/denoising-diffusion-implicit-models" class="external-link"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Model-DDIM-black.svg" alt="model badge"></a></td>
<td align="center"><a href="https://huggingface.co/spaces/keras-io/denoising-diffusion-implicit-models" class="external-link"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Spaces-DDIM-black.svg" alt="spaces badge"></a></td>
</tr></tbody>
</table>
</div>
<div class="section level2">
<h2 id="lessons-learned">Lessons learned<a class="anchor" aria-label="anchor" href="#lessons-learned"></a>
</h2>
<p>During preparation for this code example I have run numerous
experiments using <a href="https://github.com/beresandras/clear-diffusion-keras" class="external-link">this
repository</a>. In this section I list the lessons learned and my
recommendations in my subjective order of importance.</p>
<div class="section level3">
<h3 id="algorithmic-tips">Algorithmic tips<a class="anchor" aria-label="anchor" href="#algorithmic-tips"></a>
</h3>
<ul>
<li>
<strong>min. and max. signal rates</strong>: I found the min. signal
rate to be an important hyperparameter. Setting it too low will make the
generated images oversaturated, while setting it too high will make them
undersaturated. I recommend tuning it carefully. Also, setting it to 0
will lead to a division by zero error. The max. signal rate can be set
to 1, but I found that setting it lower slightly improves generation
quality.</li>
<li>
<strong>loss function</strong>: While large models tend to use mean
squared error (MSE) loss, I recommend using mean absolute error (MAE) on
this dataset. In my experience MSE loss generates more diverse samples
(it also seems to hallucinate more <a href="https://arxiv.org/abs/2111.05826" class="external-link">Section 3</a>), while MAE loss
leads to smoother images. I recommend trying both.</li>
<li>
<strong>weight decay</strong>: I did occasionally run into diverged
trainings when scaling up the model, and found that weight decay helps
in avoiding instabilities at a low performance cost. This is why I use
<a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers/experimental/AdamW" class="external-link">AdamW</a>
instead of <a href="https://keras.io/api/optimizers/adam/" class="external-link">Adam</a> in
this example.</li>
<li>
<strong>exponential moving average of weights</strong>: This helps
to reduce the variance of the KID metric, and helps in averaging out
short-term changes during training.</li>
<li>
<strong>image augmentations</strong>: Though I did not use image
augmentations in this example, in my experience adding horizontal flips
to the training increases generation performance, while random crops do
not. Since we use a supervised denoising loss, overfitting can be an
issue, so image augmentations might be important on small datasets. One
should also be careful not to use <a href="https://keras.io/examples/generative/gan_ada/#invertible-data-augmentation" class="external-link">leaky
augmentations</a>, which can be done following <a href="https://arxiv.org/abs/2206.00364" class="external-link">this method (end of Section
5)</a> for instance.</li>
<li>
<strong>data normalization</strong>: In the literature the pixel
values of images are usually converted to the -1 to 1 range. For
theoretical correctness, I normalize the images to have zero mean and
unit variance instead, exactly like the random noises.</li>
<li>
<strong>noise level input</strong>: I chose to input the noise
variance to the network, as it is symmetrical under our sampling
schedule. One could also input the noise rate (similar performance), the
signal rate (lower performance), or even the <a href="https://arxiv.org/abs/2107.00630" class="external-link">log-signal-to-noise ratio
(Appendix B.1)</a> (did not try, as its range is highly dependent on the
min. and max. signal rates, and would require adjusting the min.
embedding frequency accordingly).</li>
<li>
<strong>gradient clipping</strong>: Using global gradient clipping
with a value of 1 can help with training stability for large models, but
decreased performance significantly in my experience.</li>
<li>
<strong>residual connection downscaling</strong>: For <a href="https://arxiv.org/abs/2205.11487" class="external-link">deeper models (Appendix B)</a>,
scaling the residual connections with 1/sqrt(2) can be helpful, but did
not help in my case.</li>
<li>
<strong>learning rate</strong>: For me, <a href="https://keras.io/api/optimizers/adam/" class="external-link">Adam optimizer’s</a>
default learning rate of 1e-3 worked very well, but lower learning rates
are more common in the <a href="https://arxiv.org/abs/2105.05233" class="external-link">literature (Tables
11-13)</a>.</li>
</ul>
</div>
<div class="section level3">
<h3 id="architectural-tips">Architectural tips<a class="anchor" aria-label="anchor" href="#architectural-tips"></a>
</h3>
<ul>
<li>
<strong>sinusoidal embedding</strong>: Using sinusoidal embeddings
on the noise level input of the network is crucial for good performance.
I recommend setting the min. embedding frequency to the reciprocal of
the range of this input, and since we use the noise variance in this
example, it can be left always at 1. The max. embedding frequency
controls the smallest change in the noise variance that the network will
be sensitive to, and the embedding dimensions set the number of
frequency components in the embedding. In my experience the performance
is not too sensitive to these values.</li>
<li>
<strong>skip connections</strong>: Using skip connections in the
network architecture is absolutely critical, without them the model will
fail to learn to denoise at a good performance.</li>
<li>
<strong>residual connections</strong>: In my experience residual
connections also significantly improve performance, but this might be
due to the fact that we only input the noise level embeddings to the
first layer of the network instead of to all of them.</li>
<li>
<strong>normalization</strong>: When scaling up the model, I did
occasionally encounter diverged trainings, using normalization layers
helped to mitigate this issue. In the literature it is common to use <a href="https://www.tensorflow.org/addons/api_docs/python/tfa/layers/GroupNormalization" class="external-link">GroupNormalization</a>
(with 8 groups for example) or <a href="https://keras.io/api/layers/normalization_layers/layer_normalization/" class="external-link">LayerNormalization</a>
in the network, I however chose to use <a href="https://keras.io/api/layers/normalization_layers/batch_normalization/" class="external-link">BatchNormalization</a>,
as it gave similar benefits in my experiments but was computationally
lighter.</li>
<li>
<strong>activations</strong>: The choice of activation functions had
a larger effect on generation quality than I expected. In my experiments
using non-monotonic activation functions outperformed monotonic ones
(such as <a href="https://www.tensorflow.org/api_docs/python/tf/keras/activations/relu" class="external-link">ReLU</a>),
with <a href="https://www.tensorflow.org/api_docs/python/tf/keras/activations/swish" class="external-link">Swish</a>
performing the best (this is also what <a href="https://arxiv.org/abs/2205.11487" class="external-link">Imagen uses, page 41</a>).</li>
<li>
<strong>attention</strong>: As mentioned earlier, it is common in
the literature to use <a href="https://keras.io/api/layers/attention_layers/multi_head_attention/" class="external-link">attention
layers</a> at low resolutions for better global coherence. I omitted
them for simplicity.</li>
<li>
<strong>upsampling</strong>: <a href="https://keras.io/api/layers/reshaping_layers/up_sampling2d/" class="external-link">Bilinear
and nearest neighbour upsampling</a> in the network performed similarly,
however I did not try <a href="https://keras.io/api/layers/convolution_layers/convolution2d_transpose/" class="external-link">transposed
convolutions</a>.</li>
</ul>
<p>For a similar list about GANs check out <a href="https://keras.io/examples/generative/gan_ada/#gan-tips-and-tricks" class="external-link">this
Keras tutorial</a>.</p>
</div>
</div>
<div class="section level2">
<h2 id="what-to-try-next">What to try next?<a class="anchor" aria-label="anchor" href="#what-to-try-next"></a>
</h2>
<p>If you would like to dive in deeper to the topic, I recommend
checking out <a href="https://github.com/beresandras/clear-diffusion-keras" class="external-link">this
repository</a> that I created in preparation for this code example,
which implements a wider range of features in a similar style, such
as:</p>
<ul>
<li>stochastic sampling</li>
<li>second-order sampling based on the <a href="https://arxiv.org/abs/2010.02502" class="external-link">differential equation view of
DDIMs (Equation 13)</a>
</li>
<li>more diffusion schedules</li>
<li>more network output types: predicting image or <a href="https://arxiv.org/abs/2202.00512" class="external-link">velocity (Appendix D)</a>
instead of noise</li>
<li>more datasets</li>
</ul>
</div>
<div class="section level2">
<h2 id="related-works">Related works<a class="anchor" aria-label="anchor" href="#related-works"></a>
</h2>
<ul>
<li>
<a href="https://yang-song.github.io/blog/2021/score/" class="external-link">Score-based
generative modeling</a> (blogpost)</li>
<li>
<a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/" class="external-link">What
are diffusion models?</a> (blogpost)</li>
<li>
<a href="https://huggingface.co/blog/annotated-diffusion" class="external-link">Annotated
diffusion model</a> (blogpost)</li>
<li>
<a href="https://cvpr2022-tutorial-diffusion-models.github.io/" class="external-link">CVPR
2022 tutorial on diffusion models</a> (slides available)</li>
<li>
<a href="https://arxiv.org/abs/2206.00364" class="external-link">Elucidating the Design
Space of Diffusion-Based Generative Models</a>: attempts unifying
diffusion methods under a common framework</li>
<li>High-level video overviews: <a href="https://www.youtube.com/watch?v=yTAMrHVG1ew" class="external-link">1</a>, <a href="https://www.youtube.com/watch?v=344w5h24-h8" class="external-link">2</a>
</li>
<li>Detailed technical videos: <a href="https://www.youtube.com/watch?v=fbLgFrlTnGU" class="external-link">1</a>, <a href="https://www.youtube.com/watch?v=W-O7AZNzbzQ" class="external-link">2</a>
</li>
<li>Score-based generative models: <a href="https://arxiv.org/abs/1907.05600" class="external-link">NCSN</a>, <a href="https://arxiv.org/abs/2006.09011" class="external-link">NCSN+</a>, <a href="https://arxiv.org/abs/2011.13456" class="external-link">NCSN++</a>
</li>
<li>Denoising diffusion models: <a href="https://arxiv.org/abs/2006.11239" class="external-link">DDPM</a>, <a href="https://arxiv.org/abs/2010.02502" class="external-link">DDIM</a>, <a href="https://arxiv.org/abs/2102.09672" class="external-link">DDPM+</a>, <a href="https://arxiv.org/abs/2105.05233" class="external-link">DDPM++</a>
</li>
<li>Large diffusion models: <a href="https://arxiv.org/abs/2112.10741" class="external-link">GLIDE</a>, <a href="https://arxiv.org/abs/2204.06125/" class="external-link">DALL-E 2</a>, <a href="https://arxiv.org/abs/2205.11487" class="external-link">Imagen</a>
</li>
</ul>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Tomasz Kalinowski, JJ Allaire, François Chollet, RStudio, Google.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
