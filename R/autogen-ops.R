## Autogenerated. Do not modify manually.


# keras$ops$cast
# keras.ops.cast
# keras.src.ops.core.cast
r"-(Cast a tensor to the desired dtype.

    Args:
        x: A tensor or variable.
        dtype: The target type.

    Returns:
        A tensor of the specified `dtype`.

    Example:

    >>> x = keras.ops.arange(4)
    >>> x = keras.ops.cast(x, dtype="float16")
    )-"

# keras.src.ops.core.cast
#' Cast a tensor to the desired dtype.
#'
#' @description
#'
#' # Returns
#' A tensor of the specified `dtype`.
#'
#' # Examples
#' ```python
#' x = keras.ops.arange(4)
#' x = keras.ops.cast(x, dtype="float16")
#' ```
#'
#' @param x A tensor or variable.
#' @param dtype The target type.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cast>
k_cast <-
function (x, dtype)
keras$ops$cast(x, dtype)


# keras$ops$cond
# keras.ops.cond
# keras.src.ops.core.cond
r"-(Conditionally applies `true_fn` or `false_fn`.

    Args:
        pred: Boolean scalar type
        true_fn: Callable returning the output for the `pred == True` case.
        false_fn: Callable returning the output for the `pred == False` case.

    Returns:
        The output of either `true_fn` or `false_fn` depending on pred.
    )-"

# keras.src.ops.core.cond
#' Conditionally applies `true_fn` or `false_fn`.
#'
#' @description
#'
#' # Returns
#'     The output of either `true_fn` or `false_fn` depending on pred.
#'
#' @param pred Boolean scalar type
#' @param true_fn Callable returning the output for the `pred == True` case.
#' @param false_fn Callable returning the output for the `pred == False` case.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cond>
k_cond <-
function (pred, true_fn, false_fn)
keras$ops$cond(pred, true_fn, false_fn)


# keras$ops$convert_to_numpy
# keras.ops.convert_to_numpy
# keras.src.ops.core.convert_to_numpy
r"-(Convert a tensor to a NumPy array.

    Args:
        x: A tensor.

    Returns:
        A NumPy array.
    )-"

# keras.src.ops.core.convert_to_numpy
#' Convert a tensor to a NumPy array.
#'
#' @description
#'
#' # Returns
#'     A NumPy array.
#'
#' @param x A tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/convert_to_numpy>
k_convert_to_numpy <-
function (x)
keras$ops$convert_to_numpy(x)


# keras$ops$convert_to_tensor
# keras.ops.convert_to_tensor
# keras.src.ops.core.convert_to_tensor
r"-(Convert a NumPy array to a tensor.

    Args:
        x: A NumPy array.
        dtype: The target type.

    Returns:
        A tensor of the specified `dtype`.

    Example:

    >>> x = np.array([1, 2, 3])
    >>> y = keras.ops.convert_to_tensor(x)
    )-"

# keras.src.ops.core.convert_to_tensor
#' Convert a NumPy array to a tensor.
#'
#' @description
#'
#' # Returns
#' A tensor of the specified `dtype`.
#'
#' # Examples
#' ```python
#' x = np.array([1, 2, 3])
#' y = keras.ops.convert_to_tensor(x)
#' ```
#'
#' @param x A NumPy array.
#' @param dtype The target type.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/convert_to_tensor>
k_convert_to_tensor <-
function (x, dtype = NULL)
keras$ops$convert_to_tensor(x, dtype)


# keras$ops$fori_loop
# keras.ops.fori_loop
# keras.src.ops.core.fori_loop
r"-(For loop implementation.

    Args:
        lower: The initial value of the loop variable.
        upper: The upper bound of the loop variable.
        body_fun: A callable that represents the loop body. Must take two
            arguments: the loop variable and the loop state. The loop state
            should be updated and returned by this function.
        init_val: The initial value of the loop state.

    Returns:
        The final state after the loop.

    Example:

    >>> lower = 0
    >>> upper = 10
    >>> body_fun = lambda i, s: (i + 1, s + i)
    >>> init_val = 0
    >>> keras.ops.fori_loop(lower, upper, body_fun, init_val)
    45
    )-"

# keras.src.ops.core.fori_loop
#' For loop implementation.
#'
#' @description
#'
#' # Returns
#' The final state after the loop.
#'
#' # Examples
#' ```python
#' lower = 0
#' upper = 10
#' body_fun = lambda i, s: (i + 1, s + i)
#' init_val = 0
#' keras.ops.fori_loop(lower, upper, body_fun, init_val)
#' # 45
#' ```
#'
#' @param lower The initial value of the loop variable.
#' @param upper The upper bound of the loop variable.
#' @param body_fun A callable that represents the loop body. Must take two
#'     arguments: the loop variable and the loop state. The loop state
#'     should be updated and returned by this function.
#' @param init_val The initial value of the loop state.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/fori_loop>
k_fori_loop <-
function (lower, upper, body_fun, init_val)
keras$ops$fori_loop(lower, upper, body_fun, init_val)


# keras$ops$scatter
# keras.ops.scatter
# keras.src.ops.core.scatter
r"-(Returns a tensor of shape `shape` where `indices` are set to `values`.

    At a high level, this operation does `zeros[indices] = updates` and
    returns the output. It is equivalent to:

    ```python
    zeros = keras.ops.zeros(shape)
    output = keras.ops.scatter_update(zeros, indices, values)
    ```

    Args:
        indices: A tensor or list/tuple specifying
            indices for the values in `values`.
        updates: A tensor, the values to be set at `indices`.
        shape: Shape of the output tensor.

    Example:

    >>> indices = [[0, 1], [1, 1]]
    >>> values = np.array([1., 1.])
    >>> keras.ops.scatter(indices, values, shape=(2, 2))
    array([[0., 1.],
           [0., 1.]])
    )-"

# keras.src.ops.core.scatter
#' Returns a tensor of shape `shape` where `indices` are set to `values`.
#'
#' @description
#' At a high level, this operation does `zeros[indices] = updates` and
#' returns the output. It is equivalent to:
#'
#' ```python
#' zeros = keras.ops.zeros(shape)
#' output = keras.ops.scatter_update(zeros, indices, values)
#' ```
#'
#' # Examples
#' ```python
#' indices = [[0, 1], [1, 1]]
#' values = np.array([1., 1.])
#' keras.ops.scatter(indices, values, shape=(2, 2))
#' # array([[0., 1.],
#' #        [0., 1.]])
#' ```
#'
#' @param indices A tensor or list/tuple specifying
#'     indices for the values in `values`.
#' @param values A tensor, the values to be set at `indices`.
#' @param shape Shape of the output tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/scatter>
k_scatter <-
function (indices, values, shape)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$scatter, args)
}


# keras$ops$scatter_update
# keras.ops.scatter_update
# keras.src.ops.core.scatter_update
r"-(Update inputs via updates at scattered (sparse) indices.

    At a high level, this operation does `inputs[indices] = updates`.
    Assume `inputs` is a tensor of shape `(D0, D1, ..., Dn)`, there are 2 main
    usages of `scatter_update`.

    1. `indices` is a 2D tensor of shape `(num_updates, n)`, where `num_updates`
        is the number of updates to perform, and `updates` is a 1D tensor of
        shape `(num_updates,)`. For example, if `inputs` is `zeros((4, 4, 4))`,
        and we want to update `inputs[1, 2, 3]` and `inputs[0, 1, 3]` as 1, then
        we can use:

    ```python
    inputs = np.zeros((4, 4, 4))
    indices = [[1, 2, 3], [0, 1, 3]]
    updates = np.array([1., 1.])
    inputs = keras.ops.scatter_update(inputs, indices, updates)
    ```

    2 `indices` is a 2D tensor of shape `(num_updates, k)`, where `num_updates`
        is the number of updates to perform, and `k` (`k < n`) is the size of
        each index in `indices`. `updates` is a `n - k`-D tensor of shape
        `(num_updates, inputs.shape[k:])`. For example, if
        `inputs = np.zeros((4, 4, 4))`, and we want to update `inputs[1, 2, :]`
        and `inputs[2, 3, :]` as `[1, 1, 1, 1]`, then `indices` would have shape
        `(num_updates, 2)` (`k = 2`), and `updates` would have shape
        `(num_updates, 4)` (`inputs.shape[2:] = 4`). See the code below:

    ```python
    inputs = np.zeros((4, 4, 4))
    indices = [[1, 2], [2, 3]]
    updates = np.array([[1., 1., 1, 1,], [1., 1., 1, 1,])
    inputs = keras.ops.scatter_update(inputs, indices, updates)
    ```

    Args:
        inputs: A tensor, the tensor to be updated.
        indices: A tensor or list/tuple of shape `(N, inputs.ndim)`, specifying
            indices to update. `N` is the number of indices to update, must be
            equal to the first dimension of `updates`.
        updates: A tensor, the new values to be put to `inputs` at `indices`.

    Returns:
        A tensor, has the same shape and dtype as `inputs`.
    )-"

# keras.src.ops.core.scatter_update
#' Update inputs via updates at scattered (sparse) indices.
#'
#' @description
#' At a high level, this operation does `inputs[indices] = updates`.
#' Assume `inputs` is a tensor of shape `(D0, D1, ..., Dn)`, there are 2 main
#' usages of `scatter_update`.
#'
#' 1. `indices` is a 2D tensor of shape `(num_updates, n)`, where `num_updates`
#'     is the number of updates to perform, and `updates` is a 1D tensor of
#'     shape `(num_updates,)`. For example, if `inputs` is `zeros((4, 4, 4))`,
#'     and we want to update `inputs[1, 2, 3]` and `inputs[0, 1, 3]` as 1, then
#'     we can use:
#'
#' ```python
#' inputs = np.zeros((4, 4, 4))
#' indices = [[1, 2, 3], [0, 1, 3]]
#' updates = np.array([1., 1.])
#' inputs = keras.ops.scatter_update(inputs, indices, updates)
#' ```
#'
#' 2 `indices` is a 2D tensor of shape `(num_updates, k)`, where `num_updates`
#'     is the number of updates to perform, and `k` (`k < n`) is the size of
#'     each index in `indices`. `updates` is a `n - k`-D tensor of shape
#'     `(num_updates, inputs.shape[k:])`. For example, if
#'     `inputs = np.zeros((4, 4, 4))`, and we want to update `inputs[1, 2, :]`
#'     and `inputs[2, 3, :]` as `[1, 1, 1, 1]`, then `indices` would have shape
#'     `(num_updates, 2)` (`k = 2`), and `updates` would have shape
#'     `(num_updates, 4)` (`inputs.shape[2:] = 4`). See the code below:
#'
#' ```python
#' inputs = np.zeros((4, 4, 4))
#' indices = [[1, 2], [2, 3]]
#' updates = np.array([[1., 1., 1, 1,], [1., 1., 1, 1,])
#' inputs = keras.ops.scatter_update(inputs, indices, updates)
#' ```
#'
#' # Returns
#'     A tensor, has the same shape and dtype as `inputs`.
#'
#' @param inputs A tensor, the tensor to be updated.
#' @param indices A tensor or list/tuple of shape `(N, inputs.ndim)`, specifying
#'     indices to update. `N` is the number of indices to update, must be
#'     equal to the first dimension of `updates`.
#' @param updates A tensor, the new values to be put to `inputs` at `indices`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/scatter_update>
k_scatter_update <-
function (inputs, indices, updates)
keras$ops$scatter_update(inputs, indices, updates)


# keras$ops$shape
# keras.ops.shape
# keras.src.ops.core.shape
r"-(Gets the shape of the tensor input.

    Note: On the tensorflow backend, when `x` is a `tf.Tensor` with dynamic
    shape, dimensions which are dynamic in the context of a compiled function
    will have a `tf.Tensor` value instead of a static integer value.

    Args:
        x: A tensor. This function will try to access the `shape` attribute of
            the input tensor.

    Returns:
        A tuple of integers or None values, indicating the shape of the input
            tensor.

    Example:

    >>> x = keras.zeros((8, 12))
    >>> keras.ops.shape(x)
    (8, 12)
    )-"

# keras.src.ops.core.shape
#' Gets the shape of the tensor input.
#'
#' @description
#'
#' # Note
#' On the tensorflow backend, when `x` is a `tf.Tensor` with dynamic
#' shape, dimensions which are dynamic in the context of a compiled function
#' will have a `tf.Tensor` value instead of a static integer value.
#'
#' # Returns
#' A tuple of integers or None values, indicating the shape of the input
#' tensor.
#'
#' # Examples
#' ```python
#' x = keras.zeros((8, 12))
#' keras.ops.shape(x)
#' # (8, 12)
#' ```
#'
#' @param x A tensor. This function will try to access the `shape` attribute of
#' the input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/shape>
k_shape <-
function (x)
keras$ops$shape(x)


# keras$ops$slice
# keras.ops.slice
# keras.src.ops.core.slice
r"-(Return a slice of an input tensor.

    At a high level, this operation is an explicit replacement for array slicing
    e.g. `inputs[start_indices: start_indices + shape]`.
    Unlike slicing via brackets, this operation will accept tensor start
    indices on all backends, which is useful when indices dynamically computed
    via other tensor operations.

    ```python
    inputs = np.zeros((5, 5))
    start_indices = np.array([3, 3])
    shape = np.array([2, 2])
    inputs = keras.ops.slice(inputs, start_indices, updates)
    ```

    Args:
        inputs: A tensor, the tensor to be updated.
        start_indices: A list/tuple of shape `(inputs.ndim,)`, specifying
            the starting indices for updating.
        shape: The full shape of the returned slice.

    Returns:
        A tensor, has the same shape and dtype as `inputs`.
    )-"

# keras.src.ops.core.slice
#' Return a slice of an input tensor.
#'
#' @description
#' At a high level, this operation is an explicit replacement for array slicing
#' e.g. `inputs[start_indices: start_indices + shape]`.
#' Unlike slicing via brackets, this operation will accept tensor start
#' indices on all backends, which is useful when indices dynamically computed
#' via other tensor operations.
#'
#' ```python
#' inputs = np.zeros((5, 5))
#' start_indices = np.array([3, 3])
#' shape = np.array([2, 2])
#' inputs = keras.ops.slice(inputs, start_indices, updates)
#' ```
#'
#' # Returns
#'     A tensor, has the same shape and dtype as `inputs`.
#'
#' @param inputs A tensor, the tensor to be updated.
#' @param start_indices A list/tuple of shape `(inputs.ndim,)`, specifying
#'     the starting indices for updating.
#' @param shape The full shape of the returned slice.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/slice>
k_slice <-
function (inputs, start_indices, shape)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$slice, args)
}


# keras$ops$slice_update
# keras.ops.slice_update
# keras.src.ops.core.slice_update
r"-(Update an input by slicing in a tensor of updated values.

    At a high level, this operation does
    `inputs[start_indices: start_indices + updates.shape] = updates`.
    Assume inputs is a tensor of shape `(D0, D1, ..., Dn)`,
    `start_indices` must be a list/tuple of n integers, specifying the starting
    indices. `updates` must have the same rank as `inputs`, and the size of each
    dim must not exceed `Di - start_indices[i]`. For example, if we have 2D
    inputs `inputs = np.zeros((5, 5))`, and we want to update the intersection
    of last 2 rows and last 2 columns as 1, i.e.,
    `inputs[3:, 3:] = np.ones((2, 2))`, then we can use the code below:

    ```python
    inputs = np.zeros((5, 5))
    start_indices = [3, 3]
    updates = np.ones((2, 2))
    inputs = keras.ops.slice_update(inputs, start_indices, updates)
    ```

    Args:
        inputs: A tensor, the tensor to be updated.
        start_indices: A list/tuple of shape `(inputs.ndim,)`, specifying
            the starting indices for updating.
        updates: A tensor, the new values to be put to `inputs` at `indices`.
            `updates` must have the same rank as `inputs`.

    Returns:
        A tensor, has the same shape and dtype as `inputs`.
    )-"

# keras.src.ops.core.slice_update
#' Update an input by slicing in a tensor of updated values.
#'
#' @description
#' At a high level, this operation does
#' `inputs[start_indices: start_indices + updates.shape] = updates`.
#' Assume inputs is a tensor of shape `(D0, D1, ..., Dn)`,
#' `start_indices` must be a list/tuple of n integers, specifying the starting
#' indices. `updates` must have the same rank as `inputs`, and the size of each
#' dim must not exceed `Di - start_indices[i]`. For example, if we have 2D
#' inputs `inputs = np.zeros((5, 5))`, and we want to update the intersection
#' of last 2 rows and last 2 columns as 1, i.e.,
#' `inputs[3:, 3:] = np.ones((2, 2))`, then we can use the code below:
#'
#' ```python
#' inputs = np.zeros((5, 5))
#' start_indices = [3, 3]
#' updates = np.ones((2, 2))
#' inputs = keras.ops.slice_update(inputs, start_indices, updates)
#' ```
#'
#' # Returns
#'     A tensor, has the same shape and dtype as `inputs`.
#'
#' @param inputs A tensor, the tensor to be updated.
#' @param start_indices A list/tuple of shape `(inputs.ndim,)`, specifying
#'     the starting indices for updating.
#' @param updates A tensor, the new values to be put to `inputs` at `indices`.
#'     `updates` must have the same rank as `inputs`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/slice_update>
k_slice_update <-
function (inputs, start_indices, updates)
keras$ops$slice_update(inputs, start_indices, updates)


# keras$ops$stop_gradient
# keras.ops.stop_gradient
# keras.src.ops.core.stop_gradient
r"-(Stops gradient computation.

    Args:
        variable: A tensor variable for which the gradient
            computation is to be disabled.

    Returns:
        The variable with gradient computation disabled.

    Examples:

    >>> var = keras.backend.convert_to_tensor(
    ...     [1., 2., 3.],
    ...     dtype="float32"
    ... )
    >>> var = keras.ops.stop_gradient(var)
    )-"

# keras.src.ops.core.stop_gradient
#' Stops gradient computation.
#'
#' @description
#'
#' # Returns
#' The variable with gradient computation disabled.
#'
#' # Examples
#' ```python
#' var = keras.backend.convert_to_tensor(
#'     [1., 2., 3.],
#'     dtype="float32"
#' )
#' var = keras.ops.stop_gradient(var)
#' ```
#'
#' @param variable A tensor variable for which the gradient
#' computation is to be disabled.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/stop_gradient>
k_stop_gradient <-
function (variable)
keras$ops$stop_gradient(variable)


# keras$ops$unstack
# keras.ops.unstack
# keras.src.ops.core.unstack
r"-(Unpacks the given dimension of a rank-R tensor into rank-(R-1) tensors.

    Args:
        x: The input tensor.
        num: The length of the dimension axis. Automatically inferred
            if `None`.
        axis: The axis along which to unpack.

    Returns:
        A list of tensors unpacked along the given axis.

    Example:

    >>> x = keras.ops.array([[1, 2], [3, 4]])
    >>> keras.ops.unstack(x, axis=0)
    [array([1, 2]), array([3, 4])]
    )-"

# keras.src.ops.core.unstack
#' Unpacks the given dimension of a rank-R tensor into rank-(R-1) tensors.
#'
#' @description
#'
#' # Returns
#' A list of tensors unpacked along the given axis.
#'
#' # Examples
#' ```python
#' x = keras.ops.array([[1, 2], [3, 4]])
#' keras.ops.unstack(x, axis=0)
#' # [array([1, 2]), array([3, 4])]
#' ```
#'
#' @param x The input tensor.
#' @param num The length of the dimension axis. Automatically inferred
#'     if `None`.
#' @param axis The axis along which to unpack.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/unstack>
k_unstack <-
function (x, num = NULL, axis = 0L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$unstack, args)
}


# keras$ops$while_loop
# keras.ops.while_loop
# keras.src.ops.core.while_loop
r"-(While loop implementation.

    Args:
        cond: A callable that represents the termination condition of the loop.
            Must have the same number of args as `loop_vars`, and return a bool.
        body: A callable that represents the loop body. Must have the same
            number of args as `loop_vars`, and return a list/tuple of the same
            length, shape and dtype as `loop_vars`.
        loop_vars: A list/tuple of tensors, the loop variables.
        maximum_iterations: Optional maximum number of iterations of the while
            loop to run. If provided, the `cond` output is AND-ed with an
            additional condition ensuring the number of iterations executed is
            no greater than `maximum_iterations`.

    Returns:
        A list/tuple of tensors, has the same shape and dtype as `inputs`.

    Examples:

    >>> i = 0
    >>> cond = lambda i: i < 10
    >>> body = lambda i: i + 1
    >>> keras.ops.while_loop(cond, body, [i])[0]
    10
    )-"

# keras.src.ops.core.while_loop
#' While loop implementation.
#'
#' @description
#'
#' # Returns
#' A list/tuple of tensors, has the same shape and dtype as `inputs`.
#'
#' # Examples
#' ```python
#' i = 0
#' cond = lambda i: i < 10
#' body = lambda i: i + 1
#' keras.ops.while_loop(cond, body, [i])[0]
#' # 10
#' ```
#'
#' @param cond A callable that represents the termination condition of the loop.
#'     Must have the same number of args as `loop_vars`, and return a bool.
#' @param body A callable that represents the loop body. Must have the same
#'     number of args as `loop_vars`, and return a list/tuple of the same
#'     length, shape and dtype as `loop_vars`.
#' @param loop_vars A list/tuple of tensors, the loop variables.
#' @param maximum_iterations Optional maximum number of iterations of the while
#'     loop to run. If provided, the `cond` output is AND-ed with an
#'     additional condition ensuring the number of iterations executed is
#'     no greater than `maximum_iterations`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/while_loop>
k_while_loop <-
function (cond, body, loop_vars, maximum_iterations = NULL)
keras$ops$while_loop(cond, body, loop_vars, maximum_iterations)


# keras$ops$erf
# keras.ops.erf
# keras.src.ops.math.erf
r"-(Computes the error function of `x`, element-wise.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same dtype as `x`.

    Example:

    >>> x = np.array([-3.0, -2.0, -1.0, 0.0, 1.0])
    >>> keras.ops.erf(x)
    array([-0.99998 , -0.99532, -0.842701,  0.,  0.842701], dtype=float32)
    )-"

# keras.src.ops.math.erf
#' Computes the error function of `x`, element-wise.
#'
#' @description
#'
#' # Returns
#' A tensor with the same dtype as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-3.0, -2.0, -1.0, 0.0, 1.0])
#' keras.ops.erf(x)
#' # array([-0.99998 , -0.99532, -0.842701,  0.,  0.842701], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/erf>
k_erf <-
function (x)
keras$ops$erf(x)


# keras$ops$extract_sequences
# keras.ops.extract_sequences
# keras.src.ops.math.extract_sequences
r"-(Expands the dimension of last axis into sequences of `sequence_length`.

    Slides a window of size `sequence_length` over the last axis of the input
    with a stride of `sequence_stride`, replacing the last axis with
    `[num_sequences, sequence_length]` sequences.

    If the dimension along the last axis is N, the number of sequences can be
    computed by:

    `num_sequences = 1 + (N - sequence_length) // sequence_stride`

    Args:
        x: Input tensor.
        sequence_length: An integer representing the sequences length.
        sequence_stride: An integer representing the sequences hop size.

    Returns:
        A tensor of sequences with shape [..., num_sequences, sequence_length].

    Example:

    >>> x = keras.ops.convert_to_tensor([1, 2, 3, 4, 5, 6])
    >>> extract_sequences(x, 3, 2)
    array([[1, 2, 3],
       [3, 4, 5]])
    )-"

# keras.src.ops.math.extract_sequences
#' Expands the dimension of last axis into sequences of `sequence_length`.
#'
#' @description
#' Slides a window of size `sequence_length` over the last axis of the input
#' with a stride of `sequence_stride`, replacing the last axis with
#' `[num_sequences, sequence_length]` sequences.
#'
#' If the dimension along the last axis is N, the number of sequences can be
#' computed by:
#'
#' `num_sequences = 1 + (N - sequence_length) // sequence_stride`
#'
#' # Returns
#' A tensor of sequences with shape `[..., num_sequences, sequence_length].`
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, 2, 3, 4, 5, 6])
#' extract_sequences(x, 3, 2)
#' # array([[1, 2, 3],
#' #    [3, 4, 5]])
#' ```
#'
#' @param x Input tensor.
#' @param sequence_length An integer representing the sequences length.
#' @param sequence_stride An integer representing the sequences hop size.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/extract_sequences>
k_extract_sequences <-
function (x, sequence_length, sequence_stride)
{
    args <- capture_args2(list(sequence_length = as_integer,
        sequence_stride = as_integer))
    do.call(keras$ops$extract_sequences, args)
}


# keras$ops$fft
# keras.ops.fft
# keras.src.ops.math.fft
r"-(Computes the Fast Fourier Transform along last axis of input.

    Args:
        x: Tuple of the real and imaginary parts of the input tensor. Both
            tensors in the tuple should be of floating type.

    Returns:
        A tuple containing two tensors - the real and imaginary parts of the
        output tensor.

    Example:

    >>> x = (
    ...     keras.ops.convert_to_tensor([1., 2.]),
    ...     keras.ops.convert_to_tensor([0., 1.]),
    ... )
    >>> fft(x)
    (array([ 3., -1.], dtype=float32), array([ 1., -1.], dtype=float32))
    )-"

# keras.src.ops.math.fft
#' Computes the Fast Fourier Transform along last axis of input.
#'
#' @description
#'
#' # Returns
#' A tuple containing two tensors - the real and imaginary parts of the
#' output tensor.
#'
#' # Examples
#' ```python
#' x = (
#'     keras.ops.convert_to_tensor([1., 2.]),
#'     keras.ops.convert_to_tensor([0., 1.]),
#' )
#' fft(x)
#' # (array([ 3., -1.], dtype=float32), array([ 1., -1.], dtype=float32))
#' ```
#'
#' @param x Tuple of the real and imaginary parts of the input tensor. Both
#' tensors in the tuple should be of floating type.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/fft>
k_fft <-
function (x)
keras$ops$fft(x)


# keras$ops$fft2
# keras.ops.fft2
# keras.src.ops.math.fft2
r"-(Computes the 2D Fast Fourier Transform along the last two axes of input.

    Args:
        x: Tuple of the real and imaginary parts of the input tensor. Both
            tensors in the tuple should be of floating type.

    Returns:
        A tuple containing two tensors - the real and imaginary parts of the
        output.

    Example:

    >>> x = (
    ...     keras.ops.convert_to_tensor([[1., 2.], [2., 1.]]),
    ...     keras.ops.convert_to_tensor([[0., 1.], [1., 0.]]),
    ... )
    >>> fft2(x)
    (array([[ 6.,  0.],
        [ 0., -2.]], dtype=float32), array([[ 2.,  0.],
        [ 0., -2.]], dtype=float32))
    )-"

# keras.src.ops.math.fft2
#' Computes the 2D Fast Fourier Transform along the last two axes of input.
#'
#' @description
#'
#' # Returns
#' A tuple containing two tensors - the real and imaginary parts of the
#' output.
#'
#' # Examples
#' ```python
#' x = (
#'     keras.ops.convert_to_tensor([[1., 2.], [2., 1.]]),
#'     keras.ops.convert_to_tensor([[0., 1.], [1., 0.]]),
#' )
#' fft2(x)
#' # (array([[ 6.,  0.],
#' #     [ 0., -2.]], dtype=float32), array([[ 2.,  0.],
#' #     [ 0., -2.]], dtype=float32))
#' ```
#'
#' @param x Tuple of the real and imaginary parts of the input tensor. Both
#' tensors in the tuple should be of floating type.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/fft2>
k_fft2 <-
function (x)
keras$ops$fft2(x)


# keras$ops$in_top_k
# keras.ops.in_top_k
# keras.src.ops.math.in_top_k
r"-(Checks if the targets are in the top-k predictions.

    Args:
        targets: A tensor of true labels.
        predictions: A tensor of predicted labels.
        k: An integer representing the number of predictions to consider.

    Returns:
        A boolean tensor of the same shape as `targets`, where each element
        indicates whether the corresponding target is in the top-k predictions.

    Example:

    >>> targets = keras.ops.convert_to_tensor([2, 5, 3])
    >>> predictions = keras.ops.convert_to_tensor(
    ... [[0.1, 0.4, 0.6, 0.9, 0.5],
    ...  [0.1, 0.7, 0.9, 0.8, 0.3],
    ...  [0.1, 0.6, 0.9, 0.9, 0.5]])
    >>> in_top_k(targets, predictions, k=3)
    array([ True False  True], shape=(3,), dtype=bool)
    )-"

# keras.src.ops.math.in_top_k
#' Checks if the targets are in the top-k predictions.
#'
#' @description
#'
#' # Returns
#' A boolean tensor of the same shape as `targets`, where each element
#' indicates whether the corresponding target is in the top-k predictions.
#'
#' # Examples
#' ```python
#' targets = keras.ops.convert_to_tensor([2, 5, 3])
#' predictions = keras.ops.convert_to_tensor(
#' [[0.1, 0.4, 0.6, 0.9, 0.5],
#'  [0.1, 0.7, 0.9, 0.8, 0.3],
#'  [0.1, 0.6, 0.9, 0.9, 0.5]])
#' in_top_k(targets, predictions, k=3)
#' # array([ True False  True], shape=(3,), dtype=bool)
#' ```
#'
#' @param targets A tensor of true labels.
#' @param predictions A tensor of predicted labels.
#' @param k An integer representing the number of predictions to consider.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/in_top_k>
k_in_top_k <-
function (targets, predictions, k)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$in_top_k, args)
}


# keras$ops$irfft
# keras.ops.irfft
# keras.src.ops.math.irfft
r"-(Inverse real-valued Fast Fourier transform along the last axis.

    Computes the inverse 1D Discrete Fourier Transform of a real-valued signal
    over the inner-most dimension of input.

    The inner-most dimension of the input is assumed to be the result of RFFT:
    the `fft_length / 2 + 1` unique components of the DFT of a real-valued
    signal. If `fft_length` is not provided, it is computed from the size of the
    inner-most dimension of the input `(fft_length = 2 * (inner - 1))`. If the
    FFT length used to compute is odd, it should be provided since it cannot
    be inferred properly.

    Along the axis IRFFT is computed on, if `fft_length / 2 + 1` is smaller than
    the corresponding dimension of the input, the dimension is cropped. If it is
    larger, the dimension is padded with zeros.

    Args:
        x: Tuple of the real and imaginary parts of the input tensor. Both
            tensors in the tuple should be of floating type.
        fft_length: An integer representing the number of the fft length. If not
            specified, it is inferred from the length of the last axis of `x`.
            Defaults to `None`.

    Returns:
        A tensor containing the inverse real-valued Fast Fourier Transform
        along the last axis of `x`.

    Examples:

    >>> real = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
    >>> imag = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
    >>> irfft((real, imag))
    array([0.66666667, -0.9106836, 0.24401694])

    >>> irfft(rfft(real, 5), 5)
    array([0.0, 1.0, 2.0, 3.0, 4.0])
    )-"

# keras.src.ops.math.irfft
#' Inverse real-valued Fast Fourier transform along the last axis.
#'
#' @description
#' Computes the inverse 1D Discrete Fourier Transform of a real-valued signal
#' over the inner-most dimension of input.
#'
#' The inner-most dimension of the input is assumed to be the result of RFFT:
#' the `fft_length / 2 + 1` unique components of the DFT of a real-valued
#' signal. If `fft_length` is not provided, it is computed from the size of the
#' inner-most dimension of the input `(fft_length = 2 * (inner - 1))`. If the
#' FFT length used to compute is odd, it should be provided since it cannot
#' be inferred properly.
#'
#' Along the axis IRFFT is computed on, if `fft_length / 2 + 1` is smaller than
#' the corresponding dimension of the input, the dimension is cropped. If it is
#' larger, the dimension is padded with zeros.
#'
#' # Returns
#' A tensor containing the inverse real-valued Fast Fourier Transform
#' along the last axis of `x`.
#'
#' # Examples
#' ```python
#' real = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
#' imag = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
#' irfft((real, imag))
#' # array([0.66666667, -0.9106836, 0.24401694])
#' ```
#'
#' ```python
#' irfft(rfft(real, 5), 5)
#' # array([0.0, 1.0, 2.0, 3.0, 4.0])
#' ```
#'
#' @param x Tuple of the real and imaginary parts of the input tensor. Both
#'     tensors in the tuple should be of floating type.
#' @param fft_length An integer representing the number of the fft length. If not
#'     specified, it is inferred from the length of the last axis of `x`.
#'     Defaults to `None`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/irfft>
k_irfft <-
function (x, fft_length = NULL)
{
    args <- capture_args2(list(fft_length = as_integer))
    do.call(keras$ops$irfft, args)
}


# keras$ops$istft
# keras.ops.istft
# keras.src.ops.math.istft
r"-(Inverse Short-Time Fourier Transform along the last axis of the input.

    To reconstruct an original waveform, the parameters should be the same in
    `stft`.

    Args:
        x: Tuple of the real and imaginary parts of the input tensor. Both
            tensors in the tuple should be of floating type.
        sequence_length: An integer representing the sequence length.
        sequence_stride: An integer representing the sequence hop size.
        fft_length: An integer representing the size of the FFT that produced
            `stft`.
        length: An integer representing the output is clipped to exactly length.
            If not specified, no padding or clipping take place. Defaults to
            `None`.
        window: A string, a tensor of the window or `None`. If `window` is a
            string, available values are `"hann"` and `"hamming"`. If `window`
            is a tensor, it will be used directly as the window and its length
            must be `sequence_length`. If `window` is `None`, no windowing is
            used. Defaults to `"hann"`.
        center: Whether `x` was padded on both sides so that the t-th sequence
            is centered at time `t * sequence_stride`. Defaults to `True`.

    Returns:
        A tensor containing the inverse Short-Time Fourier Transform along the
        last axis of `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
    >>> istft(stft(x, 1, 1, 1), 1, 1, 1)
    array([0.0, 1.0, 2.0, 3.0, 4.0])
    )-"

# keras.src.ops.math.istft
#' Inverse Short-Time Fourier Transform along the last axis of the input.
#'
#' @description
#' To reconstruct an original waveform, the parameters should be the same in
#' `stft`.
#'
#' # Returns
#' A tensor containing the inverse Short-Time Fourier Transform along the
#' last axis of `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
#' istft(stft(x, 1, 1, 1), 1, 1, 1)
#' # array([0.0, 1.0, 2.0, 3.0, 4.0])
#' ```
#'
#' @param x Tuple of the real and imaginary parts of the input tensor. Both
#'     tensors in the tuple should be of floating type.
#' @param sequence_length An integer representing the sequence length.
#' @param sequence_stride An integer representing the sequence hop size.
#' @param fft_length An integer representing the size of the FFT that produced
#'     `stft`.
#' @param length An integer representing the output is clipped to exactly length.
#'     If not specified, no padding or clipping take place. Defaults to
#'     `None`.
#' @param window A string, a tensor of the window or `None`. If `window` is a
#'     string, available values are `"hann"` and `"hamming"`. If `window`
#'     is a tensor, it will be used directly as the window and its length
#'     must be `sequence_length`. If `window` is `None`, no windowing is
#'     used. Defaults to `"hann"`.
#' @param center Whether `x` was padded on both sides so that the t-th sequence
#'     is centered at time `t * sequence_stride`. Defaults to `True`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/istft>
k_istft <-
function (x, sequence_length, sequence_stride, fft_length, length = NULL,
    window = "hann", center = TRUE)
{
    args <- capture_args2(list(sequence_length = as_integer,
        sequence_stride = as_integer, fft_length = as_integer,
        length = as_integer))
    do.call(keras$ops$istft, args)
}


# keras$ops$logsumexp
# keras.ops.logsumexp
# keras.src.ops.math.logsumexp
r"-(Computes the logarithm of sum of exponentials of elements in a tensor.

    Args:
        x: Input tensor.
        axis: An integer or a tuple of integers specifying the axis/axes
            along which to compute the sum. If `None`, the sum is computed
            over all elements. Defaults to`None`.
        keepdims: A boolean indicating whether to keep the dimensions of
            the input tensor when computing the sum. Defaults to`False`.

    Returns:
        A tensor containing the logarithm of the sum of exponentials of
        elements in `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([1., 2., 3.])
    >>> logsumexp(x)
    3.407606
    )-"

# keras.src.ops.math.logsumexp
#' Computes the logarithm of sum of exponentials of elements in a tensor.
#'
#' @description
#'
#' # Returns
#' A tensor containing the logarithm of the sum of exponentials of
#' elements in `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1., 2., 3.])
#' logsumexp(x)
#' # 3.407606
#' ```
#'
#' @param x Input tensor.
#' @param axis An integer or a tuple of integers specifying the axis/axes
#'     along which to compute the sum. If `None`, the sum is computed
#'     over all elements. Defaults to`None`.
#' @param keepdims A boolean indicating whether to keep the dimensions of
#'     the input tensor when computing the sum. Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logsumexp>
k_logsumexp <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$logsumexp, args)
}


# keras$ops$qr
# keras.ops.qr
# keras.src.ops.math.qr
r"-(Computes the QR decomposition of a tensor.

    Args:
        x: Input tensor.
        mode: A string specifying the mode of the QR decomposition.
            - 'reduced': Returns the reduced QR decomposition. (default)
            - 'complete': Returns the complete QR decomposition.

    Returns:
        A tuple containing two tensors. The first tensor represents the
        orthogonal matrix Q, and the second tensor represents the upper
        triangular matrix R.

    Example:

    >>> x = keras.ops.convert_to_tensor([[1., 2.], [3., 4.], [5., 6.]])
    >>> q, r = qr(x)
    >>> print(q)
    array([[-0.16903079  0.897085]
           [-0.5070925   0.2760267 ]
           [-0.8451542  -0.34503305]], shape=(3, 2), dtype=float32)
    )-"

# keras.src.ops.math.qr
#' Computes the QR decomposition of a tensor.
#'
#' @description
#'
#' # Returns
#' A tuple containing two tensors. The first tensor represents the
#' orthogonal matrix Q, and the second tensor represents the upper
#' triangular matrix R.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([[1., 2.], [3., 4.], [5., 6.]])
#' q, r = qr(x)
#' print(q)
#' # array([[-0.16903079  0.897085]
#' #        [-0.5070925   0.2760267 ]
#' #        [-0.8451542  -0.34503305]], shape=(3, 2), dtype=float32)
#' ```
#'
#' @param x Input tensor.
#' @param mode A string specifying the mode of the QR decomposition.
#'     - 'reduced': Returns the reduced QR decomposition. (default)
#'     - 'complete': Returns the complete QR decomposition.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/qr>
k_qr <-
function (x, mode = "reduced")
keras$ops$qr(x, mode)


# keras$ops$rfft
# keras.ops.rfft
# keras.src.ops.math.rfft
r"-(Real-valued Fast Fourier Transform along the last axis of the input.

    Computes the 1D Discrete Fourier Transform of a real-valued signal over the
    inner-most dimension of input.

    Since the Discrete Fourier Transform of a real-valued signal is
    Hermitian-symmetric, RFFT only returns the `fft_length / 2 + 1` unique
    components of the FFT: the zero-frequency term, followed by the
    `fft_length / 2` positive-frequency terms.

    Along the axis RFFT is computed on, if `fft_length` is smaller than the
    corresponding dimension of the input, the dimension is cropped. If it is
    larger, the dimension is padded with zeros.

    Args:
        x: Input tensor.
        fft_length: An integer representing the number of the fft length. If not
            specified, it is inferred from the length of the last axis of `x`.
            Defaults to `None`.

    Returns:
        A tuple containing two tensors - the real and imaginary parts of the
        output.

    Examples:

    >>> x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
    >>> rfft(x)
    (array([10.0, -2.5, -2.5]), array([0.0, 3.4409548, 0.81229924]))

    >>> rfft(x, 3)
    (array([3.0, -1.5]), array([0.0, 0.8660254]))
    )-"

# keras.src.ops.math.rfft
#' Real-valued Fast Fourier Transform along the last axis of the input.
#'
#' @description
#' Computes the 1D Discrete Fourier Transform of a real-valued signal over the
#' inner-most dimension of input.
#'
#' Since the Discrete Fourier Transform of a real-valued signal is
#' Hermitian-symmetric, RFFT only returns the `fft_length / 2 + 1` unique
#' components of the FFT: the zero-frequency term, followed by the
#' `fft_length / 2` positive-frequency terms.
#'
#' Along the axis RFFT is computed on, if `fft_length` is smaller than the
#' corresponding dimension of the input, the dimension is cropped. If it is
#' larger, the dimension is padded with zeros.
#'
#' # Returns
#' A tuple containing two tensors - the real and imaginary parts of the
#' output.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
#' rfft(x)
#' # (array([10.0, -2.5, -2.5]), array([0.0, 3.4409548, 0.81229924]))
#' ```
#'
#' ```python
#' rfft(x, 3)
#' # (array([3.0, -1.5]), array([0.0, 0.8660254]))
#' ```
#'
#' @param x Input tensor.
#' @param fft_length An integer representing the number of the fft length. If not
#'     specified, it is inferred from the length of the last axis of `x`.
#'     Defaults to `None`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/rfft>
k_rfft <-
function (x, fft_length = NULL)
{
    args <- capture_args2(list(fft_length = as_integer))
    do.call(keras$ops$rfft, args)
}


# keras$ops$rsqrt
# keras.ops.rsqrt
# keras.src.ops.math.rsqrt
r"-(Computes reciprocal of square root of x element-wise.

    Args:
        x: input tensor

    Returns:
        A tensor with the same dtype as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([1.0, 10.0, 100.0])
    >>> keras.ops.rsqrt(x)
    array([1.0, 0.31622776, 0.1], dtype=float32)
    )-"

# keras.src.ops.math.rsqrt
#' Computes reciprocal of square root of x element-wise.
#'
#' @description
#'
#' # Returns
#' A tensor with the same dtype as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1.0, 10.0, 100.0])
#' keras.ops.rsqrt(x)
#' # array([1.0, 0.31622776, 0.1], dtype=float32)
#' ```
#'
#' @param x input tensor
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/rsqrt>
k_rsqrt <-
function (x)
keras$ops$rsqrt(x)


# keras$ops$segment_max
# keras.ops.segment_max
# keras.src.ops.math.segment_max
r"-(Computes the max of segments in a tensor.

    Args:
        data: Input tensor.
        segment_ids: A 1-D tensor containing segment indices for each
            element in `data`.
        num_segments: An integer representing the total number of
            segments. If not specified, it is inferred from the maximum
            value in `segment_ids`.
        sorted: A boolean indicating whether `segment_ids` is sorted.
            Defaults to`False`.

    Returns:
        A tensor containing the max of segments, where each element
        represents the max of the corresponding segment in `data`.

    Example:

    >>> data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])
    >>> segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])
    >>> num_segments = 3
    >>> keras.ops.segment_max(data, segment_ids, num_segments)
    array([2, 20, 200], dtype=int32)
    )-"

# keras.src.ops.math.segment_max
#' Computes the max of segments in a tensor.
#'
#' @description
#'
#' # Returns
#' A tensor containing the max of segments, where each element
#' represents the max of the corresponding segment in `data`.
#'
#' # Examples
#' ```python
#' data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])
#' segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])
#' num_segments = 3
#' keras.ops.segment_max(data, segment_ids, num_segments)
#' # array([2, 20, 200], dtype=int32)
#' ```
#'
#' @param data Input tensor.
#' @param segment_ids A 1-D tensor containing segment indices for each
#'     element in `data`.
#' @param num_segments An integer representing the total number of
#'     segments. If not specified, it is inferred from the maximum
#'     value in `segment_ids`.
#' @param sorted A boolean indicating whether `segment_ids` is sorted.
#'     Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/segment_max>
k_segment_max <-
function (data, segment_ids, num_segments = NULL, sorted = FALSE)
{
    args <- capture_args2(list(num_segments = as_integer))
    do.call(keras$ops$segment_max, args)
}


# keras$ops$segment_sum
# keras.ops.segment_sum
# keras.src.ops.math.segment_sum
r"-(Computes the sum of segments in a tensor.

    Args:
        data: Input tensor.
        segment_ids: A 1-D tensor containing segment indices for each
            element in `data`.
        num_segments: An integer representing the total number of
            segments. If not specified, it is inferred from the maximum
            value in `segment_ids`.
        sorted: A boolean indicating whether `segment_ids` is sorted.
            Defaults to`False`.

    Returns:
        A tensor containing the sum of segments, where each element
        represents the sum of the corresponding segment in `data`.

    Example:

    >>> data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])
    >>> segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])
    >>> num_segments = 3
    >>> keras.ops.segment_sum(data, segment_ids,num_segments)
    array([3, 30, 300], dtype=int32)
    )-"

# keras.src.ops.math.segment_sum
#' Computes the sum of segments in a tensor.
#'
#' @description
#'
#' # Returns
#' A tensor containing the sum of segments, where each element
#' represents the sum of the corresponding segment in `data`.
#'
#' # Examples
#' ```python
#' data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])
#' segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])
#' num_segments = 3
#' keras.ops.segment_sum(data, segment_ids,num_segments)
#' # array([3, 30, 300], dtype=int32)
#' ```
#'
#' @param data Input tensor.
#' @param segment_ids A 1-D tensor containing segment indices for each
#'     element in `data`.
#' @param num_segments An integer representing the total number of
#'     segments. If not specified, it is inferred from the maximum
#'     value in `segment_ids`.
#' @param sorted A boolean indicating whether `segment_ids` is sorted.
#'     Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/segment_sum>
k_segment_sum <-
function (data, segment_ids, num_segments = NULL, sorted = FALSE)
{
    args <- capture_args2(list(num_segments = as_integer))
    do.call(keras$ops$segment_sum, args)
}


# keras$ops$stft
# keras.ops.stft
# keras.src.ops.math.stft
r"-(Short-Time Fourier Transform along the last axis of the input.

    The STFT computes the Fourier transform of short overlapping windows of the
    input. This giving frequency components of the signal as they change over
    time.

    Args:
        x: Input tensor.
        sequence_length: An integer representing the sequence length.
        sequence_stride: An integer representing the sequence hop size.
        fft_length: An integer representing the size of the FFT to apply. If not
            specified, uses the smallest power of 2 enclosing `sequence_length`.
        window: A string, a tensor of the window or `None`. If `window` is a
            string, available values are `"hann"` and `"hamming"`. If `window`
            is a tensor, it will be used directly as the window and its length
            must be `sequence_length`. If `window` is `None`, no windowing is
            used. Defaults to `"hann"`.
        center: Whether to pad `x` on both sides so that the t-th sequence is
            centered at time `t * sequence_stride`. Otherwise, the t-th sequence
            begins at time `t * sequence_stride`. Defaults to `True`.

    Returns:
        A tuple containing two tensors - the real and imaginary parts of the
        STFT output.

    Example:

    >>> x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
    >>> stft(x, 3, 2, 3)
    (array([[0.75, -0.375],
       [3.75, -1.875],
       [5.25, -2.625]]), array([[0.0, 0.64951905],
       [0.0, 0.64951905],
       [0.0, -0.64951905]]))
    )-"

# keras.src.ops.math.stft
#' Short-Time Fourier Transform along the last axis of the input.
#'
#' @description
#' The STFT computes the Fourier transform of short overlapping windows of the
#' input. This giving frequency components of the signal as they change over
#' time.
#'
#' # Returns
#' A tuple containing two tensors - the real and imaginary parts of the
#' STFT output.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])
#' stft(x, 3, 2, 3)
#' # (array([[0.75, -0.375],
#' #    [3.75, -1.875],
#' #    [5.25, -2.625]]), array([[0.0, 0.64951905],
#' #    [0.0, 0.64951905],
#' #    [0.0, -0.64951905]]))
#' ```
#'
#' @param x Input tensor.
#' @param sequence_length An integer representing the sequence length.
#' @param sequence_stride An integer representing the sequence hop size.
#' @param fft_length An integer representing the size of the FFT to apply. If not
#'     specified, uses the smallest power of 2 enclosing `sequence_length`.
#' @param window A string, a tensor of the window or `None`. If `window` is a
#'     string, available values are `"hann"` and `"hamming"`. If `window`
#'     is a tensor, it will be used directly as the window and its length
#'     must be `sequence_length`. If `window` is `None`, no windowing is
#'     used. Defaults to `"hann"`.
#' @param center Whether to pad `x` on both sides so that the t-th sequence is
#'     centered at time `t * sequence_stride`. Otherwise, the t-th sequence
#'     begins at time `t * sequence_stride`. Defaults to `True`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/stft>
k_stft <-
function (x, sequence_length, sequence_stride, fft_length, window = "hann",
    center = TRUE)
{
    args <- capture_args2(list(sequence_length = as_integer,
        sequence_stride = as_integer, fft_length = as_integer))
    do.call(keras$ops$stft, args)
}


# keras$ops$top_k
# keras.ops.top_k
# keras.src.ops.math.top_k
r"-(Finds the top-k values and their indices in a tensor.

    Args:
        x: Input tensor.
        k: An integer representing the number of top elements to retrieve.
        sorted: A boolean indicating whether to sort the output in
        descending order. Defaults to`True`.

    Returns:
        A tuple containing two tensors. The first tensor contains the
        top-k values, and the second tensor contains the indices of the
        top-k values in the input tensor.

    Example:

    >>> x = keras.ops.convert_to_tensor([5, 2, 7, 1, 9, 3])
    >>> values, indices = top_k(x, k=3)
    >>> print(values)
    array([9 7 5], shape=(3,), dtype=int32)
    >>> print(indices)
    array([4 2 0], shape=(3,), dtype=int32)

    )-"

# keras.src.ops.math.top_k
#' Finds the top-k values and their indices in a tensor.
#'
#' @description
#'
#' # Returns
#' A tuple containing two tensors. The first tensor contains the
#' top-k values, and the second tensor contains the indices of the
#' top-k values in the input tensor.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([5, 2, 7, 1, 9, 3])
#' values, indices = top_k(x, k=3)
#' print(values)
#' # array([9 7 5], shape=(3,), dtype=int32)
#' print(indices)
#' # array([4 2 0], shape=(3,), dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param k An integer representing the number of top elements to retrieve.
#' @param sorted A boolean indicating whether to sort the output in
#' descending order. Defaults to`True`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/top_k>
k_top_k <-
function (x, k, sorted = TRUE)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$top_k, args)
}


# keras$ops$average_pool
# keras.ops.average_pool
# keras.src.ops.nn.average_pool
r"-(Average pooling operation.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,)` + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`. Pooling happens over the spatial
            dimensions only.
        pool_size: int or tuple/list of integers of size
            `len(inputs_spatial_shape)`, specifying the size of the pooling
            window for each spatial dimension of the input tensor. If
            `pool_size` is int, then every spatial dimension shares the same
            `pool_size`.
        strides: int or tuple/list of integers of size
            `len(inputs_spatial_shape)`. The stride of the sliding window for
            each spatial dimension of the input tensor. If `strides` is int,
            then every spatial dimension shares the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.

    Returns:
        A tensor of rank N+2, the result of the average pooling operation.
    )-"

# keras.src.ops.nn.average_pool
#' Average pooling operation.
#'
#' @description
#'
#' # Returns
#'     A tensor of rank N+2, the result of the average pooling operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`. Pooling happens over the spatial
#'     dimensions only.
#' @param pool_size int or tuple/list of integers of size
#'     `len(inputs_spatial_shape)`, specifying the size of the pooling
#'     window for each spatial dimension of the input tensor. If
#'     `pool_size` is int, then every spatial dimension shares the same
#'     `pool_size`.
#' @param strides int or tuple/list of integers of size
#'     `len(inputs_spatial_shape)`. The stride of the sliding window for
#'     each spatial dimension of the input tensor. If `strides` is int,
#'     then every spatial dimension shares the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/average_pool>
k_average_pool <-
function (inputs, pool_size, strides = NULL, padding = "valid",
    data_format = NULL)
{
    args <- capture_args2(list(pool_size = as_integer, strides = as_integer))
    do.call(keras$ops$average_pool, args)
}


# keras$ops$binary_crossentropy
# keras.ops.binary_crossentropy
# keras.src.ops.nn.binary_crossentropy
r"-(Computes binary cross-entropy loss between target and output tensor.

    The binary cross-entropy loss is commonly used in binary
    classification tasks where each input sample belongs to one
    of the two classes. It measures the dissimilarity between the
    target and output probabilities or logits.

    Args:
        target: The target tensor representing the true binary labels.
            Its shape should match the shape of the `output` tensor.
        output: The output tensor representing the predicted probabilities
            or logits. Its shape should match the shape of the
            `target` tensor.
        from_logits: (optional) Whether `output` is a tensor of logits or
            probabilities.
            Set it to `True` if `output` represents logits; otherwise,
            set it to `False` if `output` represents probabilities.
            Defaults to`False`.

    Returns:
        Integer tensor: The computed binary cross-entropy loss between
        `target` and `output`.

    Example:

    >>> target = keras.ops.convert_to_tensor([0, 1, 1, 0])
    >>> output = keras.ops.convert_to_tensor([0.1, 0.9, 0.8, 0.2])
    >>> binary_crossentropy(target, output)
    array([0.10536054 0.10536054 0.22314355 0.22314355],
          shape=(4,), dtype=float32)
    )-"

# keras.src.ops.nn.binary_crossentropy
#' Computes binary cross-entropy loss between target and output tensor.
#'
#' @description
#' The binary cross-entropy loss is commonly used in binary
#' classification tasks where each input sample belongs to one
#' of the two classes. It measures the dissimilarity between the
#' target and output probabilities or logits.
#'
#' # Returns
#' Integer tensor: The computed binary cross-entropy loss between
#' `target` and `output`.
#'
#' # Examples
#' ```python
#' target = keras.ops.convert_to_tensor([0, 1, 1, 0])
#' output = keras.ops.convert_to_tensor([0.1, 0.9, 0.8, 0.2])
#' binary_crossentropy(target, output)
#' # array([0.10536054 0.10536054 0.22314355 0.22314355],
#' #       shape=(4,), dtype=float32)
#' ```
#'
#' @param target The target tensor representing the true binary labels.
#'     Its shape should match the shape of the `output` tensor.
#' @param output The output tensor representing the predicted probabilities
#'     or logits. Its shape should match the shape of the
#'     `target` tensor.
#' @param from_logits (optional) Whether `output` is a tensor of logits or
#'     probabilities.
#'     Set it to `True` if `output` represents logits; otherwise,
#'     set it to `False` if `output` represents probabilities.
#'     Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/binary_crossentropy>
k_binary_crossentropy <-
function (target, output, from_logits = FALSE)
keras$ops$binary_crossentropy(target, output, from_logits)


# keras$ops$categorical_crossentropy
# keras.ops.categorical_crossentropy
# keras.src.ops.nn.categorical_crossentropy
r"-(Computes categorical cross-entropy loss between target and output tensor.

    The categorical cross-entropy loss is commonly used in multi-class
    classification tasks where each input sample can belong to one of
    multiple classes. It measures the dissimilarity
    between the target and output probabilities or logits.

    Args:
        target: The target tensor representing the true categorical labels.
            Its shape should match the shape of the `output` tensor
            except for the last dimension.
        output: The output tensor representing the predicted probabilities
            or logits. Its shape should match the shape of the `target`
            tensor except for the last dimension.
        from_logits: (optional) Whether `output` is a tensor of logits or
            probabilities.
            Set it to `True` if `output` represents logits; otherwise,
            set it to `False` if `output` represents probabilities.
            Defaults to`False`.
        axis: (optional) The axis along which the categorical cross-entropy
            is computed.
            Defaults to `-1`, which corresponds to the last dimension of
            the tensors.

    Returns:
        Integer tensor: The computed categorical cross-entropy loss between
        `target` and `output`.

    Example:

    >>> target = keras.ops.convert_to_tensor(
    ... [[1, 0, 0],
    ...  [0, 1, 0],
    ...  [0, 0, 1]])
    >>> output = keras.ops.convert_to_tensor(
    ... [[0.9, 0.05, 0.05],
    ...  [0.1, 0.8, 0.1],
    ...  [0.2, 0.3, 0.5]])
    >>> categorical_crossentropy(target, output)
    array([0.10536054 0.22314355 0.6931472 ], shape=(3,), dtype=float32)
    )-"

# keras.src.ops.nn.categorical_crossentropy
#' Computes categorical cross-entropy loss between target and output tensor.
#'
#' @description
#' The categorical cross-entropy loss is commonly used in multi-class
#' classification tasks where each input sample can belong to one of
#' multiple classes. It measures the dissimilarity
#' between the target and output probabilities or logits.
#'
#' # Returns
#' Integer tensor: The computed categorical cross-entropy loss between
#' `target` and `output`.
#'
#' # Examples
#' ```python
#' target = keras.ops.convert_to_tensor(
#' [[1, 0, 0],
#'  [0, 1, 0],
#'  [0, 0, 1]])
#' output = keras.ops.convert_to_tensor(
#' [[0.9, 0.05, 0.05],
#'  [0.1, 0.8, 0.1],
#'  [0.2, 0.3, 0.5]])
#' categorical_crossentropy(target, output)
#' # array([0.10536054 0.22314355 0.6931472 ], shape=(3,), dtype=float32)
#' ```
#'
#' @param target The target tensor representing the true categorical labels.
#'     Its shape should match the shape of the `output` tensor
#'     except for the last dimension.
#' @param output The output tensor representing the predicted probabilities
#'     or logits. Its shape should match the shape of the `target`
#'     tensor except for the last dimension.
#' @param from_logits (optional) Whether `output` is a tensor of logits or
#'     probabilities.
#'     Set it to `True` if `output` represents logits; otherwise,
#'     set it to `False` if `output` represents probabilities.
#'     Defaults to`False`.
#' @param axis (optional) The axis along which the categorical cross-entropy
#'     is computed.
#'     Defaults to `-1`, which corresponds to the last dimension of
#'     the tensors.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/categorical_crossentropy>
k_categorical_crossentropy <-
function (target, output, from_logits = FALSE, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$categorical_crossentropy, args)
}


# keras$ops$conv
# keras.ops.conv
# keras.src.ops.nn.conv
r"-(General N-D convolution.

    This ops supports 1D, 2D and 3D convolution.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`.
        kernel: Tensor of rank N+2. `kernel` has shape
            `(kernel_spatial_shape, num_input_channels, num_output_channels)`.
            `num_input_channels` should match the number of channels in
            `inputs`.
        strides: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the strides of the convolution along each spatial
            dimension. If `strides` is int, then every spatial dimension shares
            the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.
        dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the dilation rate to use for dilated convolution. If
            `dilation_rate` is int, then every spatial dimension shares
            the same `dilation_rate`.

    Returns:
        A tensor of rank N+2, the result of the conv operation.
    )-"

# keras.src.ops.nn.conv
#' General N-D convolution.
#'
#' @description
#' This ops supports 1D, 2D and 3D convolution.
#'
#' # Returns
#'     A tensor of rank N+2, the result of the conv operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`.
#' @param kernel Tensor of rank N+2. `kernel` has shape
#'     `(kernel_spatial_shape, num_input_channels, num_output_channels)`.
#'     `num_input_channels` should match the number of channels in
#'     `inputs`.
#' @param strides int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the strides of the convolution along each spatial
#'     dimension. If `strides` is int, then every spatial dimension shares
#'     the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#' @param dilation_rate int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the dilation rate to use for dilated convolution. If
#'     `dilation_rate` is int, then every spatial dimension shares
#'     the same `dilation_rate`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/conv>
k_conv <-
function (inputs, kernel, strides = 1L, padding = "valid", data_format = NULL,
    dilation_rate = 1L)
{
    args <- capture_args2(list(strides = as_integer, dilation_rate = as_integer))
    do.call(keras$ops$conv, args)
}


# keras$ops$conv_transpose
# keras.ops.conv_transpose
# keras.src.ops.nn.conv_transpose
r"-(General N-D convolution transpose.

    Also known as de-convolution. This ops supports 1D, 2D and 3D convolution.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,)` + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`.
        kernel: Tensor of rank N+2. `kernel` has shape
            [kernel_spatial_shape, num_output_channels, num_input_channels],
            `num_input_channels` should match the number of channels in
            `inputs`.
        strides: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the strides of the convolution along each spatial
            dimension. If `strides` is int, then every spatial dimension shares
            the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        output_padding: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the amount of padding along the height and width of
            the output tensor. Can be a single integer to specify the same
            value for all spatial dimensions. The amount of output padding
            along a given dimension must be lower than the stride along that
            same dimension. If set to `None` (default), the output shape is
            inferred.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.
        dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the dilation rate to use for dilated convolution. If
            `dilation_rate` is int, then every spatial dimension shares
            the same `dilation_rate`.

    Returns:
        A tensor of rank N+2, the result of the conv operation.
    )-"

# keras.src.ops.nn.conv_transpose
#' General N-D convolution transpose.
#'
#' @description
#' Also known as de-convolution. This ops supports 1D, 2D and 3D convolution.
#'
#' # Returns
#'     A tensor of rank N+2, the result of the conv operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`.
#' @param kernel Tensor of rank N+2. `kernel` has shape
#'     `[kernel_spatial_shape, num_output_channels, num_input_channels],`
#'     `num_input_channels` should match the number of channels in
#'     `inputs`.
#' @param strides int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the strides of the convolution along each spatial
#'     dimension. If `strides` is int, then every spatial dimension shares
#'     the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param output_padding int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the amount of padding along the height and width of
#'     the output tensor. Can be a single integer to specify the same
#'     value for all spatial dimensions. The amount of output padding
#'     along a given dimension must be lower than the stride along that
#'     same dimension. If set to `None` (default), the output shape is
#'     inferred.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#' @param dilation_rate int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the dilation rate to use for dilated convolution. If
#'     `dilation_rate` is int, then every spatial dimension shares
#'     the same `dilation_rate`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/conv_transpose>
k_conv_transpose <-
function (inputs, kernel, strides, padding = "valid", output_padding = NULL,
    data_format = NULL, dilation_rate = 1L)
{
    args <- capture_args2(list(strides = as_integer, output_padding = as_integer,
        dilation_rate = as_integer))
    do.call(keras$ops$conv_transpose, args)
}


# keras$ops$depthwise_conv
# keras.ops.depthwise_conv
# keras.src.ops.nn.depthwise_conv
r"-(General N-D depthwise convolution.

    This ops supports 1D and 2D depthwise convolution.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,)` + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`.
        kernel: Tensor of rank N+2. `kernel` has shape
            [kernel_spatial_shape, num_input_channels, num_channels_multiplier],
            `num_input_channels` should match the number of channels in
            `inputs`.
        strides: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the strides of the convolution along each spatial
            dimension. If `strides` is int, then every spatial dimension shares
            the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.
        dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the dilation rate to use for dilated convolution. If
            `dilation_rate` is int, then every spatial dimension shares
            the same `dilation_rate`.

    Returns:
        A tensor of rank N+2, the result of the depthwise conv operation.
    )-"

# keras.src.ops.nn.depthwise_conv
#' General N-D depthwise convolution.
#'
#' @description
#' This ops supports 1D and 2D depthwise convolution.
#'
#' # Returns
#'     A tensor of rank N+2, the result of the depthwise conv operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`.
#' @param kernel Tensor of rank N+2. `kernel` has shape
#'     `[kernel_spatial_shape, num_input_channels, num_channels_multiplier],`
#'     `num_input_channels` should match the number of channels in
#'     `inputs`.
#' @param strides int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the strides of the convolution along each spatial
#'     dimension. If `strides` is int, then every spatial dimension shares
#'     the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#' @param dilation_rate int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the dilation rate to use for dilated convolution. If
#'     `dilation_rate` is int, then every spatial dimension shares
#'     the same `dilation_rate`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/depthwise_conv>
k_depthwise_conv <-
function (inputs, kernel, strides = 1L, padding = "valid", data_format = NULL,
    dilation_rate = 1L)
{
    args <- capture_args2(list(strides = as_integer, dilation_rate = as_integer))
    do.call(keras$ops$depthwise_conv, args)
}


# keras$ops$elu
# keras.ops.elu
# keras.src.ops.nn.elu
r"-(Exponential Linear Unit activation function.

    It is defined as:

    `f(x) =  alpha * (exp(x) - 1.) for x < 0`, `f(x) = x for x >= 0`.

    Args:
        x: Input tensor.
        alpha: A scalar, slope of positive section. Defaults to `1.0`.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_elu = keras.ops.elu(x)
    >>> print(x_elu)
    array([-0.63212055, 0., 1.], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.elu
#' Exponential Linear Unit activation function.
#'
#' @description
#' It is defined as:
#'
#' `f(x) =  alpha * (exp(x) - 1.) for x < 0`, `f(x) = x for x >= 0`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_elu = keras.ops.elu(x)
#' print(x_elu)
#' # array([-0.63212055, 0., 1.], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#' @param alpha A scalar, slope of positive section. Defaults to `1.0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/elu>
k_elu <-
function (x, alpha = 1)
keras$ops$elu(x, alpha)


# keras$ops$gelu
# keras.ops.gelu
# keras.src.ops.nn.gelu
r"-(Gaussian Error Linear Unit (GELU) activation function.

    If `approximate` is `True`, it is defined as:
    `f(x) = 0.5 * x * (1 + tanh(sqrt(2 / pi) * (x + 0.044715 * x^3)))`

    Or if `approximate` is `False`, it is defined as:
    `f(x) = x * P(X <= x) = 0.5 * x * (1 + erf(x / sqrt(2)))`,
    where `P(X) ~ N(0, 1)`.

    Args:
        x: Input tensor.
        approximate: Approximate version of GELU activation. Defaults to `True`.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_gelu = keras.ops.gelu(x)
    >>> print(x_gelu)
    array([-0.15865525, 0., 0.84134475], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.gelu
#' Gaussian Error Linear Unit (GELU) activation function.
#'
#' @description
#' If `approximate` is `True`, it is defined as:
#' `f(x) = 0.5 * x * (1 + tanh(sqrt(2 / pi) * (x + 0.044715 * x^3)))`
#'
#' Or if `approximate` is `False`, it is defined as:
#' `f(x) = x * P(X <= x) = 0.5 * x * (1 + erf(x / sqrt(2)))`,
#' where `P(X) ~ N(0, 1)`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_gelu = keras.ops.gelu(x)
#' print(x_gelu)
#' # array([-0.15865525, 0., 0.84134475], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#' @param approximate Approximate version of GELU activation. Defaults to `True`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/gelu>
k_gelu <-
function (x, approximate = TRUE)
keras$ops$gelu(x, approximate)


# keras$ops$hard_sigmoid
# keras.ops.hard_sigmoid
# keras.src.ops.nn.hard_sigmoid
r"-(Hard sigmoid activation function.

    It is defined as:

    `0 if x < -2.5`, `1 if x > 2.5`, `(0.2 * x) + 0.5 if -2.5 <= x <= 2.5`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_hard_sigmoid = keras.ops.hard_sigmoid(x)
    >>> print(x_hard_sigmoid)
    array([0.3, 0.5, 0.7], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.hard_sigmoid
#' Hard sigmoid activation function.
#'
#' @description
#' It is defined as:
#'
#' `0 if x < -2.5`, `1 if x > 2.5`, `(0.2 * x) + 0.5 if -2.5 <= x <= 2.5`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_hard_sigmoid = keras.ops.hard_sigmoid(x)
#' print(x_hard_sigmoid)
#' # array([0.3, 0.5, 0.7], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/hard_sigmoid>
k_hard_sigmoid <-
function (x)
keras$ops$hard_sigmoid(x)


# keras$ops$leaky_relu
# keras.ops.leaky_relu
# keras.src.ops.nn.leaky_relu
r"-(Leaky version of a Rectified Linear Unit activation function.

    It allows a small gradient when the unit is not active, it is defined as:

    `f(x) = alpha * x for x < 0` or `f(x) = x for x >= 0`.

    Args:
        x: Input tensor.
        negative_slope: Slope of the activation function at x < 0.
            Defaults to `0.2`.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_leaky_relu = keras.ops.leaky_relu(x)
    >>> print(x_leaky_relu)
    array([-0.2,  0. ,  1. ], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.leaky_relu
#' Leaky version of a Rectified Linear Unit activation function.
#'
#' @description
#' It allows a small gradient when the unit is not active, it is defined as:
#'
#' `f(x) = alpha * x for x < 0` or `f(x) = x for x >= 0`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_leaky_relu = keras.ops.leaky_relu(x)
#' print(x_leaky_relu)
#' # array([-0.2,  0. ,  1. ], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#' @param negative_slope Slope of the activation function at x < 0.
#'     Defaults to `0.2`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/leaky_relu>
k_leaky_relu <-
function (x, negative_slope = 0.2)
keras$ops$leaky_relu(x, negative_slope)


# keras$ops$log_sigmoid
# keras.ops.log_sigmoid
# keras.src.ops.nn.log_sigmoid
r"-(Logarithm of the sigmoid activation function.

    It is defined as `f(x) = log(1 / (1 + exp(-x)))`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-0.541391, 0.0, 0.50, 5.0])
    >>> keras.ops.log_sigmoid(x)
    array([-1.0000418, -0.6931472, -0.474077, -0.00671535], dtype=float32)

    )-"

# keras.src.ops.nn.log_sigmoid
#' Logarithm of the sigmoid activation function.
#'
#' @description
#' It is defined as `f(x) = log(1 / (1 + exp(-x)))`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-0.541391, 0.0, 0.50, 5.0])
#' keras.ops.log_sigmoid(x)
#' # array([-1.0000418, -0.6931472, -0.474077, -0.00671535], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log_sigmoid>
k_log_sigmoid <-
function (x)
keras$ops$log_sigmoid(x)


# keras$ops$log_softmax
# keras.ops.log_softmax
# keras.src.ops.nn.log_softmax
r"-(Log-softmax activation function.

    It is defined as:
    `f(x) = x - max(x) - log(sum(exp(x - max(x))))`

    Args:
        x: Input tensor.
        axis: Integer, axis along which the log-softmax is applied.
            Defaults to `-1`.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_log_softmax = keras.ops.log_softmax(x)
    >>> print(x_log_softmax)
    array([-2.40760596, -1.40760596, -0.40760596], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.log_softmax
#' Log-softmax activation function.
#'
#' @description
#' It is defined as:
#' `f(x) = x - max(x) - log(sum(exp(x - max(x))))`
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_log_softmax = keras.ops.log_softmax(x)
#' print(x_log_softmax)
#' # array([-2.40760596, -1.40760596, -0.40760596], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#' @param axis Integer, axis along which the log-softmax is applied.
#'     Defaults to `-1`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log_softmax>
k_log_softmax <-
function (x, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$log_softmax, args)
}


# keras$ops$max_pool
# keras.ops.max_pool
# keras.src.ops.nn.max_pool
r"-(Max pooling operation.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`. Pooling happens over the spatial
            dimensions only.
        pool_size: int or tuple/list of integers of size
            `len(inputs_spatial_shape)`, specifying the size of the pooling
            window for each spatial dimension of the input tensor. If
            `pool_size` is int, then every spatial dimension shares the same
            `pool_size`.
        strides: int or tuple/list of integers of size
            `len(inputs_spatial_shape)`. The stride of the sliding window for
            each spatial dimension of the input tensor. If `strides` is int,
            then every spatial dimension shares the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.

    Returns:
        A tensor of rank N+2, the result of the max pooling operation.
    )-"

# keras.src.ops.nn.max_pool
#' Max pooling operation.
#'
#' @description
#'
#' # Returns
#'     A tensor of rank N+2, the result of the max pooling operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`. Pooling happens over the spatial
#'     dimensions only.
#' @param pool_size int or tuple/list of integers of size
#'     `len(inputs_spatial_shape)`, specifying the size of the pooling
#'     window for each spatial dimension of the input tensor. If
#'     `pool_size` is int, then every spatial dimension shares the same
#'     `pool_size`.
#' @param strides int or tuple/list of integers of size
#'     `len(inputs_spatial_shape)`. The stride of the sliding window for
#'     each spatial dimension of the input tensor. If `strides` is int,
#'     then every spatial dimension shares the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/max_pool>
k_max_pool <-
function (inputs, pool_size, strides = NULL, padding = "valid",
    data_format = NULL)
{
    args <- capture_args2(list(pool_size = as_integer, strides = as_integer))
    do.call(keras$ops$max_pool, args)
}


# keras$ops$moments
# keras.ops.moments
# keras.src.ops.nn.moments
r"-(Calculates the mean and variance of `x`.

    The mean and variance are calculated by aggregating the contents of `x`
    across `axes`. If `x` is 1-D and `axes = [0]` this is just the mean and
    variance of a vector.

    Args:
        x: Input tensor.
        axes: A list of axes which to compute mean and variance.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one.
        synchronized: Only applicable with the TensorFlow backend.
            If `True`, synchronizes the global batch statistics (mean and
            variance) across all devices at each training step in a
            distributed training strategy. If `False`, each replica uses its own
            local batch statistics.

    Returns:
        A tuple containing two tensors - mean and variance.

    Example:

    >>> x = keras.ops.convert_to_tensor([0, 1, 2, 3, 100], dtype="float32")
    >>> keras.ops.moments(x, axes=[0])
    (array(21.2, dtype=float32), array(1553.3601, dtype=float32))

    )-"

# keras.src.ops.nn.moments
#' Calculates the mean and variance of `x`.
#'
#' @description
#' The mean and variance are calculated by aggregating the contents of `x`
#' across `axes`. If `x` is 1-D and `axes = [0]` this is just the mean and
#' variance of a vector.
#'
#' # Returns
#' A tuple containing two tensors - mean and variance.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([0, 1, 2, 3, 100], dtype="float32")
#' keras.ops.moments(x, axes=[0])
#' # (array(21.2, dtype=float32), array(1553.3601, dtype=float32))
#' ```
#'
#' @param x Input tensor.
#' @param axes A list of axes which to compute mean and variance.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one.
#' @param synchronized Only applicable with the TensorFlow backend.
#'     If `True`, synchronizes the global batch statistics (mean and
#'     variance) across all devices at each training step in a
#'     distributed training strategy. If `False`, each replica uses its own
#'     local batch statistics.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/moments>
k_moments <-
function (x, axes, keepdims = FALSE, synchronized = FALSE)
{
    args <- capture_args2(list(axes = as_axis))
    do.call(keras$ops$moments, args)
}


# keras$ops$multi_hot
# keras.ops.multi_hot
# keras.src.ops.nn.multi_hot
r"-(Encodes integer labels as multi-hot vectors.

    This function encodes integer labels as multi-hot vectors, where each label
    is mapped to a binary value in the resulting vector.

    Args:
        inputs: Tensor of integer labels to be converted to multi-hot vectors.
        num_tokens: Integer, the total number of unique tokens or classes.
        axis: (optional) Axis along which the multi-hot encoding should be
            added. Defaults to `-1`, which corresponds to the last dimension.
        dtype: (optional) The data type of the resulting tensor. Default
            is backend's float type.

    Returns:
        Tensor: The multi-hot encoded tensor.

    Example:

    >>> data = keras.ops.convert_to_tensor([0, 4])
    >>> keras.ops.multi_hot(data, num_tokens=5)
    array([1.0, 0.0, 0.0, 0.0, 1.0], dtype=float32)

    )-"

# keras.src.ops.nn.multi_hot
#' Encodes integer labels as multi-hot vectors.
#'
#' @description
#' This function encodes integer labels as multi-hot vectors, where each label
#' is mapped to a binary value in the resulting vector.
#'
#' # Returns
#' Tensor: The multi-hot encoded tensor.
#'
#' # Examples
#' ```python
#' data = keras.ops.convert_to_tensor([0, 4])
#' keras.ops.multi_hot(data, num_tokens=5)
#' # array([1.0, 0.0, 0.0, 0.0, 1.0], dtype=float32)
#' ```
#'
#' @param inputs Tensor of integer labels to be converted to multi-hot vectors.
#' @param num_tokens Integer, the total number of unique tokens or classes.
#' @param axis (optional) Axis along which the multi-hot encoding should be
#'     added. Defaults to `-1`, which corresponds to the last dimension.
#' @param dtype (optional) The data type of the resulting tensor. Default
#'     is backend's float type.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/multi_hot>
k_multi_hot <-
function (inputs, num_tokens, axis = -1L, dtype = NULL)
{
    args <- capture_args2(list(inputs = as_integer, num_tokens = as_integer,
        axis = as_axis))
    do.call(keras$ops$multi_hot, args)
}


# keras$ops$one_hot
# keras.ops.one_hot
# keras.src.ops.nn.one_hot
r"-(Converts integer tensor `x` into a one-hot tensor.

    The one-hot encoding is a representation where each integer value is
    converted into a binary vector with a length equal to `num_classes`,
    and the index corresponding to the integer value is marked as 1, while
    all other indices are marked as 0.

    Args:
        x : Integer tensor to be encoded. The shape can be
            arbitrary, but the dtype should be integer.
        num_classes: Number of classes for the one-hot encoding.
        axis: Axis along which the encoding is performed. Defaults to
            `-1`, which represents the last axis.
        dtype: (Optional) Data type of the output tensor. If not
            provided, it defaults to the default data type of the backend.

    Returns:
        Integer tensor: One-hot encoded tensor with the same shape as `x`
        except for the specified `axis` dimension, which will have
        a length of `num_classes`. The dtype of the output tensor
        is determined by `dtype` or the default data type of the backend.

    Example:

    >>> x = keras.ops.convert_to_tensor([1, 3, 2, 0])
    >>> one_hot(x, num_classes=4)
    array([[0. 1. 0. 0.]
           [0. 0. 0. 1.]
           [0. 0. 1. 0.]
           [1. 0. 0. 0.]], shape=(4, 4), dtype=float32)
    )-"

# keras.src.ops.nn.one_hot
#' Converts integer tensor `x` into a one-hot tensor.
#'
#' @description
#' The one-hot encoding is a representation where each integer value is
#' converted into a binary vector with a length equal to `num_classes`,
#' and the index corresponding to the integer value is marked as 1, while
#' all other indices are marked as 0.
#'
#' # Returns
#' Integer tensor: One-hot encoded tensor with the same shape as `x`
#' except for the specified `axis` dimension, which will have
#' a length of `num_classes`. The dtype of the output tensor
#' is determined by `dtype` or the default data type of the backend.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, 3, 2, 0])
#' one_hot(x, num_classes=4)
#' # array([[0. 1. 0. 0.]
#' #        [0. 0. 0. 1.]
#' #        [0. 0. 1. 0.]
#' #        [1. 0. 0. 0.]], shape=(4, 4), dtype=float32)
#' ```
#'
#' @param x Integer tensor to be encoded. The shape can be
#'     arbitrary, but the dtype should be integer.
#' @param num_classes Number of classes for the one-hot encoding.
#' @param axis Axis along which the encoding is performed. Defaults to
#'     `-1`, which represents the last axis.
#' @param dtype (Optional) Data type of the output tensor. If not
#'     provided, it defaults to the default data type of the backend.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/one_hot>
k_one_hot <-
function (x, num_classes, axis = -1L, dtype = NULL)
{
    args <- capture_args2(list(x = as_integer, axis = as_axis))
    do.call(keras$ops$one_hot, args)
}


# keras$ops$relu
# keras.ops.relu
# keras.src.ops.nn.relu
r"-(Rectified linear unit activation function.

    It is defined as `f(x) = max(0, x)`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x1 = keras.ops.convert_to_tensor([-1.0, 0.0, 1.0, 0.2])
    >>> keras.ops.relu(x1)
    array([0.0, 0.0, 1.0, 0.2], dtype=float32)
    )-"

# keras.src.ops.nn.relu
#' Rectified linear unit activation function.
#'
#' @description
#' It is defined as `f(x) = max(0, x)`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x1 = keras.ops.convert_to_tensor([-1.0, 0.0, 1.0, 0.2])
#' keras.ops.relu(x1)
#' # array([0.0, 0.0, 1.0, 0.2], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/relu>
k_relu <-
function (x)
keras$ops$relu(x)


# keras$ops$relu6
# keras.ops.relu6
# keras.src.ops.nn.relu6
r"-(Rectified linear unit activation function with upper bound of 6.

    It is defined as `f(x) = np.clip(x, 0, 6)`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-3.0, -2.0, 0.1, 0.2, 6.0, 8.0])
    >>> keras.ops.relu6(x)
    array([0.0, 0.0, 0.1, 0.2, 6.0, 6.0], dtype=float32)
    )-"

# keras.src.ops.nn.relu6
#' Rectified linear unit activation function with upper bound of 6.
#'
#' @description
#' It is defined as `f(x) = np.clip(x, 0, 6)`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-3.0, -2.0, 0.1, 0.2, 6.0, 8.0])
#' keras.ops.relu6(x)
#' # array([0.0, 0.0, 0.1, 0.2, 6.0, 6.0], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/relu6>
k_relu6 <-
function (x)
keras$ops$relu6(x)


# keras$ops$selu
# keras.ops.selu
# keras.src.ops.nn.selu
r"-(Scaled Exponential Linear Unit (SELU) activation function.

    It is defined as:

    `f(x) =  scale * alpha * (exp(x) - 1.) for x < 0`,
    `f(x) = scale * x for x >= 0`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_selu = keras.ops.selu(x)
    >>> print(x_selu)
    array([-1.11133055, 0., 1.05070098], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.selu
#' Scaled Exponential Linear Unit (SELU) activation function.
#'
#' @description
#' It is defined as:
#'
#' `f(x) =  scale * alpha * (exp(x) - 1.) for x < 0`,
#' `f(x) = scale * x for x >= 0`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_selu = keras.ops.selu(x)
#' print(x_selu)
#' # array([-1.11133055, 0., 1.05070098], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/selu>
k_selu <-
function (x)
keras$ops$selu(x)


# keras$ops$separable_conv
# keras.ops.separable_conv
# keras.src.ops.nn.separable_conv
r"-(General N-D separable convolution.

    This ops supports 1D and 2D separable convolution. `separable_conv` is
    a depthwise conv followed by a pointwise conv.

    Args:
        inputs: Tensor of rank N+2. `inputs` has shape
            `(batch_size,)` + inputs_spatial_shape + (num_channels,)` if
            `data_format="channels_last"`, or
            `(batch_size, num_channels) + inputs_spatial_shape` if
            `data_format="channels_first"`.
        depthwise_kernel: Tensor of rank N+2. `depthwise_kernel` has shape
            [kernel_spatial_shape, num_input_channels, num_channels_multiplier],
            `num_input_channels` should match the number of channels in
            `inputs`.
        pointwise_kernel: Tensor of rank N+2. `pointwise_kernel` has shape
            `(*ones_like(kernel_spatial_shape),
            num_input_channels * num_channels_multiplier, num_output_channels)`.
        strides: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the strides of the convolution along each spatial
            dimension. If `strides` is int, then every spatial dimension shares
            the same `strides`.
        padding: string, either `"valid"` or `"same"`. `"valid"` means no
            padding is applied, and `"same"` results in padding evenly to the
            left/right or up/down of the input such that output has the
            same height/width dimension as the input when `strides=1`.
        data_format: A string, either `"channels_last"` or `"channels_first"`.
            `data_format` determines the ordering of the dimensions in the
            inputs. If `data_format="channels_last"`, `inputs` is of shape
            `(batch_size, ..., channels)` while if
            `data_format="channels_first"`, `inputs` is of shape
            `(batch_size, channels, ...)`.
        dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,
            specifying the dilation rate to use for dilated convolution. If
            `dilation_rate` is int, then every spatial dimension shares
            the same `dilation_rate`.

    Returns:
        A tensor of rank N+2, the result of the depthwise conv operation.
    )-"

# keras.src.ops.nn.separable_conv
#' General N-D separable convolution.
#'
#' @description
#' This ops supports 1D and 2D separable convolution. `separable_conv` is
#' a depthwise conv followed by a pointwise conv.
#'
#' # Returns
#'     A tensor of rank N+2, the result of the depthwise conv operation.
#'
#' @param inputs Tensor of rank N+2. `inputs` has shape
#'     `(batch_size,) + inputs_spatial_shape + (num_channels,)` if
#'     `data_format="channels_last"`, or
#'     `(batch_size, num_channels) + inputs_spatial_shape` if
#'     `data_format="channels_first"`.
#' @param depthwise_kernel Tensor of rank N+2. `depthwise_kernel` has shape
#'     `[kernel_spatial_shape, num_input_channels, num_channels_multiplier],`
#'     `num_input_channels` should match the number of channels in
#'     `inputs`.
#' @param pointwise_kernel Tensor of rank N+2. `pointwise_kernel` has shape
#'     `(*ones_like(kernel_spatial_shape),
#'     num_input_channels * num_channels_multiplier, num_output_channels)`.
#' @param strides int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the strides of the convolution along each spatial
#'     dimension. If `strides` is int, then every spatial dimension shares
#'     the same `strides`.
#' @param padding string, either `"valid"` or `"same"`. `"valid"` means no
#'     padding is applied, and `"same"` results in padding evenly to the
#'     left/right or up/down of the input such that output has the
#'     same height/width dimension as the input when `strides=1`.
#' @param data_format A string, either `"channels_last"` or `"channels_first"`.
#'     `data_format` determines the ordering of the dimensions in the
#'     inputs. If `data_format="channels_last"`, `inputs` is of shape
#'     `(batch_size, ..., channels)` while if
#'     `data_format="channels_first"`, `inputs` is of shape
#'     `(batch_size, channels, ...)`.
#' @param dilation_rate int or int tuple/list of `len(inputs_spatial_shape)`,
#'     specifying the dilation rate to use for dilated convolution. If
#'     `dilation_rate` is int, then every spatial dimension shares
#'     the same `dilation_rate`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/separable_conv>
k_separable_conv <-
function (inputs, depthwise_kernel, pointwise_kernel, strides = 1L,
    padding = "valid", data_format = NULL, dilation_rate = 1L)
{
    args <- capture_args2(list(strides = as_integer, dilation_rate = as_integer))
    do.call(keras$ops$separable_conv, args)
}


# keras$ops$sigmoid
# keras.ops.sigmoid
# keras.src.ops.nn.sigmoid
r"-(Sigmoid activation function.

    It is defined as `f(x) = 1 / (1 + exp(-x))`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-6.0, 1.0, 0.0, 1.0, 6.0])
    >>> keras.ops.sigmoid(x)
    array([0.00247262, 0.7310586, 0.5, 0.7310586, 0.9975274], dtype=float32)

    )-"

# keras.src.ops.nn.sigmoid
#' Sigmoid activation function.
#'
#' @description
#' It is defined as `f(x) = 1 / (1 + exp(-x))`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-6.0, 1.0, 0.0, 1.0, 6.0])
#' keras.ops.sigmoid(x)
#' # array([0.00247262, 0.7310586, 0.5, 0.7310586, 0.9975274], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sigmoid>
k_sigmoid <-
function (x)
keras$ops$sigmoid(x)


# keras$ops$silu
# keras.ops.silu
# keras.src.ops.nn.silu
r"-(Sigmoid Linear Unit (SiLU) activation function, also known as Swish.

    The SiLU activation function is computed by the sigmoid function multiplied
    by its input. It is defined as `f(x) = x * sigmoid(x)`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-6.0, 1.0, 0.0, 1.0, 6.0])
    >>> keras.ops.sigmoid(x)
    array([0.00247262, 0.7310586, 0.5, 0.7310586, 0.9975274], dtype=float32)
    >>> keras.ops.silu(x)
    array([-0.0148357, 0.7310586, 0.0, 0.7310586, 5.9851646], dtype=float32)

    )-"

# keras.src.ops.nn.silu
#' Sigmoid Linear Unit (SiLU) activation function, also known as Swish.
#'
#' @description
#' The SiLU activation function is computed by the sigmoid function multiplied
#' by its input. It is defined as `f(x) = x * sigmoid(x)`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-6.0, 1.0, 0.0, 1.0, 6.0])
#' keras.ops.sigmoid(x)
#' # array([0.00247262, 0.7310586, 0.5, 0.7310586, 0.9975274], dtype=float32)
#' keras.ops.silu(x)
#' # array([-0.0148357, 0.7310586, 0.0, 0.7310586, 5.9851646], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/silu>
k_silu <-
function (x)
keras$ops$silu(x)


# keras$ops$softmax
# keras.ops.softmax
# keras.src.ops.nn.softmax
r"-(Softmax activation function.

    The elements of the output vector lie within the range `(0, 1)`, and their
    total sum is exactly 1 (excluding the floating point rounding error).

    Each vector is processed independently. The `axis` argument specifies the
    axis along which the function is applied within the input.

    It is defined as:
    `f(x) = exp(x) / sum(exp(x))`

    Args:
        x: Input tensor.
        axis: Integer, axis along which the softmax is applied.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = np.array([-1., 0., 1.])
    >>> x_softmax = keras.ops.softmax(x)
    >>> print(x_softmax)
    array([0.09003057, 0.24472847, 0.66524096], shape=(3,), dtype=float64)

    )-"

# keras.src.ops.nn.softmax
#' Softmax activation function.
#'
#' @description
#' The elements of the output vector lie within the range `(0, 1)`, and their
#' total sum is exactly 1 (excluding the floating point rounding error).
#'
#' Each vector is processed independently. The `axis` argument specifies the
#' axis along which the function is applied within the input.
#'
#' It is defined as:
#' `f(x) = exp(x) / sum(exp(x))`
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([-1., 0., 1.])
#' x_softmax = keras.ops.softmax(x)
#' print(x_softmax)
#' # array([0.09003057, 0.24472847, 0.66524096], shape=(3,), dtype=float64)
#' ```
#'
#' @param x Input tensor.
#' @param axis Integer, axis along which the softmax is applied.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/softmax>
k_softmax <-
function (x, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$softmax, args)
}


# keras$ops$softplus
# keras.ops.softplus
# keras.src.ops.nn.softplus
r"-(Softplus activation function.

    It is defined as `f(x) = log(exp(x) + 1)`, where `log` is the natural
    logarithm and `exp` is the exponential function.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-0.555, 0.0, 0.555])
    >>> keras.ops.softplus(x)
    array([0.45366603, 0.6931472, 1.008666], dtype=float32)

    )-"

# keras.src.ops.nn.softplus
#' Softplus activation function.
#'
#' @description
#' It is defined as `f(x) = log(exp(x) + 1)`, where `log` is the natural
#' logarithm and `exp` is the exponential function.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-0.555, 0.0, 0.555])
#' keras.ops.softplus(x)
#' # array([0.45366603, 0.6931472, 1.008666], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/softplus>
k_softplus <-
function (x)
keras$ops$softplus(x)


# keras$ops$softsign
# keras.ops.softsign
# keras.src.ops.nn.softsign
r"-(Softsign activation function.

    It is defined as `f(x) = x / (abs(x) + 1)`.

    Args:
        x: Input tensor.

    Returns:
        A tensor with the same shape as `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-0.100, -10.0, 1.0, 0.0, 100.0])
    >>> keras.ops.softsign(x)
    Array([-0.09090909, -0.90909094, 0.5, 0.0, 0.990099], dtype=float32)

    )-"

# keras.src.ops.nn.softsign
#' Softsign activation function.
#'
#' @description
#' It is defined as `f(x) = x / (abs(x) + 1)`.
#'
#' # Returns
#' A tensor with the same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-0.100, -10.0, 1.0, 0.0, 100.0])
#' keras.ops.softsign(x)
#' # Array([-0.09090909, -0.90909094, 0.5, 0.0, 0.990099], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/softsign>
k_softsign <-
function (x)
keras$ops$softsign(x)


# keras$ops$sparse_categorical_crossentropy
# keras.ops.sparse_categorical_crossentropy
# keras.src.ops.nn.sparse_categorical_crossentropy
r"-(Computes sparse categorical cross-entropy loss.

    The sparse categorical cross-entropy loss is similar to categorical
    cross-entropy, but it is used when the target tensor contains integer
    class labels instead of one-hot encoded vectors. It measures the
    dissimilarity between the target and output probabilities or logits.

    Args:
        target: The target tensor representing the true class labels as
            integers. Its shape should match the shape of the `output`
            tensor except for the last dimension.
        output: The output tensor representing the predicted probabilities
            or logits.
            Its shape should match the shape of the `target` tensor except
            for the last dimension.
        from_logits: (optional) Whether `output` is a tensor of logits
            or probabilities.
            Set it to `True` if `output` represents logits; otherwise,
            set it to `False` if `output` represents probabilities.
            Defaults to`False`.
        axis: (optional) The axis along which the sparse categorical
            cross-entropy is computed.
            Defaults to `-1`, which corresponds to the last dimension
            of the tensors.

    Returns:
        Integer tensor: The computed sparse categorical cross-entropy
        loss between `target` and `output`.

    Example:

    >>> target = keras.ops.convert_to_tensor([0, 1, 2], dtype=int32)
    >>> output = keras.ops.convert_to_tensor(
    ... [[0.9, 0.05, 0.05],
    ...  [0.1, 0.8, 0.1],
    ...  [0.2, 0.3, 0.5]])
    >>> sparse_categorical_crossentropy(target, output)
    array([0.10536056 0.22314355 0.6931472 ], shape=(3,), dtype=float32)
    )-"

# keras.src.ops.nn.sparse_categorical_crossentropy
#' Computes sparse categorical cross-entropy loss.
#'
#' @description
#' The sparse categorical cross-entropy loss is similar to categorical
#' cross-entropy, but it is used when the target tensor contains integer
#' class labels instead of one-hot encoded vectors. It measures the
#' dissimilarity between the target and output probabilities or logits.
#'
#' # Returns
#' Integer tensor: The computed sparse categorical cross-entropy
#' loss between `target` and `output`.
#'
#' # Examples
#' ```python
#' target = keras.ops.convert_to_tensor([0, 1, 2], dtype=int32)
#' output = keras.ops.convert_to_tensor(
#' [[0.9, 0.05, 0.05],
#'  [0.1, 0.8, 0.1],
#'  [0.2, 0.3, 0.5]])
#' sparse_categorical_crossentropy(target, output)
#' # array([0.10536056 0.22314355 0.6931472 ], shape=(3,), dtype=float32)
#' ```
#'
#' @param target The target tensor representing the true class labels as
#'     integers. Its shape should match the shape of the `output`
#'     tensor except for the last dimension.
#' @param output The output tensor representing the predicted probabilities
#'     or logits.
#'     Its shape should match the shape of the `target` tensor except
#'     for the last dimension.
#' @param from_logits (optional) Whether `output` is a tensor of logits
#'     or probabilities.
#'     Set it to `True` if `output` represents logits; otherwise,
#'     set it to `False` if `output` represents probabilities.
#'     Defaults to`False`.
#' @param axis (optional) The axis along which the sparse categorical
#'     cross-entropy is computed.
#'     Defaults to `-1`, which corresponds to the last dimension
#'     of the tensors.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sparse_categorical_crossentropy>
k_sparse_categorical_crossentropy <-
function (target, output, from_logits = FALSE, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$sparse_categorical_crossentropy, args)
}


# keras$ops$abs
# keras.ops.abs
# keras.src.ops.numpy.abs
r"-(Shorthand for `keras.ops.absolute`.)-"

# keras.src.ops.numpy.abs
#' Shorthand for `keras.ops.absolute`.
#'
#' @param x see description
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/abs>
k_abs <-
function (x)
keras$ops$abs(x)


# keras$ops$absolute
# keras.ops.absolute
# keras.src.ops.numpy.absolute
r"-(Compute the absolute value element-wise.

    `keras.ops.abs` is a shorthand for this function.

    Args:
        x: Input tensor.

    Returns:
        An array containing the absolute value of each element in `x`.

    Example:

    >>> x = keras.ops.convert_to_tensor([-1.2, 1.2])
    >>> keras.ops.absolute(x)
    array([1.2, 1.2], dtype=float32)
    )-"

# keras.src.ops.numpy.absolute
#' Compute the absolute value element-wise.
#'
#' @description
#' `keras.ops.abs` is a shorthand for this function.
#'
#' # Returns
#' An array containing the absolute value of each element in `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([-1.2, 1.2])
#' keras.ops.absolute(x)
#' # array([1.2, 1.2], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/absolute>
k_absolute <-
function (x)
keras$ops$absolute(x)


# keras$ops$add
# keras.ops.add
# keras.src.ops.numpy.add
r"-(Add arguments element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        The tensor containing the element-wise sum of `x1` and `x2`.

    Examples:
    >>> x1 = keras.ops.convert_to_tensor([1, 4])
    >>> x2 = keras.ops.convert_to_tensor([5, 6])
    >>> keras.ops.add(x1, x2)
    array([6, 10], dtype=int32)

    `keras.ops.add` also broadcasts shapes:
    >>> x1 = keras.ops.convert_to_tensor(
    ...     [[5, 4],
    ...      [5, 6]]
    ... )
    >>> x2 = keras.ops.convert_to_tensor([5, 6])
    >>> keras.ops.add(x1, x2)
    array([[10 10]
           [10 12]], shape=(2, 2), dtype=int32)
    )-"

# keras.src.ops.numpy.add
#' Add arguments element-wise.
#'
#' @description
#'
#' # Returns
#' The tensor containing the element-wise sum of `x1` and `x2`.
#'
#' # Examples
#' ```python
#' x1 = keras.ops.convert_to_tensor([1, 4])
#' x2 = keras.ops.convert_to_tensor([5, 6])
#' keras.ops.add(x1, x2)
#' # array([6, 10], dtype=int32)
#' ```
#'
#' `keras.ops.add` also broadcasts shapes:
#' ```python
#' x1 = keras.ops.convert_to_tensor(
#'     [[5, 4],
#'      [5, 6]]
#' )
#' x2 = keras.ops.convert_to_tensor([5, 6])
#' keras.ops.add(x1, x2)
#' # array([[10 10]
#' #        [10 12]], shape=(2, 2), dtype=int32)
#' ```
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/add>
k_add <-
function (x1, x2)
keras$ops$add(x1, x2)


# keras$ops$all
# keras.ops.all
# keras.src.ops.numpy.all
r"-(Test whether all array elements along a given axis evaluate to `True`.

    Args:
        x: Input tensor.
        axis: An integer or tuple of integers that represent the axis along
            which a logical AND reduction is performed. The default
            (`axis=None`) is to perform a logical AND over all the dimensions
            of the input array. `axis` may be negative, in which case it counts
            for the last to the first axis.
        keepdims: If `True`, axes which are reduced are left in the result as
            dimensions with size one. With this option, the result will
            broadcast correctly against the input array. Defaults to`False`.

    Returns:
        The tensor containing the logical AND reduction over the `axis`.

    Examples:
    >>> x = keras.ops.convert_to_tensor([True, False])
    >>> keras.ops.all(x)
    array(False, shape=(), dtype=bool)

    >>> x = keras.ops.convert_to_tensor([[True, False], [True, True]])
    >>> keras.ops.all(x, axis=0)
    array([ True False], shape=(2,), dtype=bool)

    `keepdims=True` outputs a tensor with dimensions reduced to one.
    >>> x = keras.ops.convert_to_tensor([[True, False], [True, True]])
    >>> keras.ops.all(x, keepdims=True)
    array([[False]], shape=(1, 1), dtype=bool)
    )-"

# keras.src.ops.numpy.all
#' Test whether all array elements along a given axis evaluate to `True`.
#'
#' @description
#'
#' # Returns
#' The tensor containing the logical AND reduction over the `axis`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([True, False])
#' keras.ops.all(x)
#' # array(False, shape=(), dtype=bool)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[True, False], [True, True]])
#' keras.ops.all(x, axis=0)
#' # array([ True False], shape=(2,), dtype=bool)
#' ```
#'
#' `keepdims=True` outputs a tensor with dimensions reduced to one.
#' ```python
#' x = keras.ops.convert_to_tensor([[True, False], [True, True]])
#' keras.ops.all(x, keepdims=True)
#' # array([[False]], shape=(1, 1), dtype=bool)
#' ```
#'
#' @param x Input tensor.
#' @param axis An integer or tuple of integers that represent the axis along
#'     which a logical AND reduction is performed. The default
#'     (`axis=None`) is to perform a logical AND over all the dimensions
#'     of the input array. `axis` may be negative, in which case it counts
#'     for the last to the first axis.
#' @param keepdims If `True`, axes which are reduced are left in the result as
#'     dimensions with size one. With this option, the result will
#'     broadcast correctly against the input array. Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/all>
k_all <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$all, args)
}


# keras$ops$amax
# keras.ops.amax
# keras.src.ops.numpy.amax
r"-(Returns the maximum of an array or maximum value along an axis.

    Args:
        x: Input tensor.
        axis: Axis along which to compute the maximum.
            By default (`axis=None`), find the maximum value in all the
            dimensions of the input array.
        keepdims: If `True`, axes which are reduced are left in the result as
            dimensions that are broadcast to the size of the original
            input tensor. Defaults to `False`.

    Returns:
        An array with the maximum value. If `axis=None`, the result is a scalar
        value representing the maximum element in the entire array. If `axis` is
        given, the result is an array with the maximum values along
        the specified axis.

    Examples:
    >>> x = keras.ops.convert_to_tensor([[1, 3, 5], [2, 3, 6]])
    >>> keras.ops.amax(x)
    array(6, dtype=int32)

    >>> x = keras.ops.convert_to_tensor([[1, 6, 8], [1, 5, 2]])
    >>> keras.ops.amax(x, axis=0)
    array([1, 6, 8], dtype=int32)

    >>> x = keras.ops.convert_to_tensor([[1, 6, 8], [1, 5, 2]])
    >>> keras.ops.amax(x, axis=1, keepdims=True)
    array([[8], [5]], dtype=int32)
    )-"

# keras.src.ops.numpy.amax
#' Returns the maximum of an array or maximum value along an axis.
#'
#' @description
#'
#' # Returns
#' An array with the maximum value. If `axis=None`, the result is a scalar
#' value representing the maximum element in the entire array. If `axis` is
#' given, the result is an array with the maximum values along
#' the specified axis.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([[1, 3, 5], [2, 3, 6]])
#' keras.ops.amax(x)
#' # array(6, dtype=int32)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[1, 6, 8], [1, 5, 2]])
#' keras.ops.amax(x, axis=0)
#' # array([1, 6, 8], dtype=int32)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[1, 6, 8], [1, 5, 2]])
#' keras.ops.amax(x, axis=1, keepdims=True)
#' # array([[8], [5]], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param axis Axis along which to compute the maximum.
#'     By default (`axis=None`), find the maximum value in all the
#'     dimensions of the input array.
#' @param keepdims If `True`, axes which are reduced are left in the result as
#'     dimensions that are broadcast to the size of the original
#'     input tensor. Defaults to `False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/amax>
k_amax <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$amax, args)
}


# keras$ops$amin
# keras.ops.amin
# keras.src.ops.numpy.amin
r"-(Returns the minimum of an array or minimum value along an axis.

    Args:
        x: Input tensor.
        axis: Axis along which to compute the minimum.
            By default (`axis=None`), find the minimum value in all the
            dimensions of the input array.
        keepdims: If `True`, axes which are reduced are left in the result as
            dimensions that are broadcast to the size of the original
            input tensor. Defaults to `False`.

    Returns:
        An array with the minimum value. If `axis=None`, the result is a scalar
        value representing the minimum element in the entire array. If `axis` is
        given, the result is an array with the minimum values along
        the specified axis.

    Examples:
    >>> x = keras.ops.convert_to_tensor([1, 3, 5, 2, 3, 6])
    >>> keras.ops.amin(x)
    array(1, dtype=int32)

    >>> x = keras.ops.convert_to_tensor([[1, 6, 8], [7, 5, 3]])
    >>> keras.ops.amin(x, axis=0)
    array([1,5,3], dtype=int32)

    >>> x = keras.ops.convert_to_tensor([[1, 6, 8], [7, 5, 3]])
    >>> keras.ops.amin(x, axis=1, keepdims=True)
    array([[1],[3]], dtype=int32)
    )-"

# keras.src.ops.numpy.amin
#' Returns the minimum of an array or minimum value along an axis.
#'
#' @description
#'
#' # Returns
#' An array with the minimum value. If `axis=None`, the result is a scalar
#' value representing the minimum element in the entire array. If `axis` is
#' given, the result is an array with the minimum values along
#' the specified axis.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, 3, 5, 2, 3, 6])
#' keras.ops.amin(x)
#' # array(1, dtype=int32)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[1, 6, 8], [7, 5, 3]])
#' keras.ops.amin(x, axis=0)
#' # array([1,5,3], dtype=int32)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[1, 6, 8], [7, 5, 3]])
#' keras.ops.amin(x, axis=1, keepdims=True)
#' # array([[1],[3]], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param axis Axis along which to compute the minimum.
#'     By default (`axis=None`), find the minimum value in all the
#'     dimensions of the input array.
#' @param keepdims If `True`, axes which are reduced are left in the result as
#'     dimensions that are broadcast to the size of the original
#'     input tensor. Defaults to `False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/amin>
k_amin <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$amin, args)
}


# keras$ops$any
# keras.ops.any
# keras.src.ops.numpy.any
r"-(Test whether any array element along a given axis evaluates to `True`.

    Args:
        x: Input tensor.
        axis: An integer or tuple of integers that represent the axis along
            which a logical OR reduction is performed. The default
            (`axis=None`) is to perform a logical OR over all the dimensions
            of the input array. `axis` may be negative, in which case it counts
            for the last to the first axis.
        keepdims: If `True`, axes which are reduced are left in the result as
            dimensions with size one. With this option, the result will
            broadcast correctly against the input array. Defaults to`False`.

    Returns:
        The tensor containing the logical OR reduction over the `axis`.

    Examples:
    >>> x = keras.ops.convert_to_tensor([True, False])
    >>> keras.ops.any(x)
    array(True, shape=(), dtype=bool)

    >>> x = keras.ops.convert_to_tensor([[True, False], [True, True]])
    >>> keras.ops.any(x, axis=0)
    array([ True  True], shape=(2,), dtype=bool)

    `keepdims=True` outputs a tensor with dimensions reduced to one.
    >>> x = keras.ops.convert_to_tensor([[True, False], [True, True]])
    >>> keras.ops.all(x, keepdims=True)
    array([[False]], shape=(1, 1), dtype=bool)
    )-"

# keras.src.ops.numpy.any
#' Test whether any array element along a given axis evaluates to `True`.
#'
#' @description
#'
#' # Returns
#' The tensor containing the logical OR reduction over the `axis`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([True, False])
#' keras.ops.any(x)
#' # array(True, shape=(), dtype=bool)
#' ```
#'
#' ```python
#' x = keras.ops.convert_to_tensor([[True, False], [True, True]])
#' keras.ops.any(x, axis=0)
#' # array([ True  True], shape=(2,), dtype=bool)
#' ```
#'
#' `keepdims=True` outputs a tensor with dimensions reduced to one.
#' ```python
#' x = keras.ops.convert_to_tensor([[True, False], [True, True]])
#' keras.ops.all(x, keepdims=True)
#' # array([[False]], shape=(1, 1), dtype=bool)
#' ```
#'
#' @param x Input tensor.
#' @param axis An integer or tuple of integers that represent the axis along
#'     which a logical OR reduction is performed. The default
#'     (`axis=None`) is to perform a logical OR over all the dimensions
#'     of the input array. `axis` may be negative, in which case it counts
#'     for the last to the first axis.
#' @param keepdims If `True`, axes which are reduced are left in the result as
#'     dimensions with size one. With this option, the result will
#'     broadcast correctly against the input array. Defaults to`False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/any>
k_any <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$any, args)
}


# keras$ops$append
# keras.ops.append
# keras.src.ops.numpy.append
r"-(Append tensor `x2` to the end of tensor `x1`.

    Args:
        x1: First input tensor.
        x2: Second input tensor.
        axis: Axis along which tensor `x2` is appended to tensor `x1`.
            If `None`, both tensors are flattened before use.

    Returns:
        A tensor with the values of `x2` appended to `x1`.

    Examples:
    >>> x1 = keras.ops.convert_to_tensor([1, 2, 3])
    >>> x2 = keras.ops.convert_to_tensor([[4, 5, 6], [7, 8, 9]])
    >>> keras.ops.append(x1, x2)
    array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32)

    When `axis` is specified, `x1` and `x2` must have compatible shapes.
    >>> x1 = keras.ops.convert_to_tensor([[1, 2, 3], [4, 5, 6]])
    >>> x2 = keras.ops.convert_to_tensor([[7, 8, 9]])
    >>> keras.ops.append(x1, x2, axis=0)
    array([[1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]], dtype=int32)
    >>> x3 = keras.ops.convert_to_tensor([7, 8, 9])
    >>> keras.ops.append(x1, x3, axis=0)
    Traceback (most recent call last):
        ...
    TypeError: Cannot concatenate arrays with different numbers of
    dimensions: got (2, 3), (3,).
    )-"

# keras.src.ops.numpy.append
#' Append tensor `x2` to the end of tensor `x1`.
#'
#' @description
#'
#' # Returns
#' A tensor with the values of `x2` appended to `x1`.
#'
#' # Examples
#' ```python
#' x1 = keras.ops.convert_to_tensor([1, 2, 3])
#' x2 = keras.ops.convert_to_tensor([[4, 5, 6], [7, 8, 9]])
#' keras.ops.append(x1, x2)
#' # array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32)
#' ```
#'
#' When `axis` is specified, `x1` and `x2` must have compatible shapes.
#' ```python
#' x1 = keras.ops.convert_to_tensor([[1, 2, 3], [4, 5, 6]])
#' x2 = keras.ops.convert_to_tensor([[7, 8, 9]])
#' keras.ops.append(x1, x2, axis=0)
#' # array([[1, 2, 3],
#' #         [4, 5, 6],
#' #         [7, 8, 9]], dtype=int32)
#' x3 = keras.ops.convert_to_tensor([7, 8, 9])
#' keras.ops.append(x1, x3, axis=0)
#' # Traceback (most recent call last):
#' #     ...
#' # TypeError: Cannot concatenate arrays with different numbers of
#' # dimensions: got (2, 3), (3,).
#' ```
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#' @param axis Axis along which tensor `x2` is appended to tensor `x1`.
#'     If `None`, both tensors are flattened before use.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/append>
k_append <-
function (x1, x2, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$append, args)
}


# keras$ops$arange
# keras.ops.arange
# keras.src.ops.numpy.arange
r"-(Return evenly spaced values within a given interval.

    `arange` can be called with a varying number of positional arguments:
    * `arange(stop)`: Values are generated within the half-open interval
        `[0, stop)` (in other words, the interval including start but excluding
        stop).
    * `arange(start, stop)`: Values are generated within the half-open interval
        `[start, stop)`.
    * `arange(start, stop, step)`: Values are generated within the half-open
        interval `[start, stop)`, with spacing between values given by step.

    Args:
        start: Integer or real, representing the start of the interval. The
            interval includes this value.
        stop: Integer or real, representing the end of the interval. The
            interval does not include this value, except in some cases where
            `step` is not an integer and floating point round-off affects the
            lenght of `out`. Defaults to `None`.
        step: Integer or real, represent the spacing between values. For any
            output `out`, this is the distance between two adjacent values,
            `out[i+1] - out[i]`. The default step size is 1. If `step` is
            specified as a position argument, `start` must also be given.
        dtype: The type of the output array. If `dtype` is not given, infer the
            data type from the other input arguments.

    Returns:
        Tensor of evenly spaced values.
        For floating point arguments, the length of the result is
        `ceil((stop - start)/step)`. Because of floating point overflow, this
        rule may result in the last element of out being greater than stop.

    Examples:
    >>> keras.ops.arange(3)
    array([0, 1, 2], dtype=int32)

    >>> keras.ops.arange(3.0)
    array([0., 1., 2.], dtype=float32)

    >>> keras.ops.arange(3, 7)
    array([3, 4, 5, 6], dtype=int32)

    >>> keras.ops.arange(3, 7, 2)
    array([3, 5], dtype=int32)
    )-"

# keras.src.ops.numpy.arange
#' Return evenly spaced values within a given interval.
#'
#' @description
#' `arange` can be called with a varying number of positional arguments:
#' * `arange(stop)`: Values are generated within the half-open interval
#'     `[0, stop)` (in other words, the interval including start but excluding
#'     stop).
#' * `arange(start, stop)`: Values are generated within the half-open interval
#'     `[start, stop)`.
#' * `arange(start, stop, step)`: Values are generated within the half-open
#'     interval `[start, stop)`, with spacing between values given by step.
#'
#' # Returns
#' Tensor of evenly spaced values.
#' For floating point arguments, the length of the result is
#' `ceil((stop - start)/step)`. Because of floating point overflow, this
#' rule may result in the last element of out being greater than stop.
#'
#' # Examples
#' ```python
#' keras.ops.arange(3)
#' # array([0, 1, 2], dtype=int32)
#' ```
#'
#' ```python
#' keras.ops.arange(3.0)
#' # array([0., 1., 2.], dtype=float32)
#' ```
#'
#' ```python
#' keras.ops.arange(3, 7)
#' # array([3, 4, 5, 6], dtype=int32)
#' ```
#'
#' ```python
#' keras.ops.arange(3, 7, 2)
#' # array([3, 5], dtype=int32)
#' ```
#'
#' @param start Integer or real, representing the start of the interval. The
#'     interval includes this value.
#' @param stop Integer or real, representing the end of the interval. The
#'     interval does not include this value, except in some cases where
#'     `step` is not an integer and floating point round-off affects the
#'     lenght of `out`. Defaults to `None`.
#' @param step Integer or real, represent the spacing between values. For any
#'     output `out`, this is the distance between two adjacent values,
#'     `out[i+1] - out[i]`. The default step size is 1. If `step` is
#'     specified as a position argument, `start` must also be given.
#' @param dtype The type of the output array. If `dtype` is not given, infer the
#'     data type from the other input arguments.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arange>
k_arange <-
function (start, stop = NULL, step = 1L, dtype = NULL)
{
    args <- capture_args2(list(start = as_integer, stop = as_integer,
        step = as_integer))
    do.call(keras$ops$arange, args)
}


# keras$ops$arccos
# keras.ops.arccos
# keras.src.ops.numpy.arccos
r"-(Trigonometric inverse cosine, element-wise.

    The inverse of `cos` so that, if `y = cos(x)`, then `x = arccos(y)`.

    Args:
        x: Input tensor.

    Returns:
        Tensor of the angle of the ray intersecting the unit circle at the given
        x-coordinate in radians `[0, pi]`.

    Example:
    >>> x = keras.ops.convert_to_tensor([1, -1])
    >>> keras.ops.arccos(x)
    array([0.0, 3.1415927], dtype=float32)
    )-"

# keras.src.ops.numpy.arccos
#' Trigonometric inverse cosine, element-wise.
#'
#' @description
#' The inverse of `cos` so that, if `y = cos(x)`, then `x = arccos(y)`.
#'
#' # Returns
#' Tensor of the angle of the ray intersecting the unit circle at the given
#' x-coordinate in radians `[0, pi]`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, -1])
#' keras.ops.arccos(x)
#' # array([0.0, 3.1415927], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arccos>
k_arccos <-
function (x)
keras$ops$arccos(x)


# keras$ops$arccosh
# keras.ops.arccosh
# keras.src.ops.numpy.arccosh
r"-(Inverse hyperbolic cosine, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as x.

    Example:
    >>> x = keras.ops.convert_to_tensor([10, 100])
    >>> keras.ops.arccosh(x)
    array([2.993223, 5.298292], dtype=float32)
    )-"

# keras.src.ops.numpy.arccosh
#' Inverse hyperbolic cosine, element-wise.
#'
#' @description
#'
#' # Returns
#' Output tensor of same shape as x.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([10, 100])
#' keras.ops.arccosh(x)
#' # array([2.993223, 5.298292], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arccosh>
k_arccosh <-
function (x)
keras$ops$arccosh(x)


# keras$ops$arcsin
# keras.ops.arcsin
# keras.src.ops.numpy.arcsin
r"-(Inverse sine, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Tensor of the inverse sine of each element in `x`, in radians and in
        the closed interval `[-pi/2, pi/2]`.

    Example:
    >>> x = keras.ops.convert_to_tensor([1, -1, 0])
    >>> keras.ops.arcsin(x)
    array([ 1.5707964, -1.5707964,  0.], dtype=float32)
    )-"

# keras.src.ops.numpy.arcsin
#' Inverse sine, element-wise.
#'
#' @description
#'
#' # Returns
#' Tensor of the inverse sine of each element in `x`, in radians and in
#' the closed interval `[-pi/2, pi/2]`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, -1, 0])
#' keras.ops.arcsin(x)
#' # array([ 1.5707964, -1.5707964,  0.], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arcsin>
k_arcsin <-
function (x)
keras$ops$arcsin(x)


# keras$ops$arcsinh
# keras.ops.arcsinh
# keras.src.ops.numpy.arcsinh
r"-(Inverse hyperbolic sine, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.

    Example:
    >>> x = keras.ops.convert_to_tensor([1, -1, 0])
    >>> keras.ops.arcsinh(x)
    array([0.88137364, -0.88137364, 0.0], dtype=float32)
    )-"

# keras.src.ops.numpy.arcsinh
#' Inverse hyperbolic sine, element-wise.
#'
#' @description
#'
#' # Returns
#' Output tensor of same shape as `x`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([1, -1, 0])
#' keras.ops.arcsinh(x)
#' # array([0.88137364, -0.88137364, 0.0], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arcsinh>
k_arcsinh <-
function (x)
keras$ops$arcsinh(x)


# keras$ops$arctan
# keras.ops.arctan
# keras.src.ops.numpy.arctan
r"-(Trigonometric inverse tangent, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Tensor of the inverse tangent of each element in `x`, in the interval
        `[-pi/2, pi/2]`.

    Example:
    >>> x = keras.ops.convert_to_tensor([0, 1])
    >>> keras.ops.arctan(x)
    array([0., 0.7853982], dtype=float32)
    )-"

# keras.src.ops.numpy.arctan
#' Trigonometric inverse tangent, element-wise.
#'
#' @description
#'
#' # Returns
#' Tensor of the inverse tangent of each element in `x`, in the interval
#' `[-pi/2, pi/2]`.
#'
#' # Examples
#' ```python
#' x = keras.ops.convert_to_tensor([0, 1])
#' keras.ops.arctan(x)
#' # array([0., 0.7853982], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arctan>
k_arctan <-
function (x)
keras$ops$arctan(x)


# keras$ops$arctan2
# keras.ops.arctan2
# keras.src.ops.numpy.arctan2
r"-(Element-wise arc tangent of `x1/x2` choosing the quadrant correctly.

    The quadrant (i.e., branch) is chosen so that `arctan2(x1, x2)` is the
    signed angle in radians between the ray ending at the origin and passing
    through the point `(1, 0)`, and the ray ending at the origin and passing
    through the point `(x2, x1)`. (Note the role reversal: the "y-coordinate"
    is the first function parameter, the "x-coordinate" is the second.) By IEEE
    convention, this function is defined for `x2 = +/-0` and for either or both
    of `x1` and `x2` `= +/-inf`.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Tensor of angles in radians, in the range `[-pi, pi]`.

    Examples:
    Consider four points in different quadrants:
    >>> x = keras.ops.convert_to_tensor([-1, +1, +1, -1])
    >>> y = keras.ops.convert_to_tensor([-1, -1, +1, +1])
    >>> keras.ops.arctan2(y, x) * 180 / numpy.pi
    array([-135., -45., 45., 135.], dtype=float32)

    Note the order of the parameters. `arctan2` is defined also when x2=0 and
    at several other points, obtaining values in the range `[-pi, pi]`:
    >>> keras.ops.arctan2(
    ...     keras.ops.array([1., -1.]),
    ...     keras.ops.array([0., 0.]),
    ... )
    array([ 1.5707964, -1.5707964], dtype=float32)
    >>> keras.ops.arctan2(
    ...     keras.ops.array([0., 0., numpy.inf]),
    ...     keras.ops.array([+0., -0., numpy.inf]),
    ... )
    array([0., 3.1415925, 0.7853982], dtype=float32)
    )-"

# keras.src.ops.numpy.arctan2
#' Element-wise arc tangent of `x1/x2` choosing the quadrant correctly.
#'
#' @description
#' The quadrant (i.e., branch) is chosen so that `arctan2(x1, x2)` is the
#' signed angle in radians between the ray ending at the origin and passing
#' through the point `(1, 0)`, and the ray ending at the origin and passing
#' through the point `(x2, x1)`. (Note the role reversal: the "y-coordinate"
#' is the first function parameter, the "x-coordinate" is the second.) By IEEE
#' convention, this function is defined for `x2 = +/-0` and for either or both
#' of `x1` and `x2` `= +/-inf`.
#'
#' # Returns
#' Tensor of angles in radians, in the range `[-pi, pi]`.
#'
#' # Examples
#' Consider four points in different quadrants:
#' ```python
#' x = keras.ops.convert_to_tensor([-1, +1, +1, -1])
#' y = keras.ops.convert_to_tensor([-1, -1, +1, +1])
#' keras.ops.arctan2(y, x) * 180 / numpy.pi
#' # array([-135., -45., 45., 135.], dtype=float32)
#' ```
#'
#' Note the order of the parameters. `arctan2` is defined also when x2=0 and
#' at several other points, obtaining values in the range `[-pi, pi]`:
#' ```python
#' keras.ops.arctan2(
#'     keras.ops.array([1., -1.]),
#'     keras.ops.array([0., 0.]),
#' )
#' # array([ 1.5707964, -1.5707964], dtype=float32)
#' keras.ops.arctan2(
#'     keras.ops.array([0., 0., numpy.inf]),
#'     keras.ops.array([+0., -0., numpy.inf]),
#' )
#' # array([0., 3.1415925, 0.7853982], dtype=float32)
#' ```
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arctan2>
k_arctan2 <-
function (x1, x2)
keras$ops$arctan2(x1, x2)


# keras$ops$arctanh
# keras.ops.arctanh
# keras.src.ops.numpy.arctanh
r"-(Inverse hyperbolic tangent, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.arctanh
#' Inverse hyperbolic tangent, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/arctanh>
k_arctanh <-
function (x)
keras$ops$arctanh(x)


# keras$ops$argmax
# keras.ops.argmax
# keras.src.ops.numpy.argmax
r"-(Returns the indices of the maximum values along an axis.

    Args:
        x: Input tensor.
        axis: By default, the index is into the flattened tensor, otherwise
            along the specified axis.

    Returns:
        Tensor of indices. It has the same shape as `x`, with the dimension
        along `axis` removed.

    Example:
    >>> x = keras.ops.arange(6).reshape(2, 3) + 10
    >>> x
    array([[10, 11, 12],
           [13, 14, 15]], dtype=int32)
    >>> keras.ops.argmax(x)
    array(5, dtype=int32)
    >>> keras.ops.argmax(x, axis=0)
    array([1, 1, 1], dtype=int32)
    >>> keras.ops.argmax(x, axis=1)
    array([2, 2], dtype=int32)
    )-"

# keras.src.ops.numpy.argmax
#' Returns the indices of the maximum values along an axis.
#'
#' @description
#'
#' # Returns
#' Tensor of indices. It has the same shape as `x`, with the dimension
#' along `axis` removed.
#'
#' # Examples
#' ```python
#' x = keras.ops.arange(6).reshape(2, 3) + 10
#' x
#' # array([[10, 11, 12],
#' #        [13, 14, 15]], dtype=int32)
#' keras.ops.argmax(x)
#' # array(5, dtype=int32)
#' keras.ops.argmax(x, axis=0)
#' # array([1, 1, 1], dtype=int32)
#' keras.ops.argmax(x, axis=1)
#' # array([2, 2], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param axis By default, the index is into the flattened tensor, otherwise
#'     along the specified axis.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/argmax>
k_argmax <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$argmax, args)
}


# keras$ops$argmin
# keras.ops.argmin
# keras.src.ops.numpy.argmin
r"-(Returns the indices of the minium values along an axis.

    Args:
        x: Input tensor.
        axis: By default, the index is into the flattened tensor, otherwise
            along the specified axis.

    Returns:
        Tensor of indices. It has the same shape as `x`, with the dimension
        along `axis` removed.

    Example:
    >>> x = keras.ops.arange(6).reshape(2, 3) + 10
    >>> x
    array([[10, 11, 12],
           [13, 14, 15]], dtype=int32)
    >>> keras.ops.argmin(x)
    array(0, dtype=int32)
    >>> keras.ops.argmin(x, axis=0)
    array([0, 0, 0], dtype=int32)
    >>> keras.ops.argmin(x, axis=1)
    array([0, 0], dtype=int32)
    )-"

# keras.src.ops.numpy.argmin
#' Returns the indices of the minium values along an axis.
#'
#' @description
#'
#' # Returns
#' Tensor of indices. It has the same shape as `x`, with the dimension
#' along `axis` removed.
#'
#' # Examples
#' ```python
#' x = keras.ops.arange(6).reshape(2, 3) + 10
#' x
#' # array([[10, 11, 12],
#' #        [13, 14, 15]], dtype=int32)
#' keras.ops.argmin(x)
#' # array(0, dtype=int32)
#' keras.ops.argmin(x, axis=0)
#' # array([0, 0, 0], dtype=int32)
#' keras.ops.argmin(x, axis=1)
#' # array([0, 0], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param axis By default, the index is into the flattened tensor, otherwise
#'     along the specified axis.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/argmin>
k_argmin <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$argmin, args)
}


# keras$ops$argsort
# keras.ops.argsort
# keras.src.ops.numpy.argsort
r"-(Returns the indices that would sort a tensor.

    Args:
        x: Input tensor.
        axis: Axis along which to sort. Defaults to`-1` (the last axis). If
            `None`, the flattened tensor is used.

    Returns:
        Tensor of indices that sort `x` along the specified `axis`.

    Examples:
    One dimensional array:
    >>> x = keras.ops.array([3, 1, 2])
    >>> keras.ops.argsort(x)
    array([1, 2, 0], dtype=int32)

    Two-dimensional array:
    >>> x = keras.ops.array([[0, 3], [3, 2], [4, 5]])
    >>> x
    array([[0, 3],
           [3, 2],
           [4, 5]], dtype=int32)
    >>> keras.ops.argsort(x, axis=0)
    array([[0, 1],
           [1, 0],
           [2, 2]], dtype=int32)
    >>> keras.ops.argsort(x, axis=1)
    array([[0, 1],
           [1, 0],
           [0, 1]], dtype=int32)
    )-"

# keras.src.ops.numpy.argsort
#' Returns the indices that would sort a tensor.
#'
#' @description
#'
#' # Returns
#' Tensor of indices that sort `x` along the specified `axis`.
#'
#' # Examples
#' One dimensional array:
#' ```python
#' x = keras.ops.array([3, 1, 2])
#' keras.ops.argsort(x)
#' # array([1, 2, 0], dtype=int32)
#' ```
#'
#' Two-dimensional array:
#' ```python
#' x = keras.ops.array([[0, 3], [3, 2], [4, 5]])
#' x
#' # array([[0, 3],
#' #        [3, 2],
#' #        [4, 5]], dtype=int32)
#' keras.ops.argsort(x, axis=0)
#' # array([[0, 1],
#' #        [1, 0],
#' #        [2, 2]], dtype=int32)
#' keras.ops.argsort(x, axis=1)
#' # array([[0, 1],
#' #        [1, 0],
#' #        [0, 1]], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#' @param axis Axis along which to sort. Defaults to`-1` (the last axis). If
#'     `None`, the flattened tensor is used.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/argsort>
k_argsort <-
function (x, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$argsort, args)
}


# keras$ops$array
# keras.ops.array
# keras.src.ops.numpy.array
r"-(Create a tensor.

    Args:
        x: Input tensor.
        dtype: The desired data-type for the tensor.

    Returns:
        A tensor.

    Examples:
    >>> keras.ops.array([1, 2, 3])
    array([1, 2, 3], dtype=int32)

    >>> keras.ops.array([1, 2, 3], dtype="float32")
    array([1., 2., 3.], dtype=float32)
    )-"

# keras.src.ops.numpy.array
#' Create a tensor.
#'
#' @description
#'
#' # Returns
#' A tensor.
#'
#' # Examples
#' ```python
#' keras.ops.array([1, 2, 3])
#' # array([1, 2, 3], dtype=int32)
#' ```
#'
#' ```python
#' keras.ops.array([1, 2, 3], dtype="float32")
#' # array([1., 2., 3.], dtype=float32)
#' ```
#'
#' @param x Input tensor.
#' @param dtype The desired data-type for the tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/array>
k_array <-
function (x, dtype = NULL)
keras$ops$array(x, dtype)


# keras$ops$average
# keras.ops.average
# keras.src.ops.numpy.average
r"-(Compute the weighted average along the specified axis.

    Args:
        x: Input tensor.
        axis: Integer along which to average `x`. The default, `axis=None`,
            will average over all of the elements of the input tensor. If axis
            is negative it counts from the last to the first axis.
        weights: Tensor of wieghts associated with the values in `x`. Each
            value in `x` contributes to the average according to its
            associated weight. The weights array can either be 1-D (in which
            case its length must be the size of a along the given axis) or of
            the same shape as `x`. If `weights=None` (default), then all data
            in `x` are assumed to have a weight equal to one.

            The 1-D calculation is: `avg = sum(a * weights) / sum(weights)`.
            The only constraint on weights is that `sum(weights)` must not be 0.

    Returns:
        Return the average along the specified axis.

    Examples:
    >>> data = keras.ops.arange(1, 5)
    >>> data
    array([1, 2, 3, 4], dtype=int32)
    >>> keras.ops.average(data)
    array(2.5, dtype=float32)
    >>> keras.ops.average(
    ...     keras.ops.arange(1, 11),
    ...     weights=keras.ops.arange(10, 0, -1)
    ... )
    array(4., dtype=float32)

    >>> data = keras.ops.arange(6).reshape((3, 2))
    >>> data
    array([[0, 1],
           [2, 3],
           [4, 5]], dtype=int32)
    >>> keras.ops.average(
    ...     data,
    ...     axis=1,
    ...     weights=keras.ops.array([1./4, 3./4])
    ... )
    array([0.75, 2.75, 4.75], dtype=float32)
    >>> keras.ops.average(
    ...     data,
    ...     weights=keras.ops.array([1./4, 3./4])
    ... )
    Traceback (most recent call last):
        ...
    ValueError: Axis must be specified when shapes of a and weights differ.
    )-"

# keras.src.ops.numpy.average
#' Compute the weighted average along the specified axis.
#'
#' @description
#'
#' # Returns
#' Return the average along the specified axis.
#'
#' # Examples
#' ```python
#' data = keras.ops.arange(1, 5)
#' data
#' # array([1, 2, 3, 4], dtype=int32)
#' keras.ops.average(data)
#' # array(2.5, dtype=float32)
#' keras.ops.average(
#'     keras.ops.arange(1, 11),
#'     weights=keras.ops.arange(10, 0, -1)
#' )
#' # array(4., dtype=float32)
#' ```
#'
#' ```python
#' data = keras.ops.arange(6).reshape((3, 2))
#' data
#' # array([[0, 1],
#' #        [2, 3],
#' #        [4, 5]], dtype=int32)
#' keras.ops.average(
#'     data,
#'     axis=1,
#'     weights=keras.ops.array([1./4, 3./4])
#' )
#' # array([0.75, 2.75, 4.75], dtype=float32)
#' keras.ops.average(
#'     data,
#'     weights=keras.ops.array([1./4, 3./4])
#' )
#' # Traceback (most recent call last):
#' #     ...
#' # ValueError: Axis must be specified when shapes of a and weights differ.
#' ```
#'
#' @param x Input tensor.
#' @param axis Integer along which to average `x`. The default, `axis=None`,
#'     will average over all of the elements of the input tensor. If axis
#'     is negative it counts from the last to the first axis.
#' @param weights Tensor of wieghts associated with the values in `x`. Each
#'     value in `x` contributes to the average according to its
#'     associated weight. The weights array can either be 1-D (in which
#'     case its length must be the size of a along the given axis) or of
#'     the same shape as `x`. If `weights=None` (default), then all data
#'     in `x` are assumed to have a weight equal to one.
#'
#'     The 1-D calculation is: `avg = sum(a * weights) / sum(weights)`.
#'     The only constraint on weights is that `sum(weights)` must not be 0.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/average>
k_average <-
function (x, axis = NULL, weights = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$average, args)
}


# keras$ops$bincount
# keras.ops.bincount
# keras.src.ops.numpy.bincount
r"-(Count the number of occurrences of each value in a tensor of integers.

    Args:
        x: Input tensor.
            It must be of dimension 1, and it must only contain non-negative
            integer(s).
        weights: Weight tensor.
            It must have the same length as `x`. The default value is `None`.
            If specified, `x` is weighted by it, i.e. if `n = x[i]`,
            `out[n] += weight[i]` instead of the default behavior `out[n] += 1`.
        minlength: An integer.
            The default value is 0. If specified, there will be at least
            this number of bins in the output tensor. If greater than
            `max(x) + 1`, each value of the output at an index higher than
            `max(x)` is set to 0.

    Returns:
        1D tensor where each element gives the number of occurrence(s) of its
        index value in x. Its length is the maximum between `max(x) + 1` and
        minlength.

    Examples:
    >>> x = keras.ops.array([1, 2, 2, 3], dtype="uint8")
    >>> keras.ops.bincount(x)
    array([0, 1, 2, 1], dtype=int32)
    >>> weights = x / 2
    >>> weights
    array([0.5, 1., 1., 1.5], dtype=float64)
    >>> keras.ops.bincount(x, weights=weights)
    array([0., 0.5, 2., 1.5], dtype=float64)
    >>> minlength = (keras.ops.max(x).numpy() + 1) + 2 # 6
    >>> keras.ops.bincount(x, minlength=minlength)
    array([0, 1, 2, 1, 0, 0], dtype=int32)
    )-"

# keras.src.ops.numpy.bincount
#' Count the number of occurrences of each value in a tensor of integers.
#'
#' @description
#'
#' # Returns
#' 1D tensor where each element gives the number of occurrence(s) of its
#' index value in x. Its length is the maximum between `max(x) + 1` and
#' minlength.
#'
#' # Examples
#' ```python
#' x = keras.ops.array([1, 2, 2, 3], dtype="uint8")
#' keras.ops.bincount(x)
#' # array([0, 1, 2, 1], dtype=int32)
#' weights = x / 2
#' weights
#' # array([0.5, 1., 1., 1.5], dtype=float64)
#' keras.ops.bincount(x, weights=weights)
#' # array([0., 0.5, 2., 1.5], dtype=float64)
#' minlength = (keras.ops.max(x).numpy() + 1) + 2 # 6
#' keras.ops.bincount(x, minlength=minlength)
#' # array([0, 1, 2, 1, 0, 0], dtype=int32)
#' ```
#'
#' @param x Input tensor.
#'     It must be of dimension 1, and it must only contain non-negative
#'     integer(s).
#' @param weights Weight tensor.
#'     It must have the same length as `x`. The default value is `None`.
#'     If specified, `x` is weighted by it, i.e. if `n = x[i]`,
#'     `out[n] += weight[i]` instead of the default behavior `out[n] += 1`.
#' @param minlength An integer.
#'     The default value is 0. If specified, there will be at least
#'     this number of bins in the output tensor. If greater than
#'     `max(x) + 1`, each value of the output at an index higher than
#'     `max(x)` is set to 0.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/bincount>
k_bincount <-
function (x, weights = NULL, minlength = 0L)
{
    args <- capture_args2(list(x = as_integer, minlength = as_integer))
    do.call(keras$ops$bincount, args)
}


# keras$ops$broadcast_to
# keras.ops.broadcast_to
# keras.src.ops.numpy.broadcast_to
r"-(Broadcast a tensor to a new shape.

    Args:
        x: The tensor to broadcast.
        shape: The shape of the desired tensor. A single integer `i` is
            interpreted as `(i,)`.

    Returns:
        A tensor with the desired shape.

    Examples:
    >>> x = keras.ops.array([1, 2, 3])
    >>> keras.ops.broadcast_to(x, (3, 3))
    array([[1, 2, 3],
           [1, 2, 3],
           [1, 2, 3]])
    )-"

# keras.src.ops.numpy.broadcast_to
#' Broadcast a tensor to a new shape.
#'
#' @description
#'
#' # Returns
#' A tensor with the desired shape.
#'
#' # Examples
#' ```python
#' x = keras.ops.array([1, 2, 3])
#' keras.ops.broadcast_to(x, (3, 3))
#' # array([[1, 2, 3],
#' #        [1, 2, 3],
#' #        [1, 2, 3]])
#' ```
#'
#' @param x The tensor to broadcast.
#' @param shape The shape of the desired tensor. A single integer `i` is
#'     interpreted as `(i,)`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/broadcast_to>
k_broadcast_to <-
function (x, shape)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$broadcast_to, args)
}


# keras$ops$ceil
# keras.ops.ceil
# keras.src.ops.numpy.ceil
r"-(Return the ceiling of the input, element-wise.

    The ceil of the scalar `x` is the smallest integer `i`, such that
    `i >= x`.

    Args:
        x: Input tensor.

    Returns:
        The ceiling of each element in `x`, with float dtype.
    )-"

# keras.src.ops.numpy.ceil
#' Return the ceiling of the input, element-wise.
#'
#' @description
#' The ceil of the scalar `x` is the smallest integer `i`, such that
#' `i >= x`.
#'
#' # Returns
#'     The ceiling of each element in `x`, with float dtype.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/ceil>
k_ceil <-
function (x)
keras$ops$ceil(x)


# keras$ops$clip
# keras.ops.clip
# keras.src.ops.numpy.clip
r"-(Clip (limit) the values in a tensor.

    Given an interval, values outside the interval are clipped to the
    interval edges. For example, if an interval of `[0, 1]` is specified,
    values smaller than 0 become 0, and values larger than 1 become 1.

    Args:
        x: Input tensor.
        x_min: Minimum value.
        x_max: Maximum value.
    Returns:
        The clipped tensor.
    )-"

# keras.src.ops.numpy.clip
#' Clip (limit) the values in a tensor.
#'
#' @description
#' Given an interval, values outside the interval are clipped to the
#' interval edges. For example, if an interval of `[0, 1]` is specified,
#' values smaller than 0 become 0, and values larger than 1 become 1.
#'
#' # Returns
#'     The clipped tensor.
#'
#' @param x Input tensor.
#' @param x_min Minimum value.
#' @param x_max Maximum value.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/clip>
k_clip <-
function (x, x_min, x_max)
keras$ops$clip(x, x_min, x_max)


# keras$ops$concatenate
# keras.ops.concatenate
# keras.src.ops.numpy.concatenate
r"-(Join a sequence of tensors along an existing axis.

    Args:
        xs: The sequence of tensors to concatenate.
        axis: The axis along which the tensors will be joined. Defaults to `0`.

    Returns:
        The concatenated tensor.
    )-"

# keras.src.ops.numpy.concatenate
#' Join a sequence of tensors along an existing axis.
#'
#' @description
#'
#' # Returns
#'     The concatenated tensor.
#'
#' @param xs The sequence of tensors to concatenate.
#' @param axis The axis along which the tensors will be joined. Defaults to `0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/concatenate>
k_concatenate <-
function (xs, axis = 0L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$concatenate, args)
}


# keras$ops$conj
# keras.ops.conj
# keras.src.ops.numpy.conj
r"-(Shorthand for `keras.ops.conjugate`.)-"

# keras.src.ops.numpy.conj
#' Shorthand for `keras.ops.conjugate`.
#'
#' @param x see description
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/conj>
k_conj <-
function (x)
keras$ops$conj(x)


# keras$ops$conjugate
# keras.ops.conjugate
# keras.src.ops.numpy.conjugate
r"-(Returns the complex conjugate, element-wise.

    The complex conjugate of a complex number is obtained by changing the sign
    of its imaginary part.

    `keras.ops.conj` is a shorthand for this function.

    Args:
        x: Input tensor.

    Returns:
        The complex conjugate of each element in `x`.
    )-"

# keras.src.ops.numpy.conjugate
#' Returns the complex conjugate, element-wise.
#'
#' @description
#' The complex conjugate of a complex number is obtained by changing the sign
#' of its imaginary part.
#'
#' `keras.ops.conj` is a shorthand for this function.
#'
#' # Returns
#'     The complex conjugate of each element in `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/conjugate>
k_conjugate <-
function (x)
keras$ops$conjugate(x)


# keras$ops$copy
# keras.ops.copy
# keras.src.ops.numpy.copy
r"-(Returns a copy of `x`.

    Args:
        x: Input tensor.

    Returns:
        A copy of `x`.
    )-"

# keras.src.ops.numpy.copy
#' Returns a copy of `x`.
#'
#' @description
#'
#' # Returns
#'     A copy of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/copy>
k_copy <-
function (x)
keras$ops$copy(x)


# keras$ops$cos
# keras.ops.cos
# keras.src.ops.numpy.cos
r"-(Cosine, element-wise.

    Args:
        x: Input tensor.

    Returns:
        The corresponding cosine values.
    )-"

# keras.src.ops.numpy.cos
#' Cosine, element-wise.
#'
#' @description
#'
#' # Returns
#'     The corresponding cosine values.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cos>
k_cos <-
function (x)
keras$ops$cos(x)


# keras$ops$cosh
# keras.ops.cosh
# keras.src.ops.numpy.cosh
r"-(Hyperbolic cosine, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.cosh
#' Hyperbolic cosine, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cosh>
k_cosh <-
function (x)
keras$ops$cosh(x)


# keras$ops$count_nonzero
# keras.ops.count_nonzero
# keras.src.ops.numpy.count_nonzero
r"-(Counts the number of non-zero values in `x` along the given `axis`.

    If no axis is specified then all non-zeros in the tensor are counted.

    Args:
        x: Input tensor.
        axis: Axis or tuple of axes along which to count the number of
            non-zeros. Defaults to `None`.

    Returns:
        int or tensor of ints.

    Examples:
    >>> x = keras.ops.array([[0, 1, 7, 0], [3, 0, 2, 19]])
    >>> keras.ops.count_nonzero(x)
    5
    >>> keras.ops.count_nonzero(x, axis=0)
    array([1, 1, 2, 1], dtype=int64)
    >>> keras.ops.count_nonzero(x, axis=1)
    array([2, 3], dtype=int64)
    )-"

# keras.src.ops.numpy.count_nonzero
#' Counts the number of non-zero values in `x` along the given `axis`.
#'
#' @description
#' If no axis is specified then all non-zeros in the tensor are counted.
#'
#' # Returns
#' int or tensor of ints.
#'
#' # Examples
#' ```python
#' x = keras.ops.array([[0, 1, 7, 0], [3, 0, 2, 19]])
#' keras.ops.count_nonzero(x)
#' # 5
#' keras.ops.count_nonzero(x, axis=0)
#' # array([1, 1, 2, 1], dtype=int64)
#' keras.ops.count_nonzero(x, axis=1)
#' # array([2, 3], dtype=int64)
#' ```
#'
#' @param x Input tensor.
#' @param axis Axis or tuple of axes along which to count the number of
#'     non-zeros. Defaults to `None`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/count_nonzero>
k_count_nonzero <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$count_nonzero, args)
}


# keras$ops$cross
# keras.ops.cross
# keras.src.ops.numpy.cross
r"-(Returns the cross product of two (arrays of) vectors.

    The cross product of `x1` and `x2` in R^3 is a vector
    perpendicular to both `x1` and `x2`. If `x1` and `x2` are arrays of
    vectors, the vectors are defined by the last axis of `x1` and `x2`
    by default, and these axes can have dimensions 2 or 3.

    Where the dimension of either `x1` or `x2` is 2, the third component of
    the input vector is assumed to be zero and the cross product calculated
    accordingly.

    In cases where both input vectors have dimension 2, the z-component of
    the cross product is returned.

    Args:
        x1: Components of the first vector(s).
        x2: Components of the second vector(s).
        axisa: Axis of `x1` that defines the vector(s). Defaults to `-1`.
        axisb: Axis of `x2` that defines the vector(s). Defaults to `-1`.
        axisc: Axis of the result containing the cross product vector(s).
            Ignored if both input vectors have dimension 2, as the return is
            scalar. By default, the last axis.
        axis: If defined, the axis of `x1`, `x2` and the result that
            defines the vector(s) and cross product(s). Overrides `axisa`,
            `axisb` and `axisc`.

    Note:
        Torch backend does not support two dimensional vectors, or the
        arguments `axisa`, `axisb` and `axisc`. Use `axis` instead.

    Returns:
        Vector cross product(s).
    )-"

# keras.src.ops.numpy.cross
#' Returns the cross product of two (arrays of) vectors.
#'
#' @description
#' The cross product of `x1` and `x2` in R^3 is a vector
#' perpendicular to both `x1` and `x2`. If `x1` and `x2` are arrays of
#' vectors, the vectors are defined by the last axis of `x1` and `x2`
#' by default, and these axes can have dimensions 2 or 3.
#'
#' Where the dimension of either `x1` or `x2` is 2, the third component of
#' the input vector is assumed to be zero and the cross product calculated
#' accordingly.
#'
#' In cases where both input vectors have dimension 2, the z-component of
#' the cross product is returned.
#'
#' # Note
#' Torch backend does not support two dimensional vectors, or the
#' arguments `axisa`, `axisb` and `axisc`. Use `axis` instead.
#'
#' # Returns
#'     Vector cross product(s).
#'
#' @param x1 Components of the first vector(s).
#' @param x2 Components of the second vector(s).
#' @param axisa Axis of `x1` that defines the vector(s). Defaults to `-1`.
#' @param axisb Axis of `x2` that defines the vector(s). Defaults to `-1`.
#' @param axisc Axis of the result containing the cross product vector(s).
#'     Ignored if both input vectors have dimension 2, as the return is
#'     scalar. By default, the last axis.
#' @param axis If defined, the axis of `x1`, `x2` and the result that
#'     defines the vector(s) and cross product(s). Overrides `axisa`,
#'     `axisb` and `axisc`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cross>
k_cross <-
function (x1, x2, axisa = -1L, axisb = -1L, axisc = -1L, axis = NULL)
{
    args <- capture_args2(list(axisa = as_integer, axisb = as_integer,
        axisc = as_integer, axis = as_axis))
    do.call(keras$ops$cross, args)
}


# keras$ops$cumprod
# keras.ops.cumprod
# keras.src.ops.numpy.cumprod
r"-(Return the cumulative product of elements along a given axis.

    Args:
        x: Input tensor.
        axis: Axis along which the cumulative product is computed.
            By default the input is flattened.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.cumprod
#' Return the cumulative product of elements along a given axis.
#'
#' @description
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#' @param axis Axis along which the cumulative product is computed.
#'     By default the input is flattened.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cumprod>
k_cumprod <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$cumprod, args)
}


# keras$ops$cumsum
# keras.ops.cumsum
# keras.src.ops.numpy.cumsum
r"-(Returns the cumulative sum of elements along a given axis.

    Args:
        x: Input tensor.
        axis: Axis along which the cumulative sum is computed.
            By default the input is flattened.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.cumsum
#' Returns the cumulative sum of elements along a given axis.
#'
#' @description
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#' @param axis Axis along which the cumulative sum is computed.
#'     By default the input is flattened.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/cumsum>
k_cumsum <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$cumsum, args)
}


# keras$ops$diag
# keras.ops.diag
# keras.src.ops.numpy.diag
r"-(Extract a diagonal or construct a diagonal array.

    Args:
        x: Input tensor. If `x` is 2-D, returns the k-th diagonal of `x`.
            If `x` is 1-D, return a 2-D tensor with `x` on the k-th diagonal.
        k: The diagonal to consider. Defaults to `0`. Use `k > 0` for diagonals
            above the main diagonal, and `k < 0` for diagonals below
            the main diagonal.

    Returns:
        The extracted diagonal or constructed diagonal tensor.

    Examples:
    >>> from keras import ops
    >>> x = ops.arange(9).reshape((3, 3))
    >>> x
    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])

    >>> ops.diag(x)
    array([0, 4, 8])
    >>> ops.diag(x, k=1)
    array([1, 5])
    >>> ops.diag(x, k=-1)
    array([3, 7])

    >>> ops.diag(ops.diag(x)))
    array([[0, 0, 0],
           [0, 4, 0],
           [0, 0, 8]])
    )-"

# keras.src.ops.numpy.diag
#' Extract a diagonal or construct a diagonal array.
#'
#' @description
#'
#' # Returns
#' The extracted diagonal or constructed diagonal tensor.
#'
#' # Examples
#' ```python
#' from keras import ops
#' x = ops.arange(9).reshape((3, 3))
#' x
#' # array([[0, 1, 2],
#' #        [3, 4, 5],
#' #        [6, 7, 8]])
#' ```
#'
#' ```python
#' ops.diag(x)
#' # array([0, 4, 8])
#' ops.diag(x, k=1)
#' # array([1, 5])
#' ops.diag(x, k=-1)
#' # array([3, 7])
#' ```
#'
#' ```python
#' ops.diag(ops.diag(x)))
#' # array([[0, 0, 0],
#' #        [0, 4, 0],
#' #        [0, 0, 8]])
#' ```
#'
#' @param x Input tensor. If `x` is 2-D, returns the k-th diagonal of `x`.
#'     If `x` is 1-D, return a 2-D tensor with `x` on the k-th diagonal.
#' @param k The diagonal to consider. Defaults to `0`. Use `k > 0` for diagonals
#'     above the main diagonal, and `k < 0` for diagonals below
#'     the main diagonal.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/diag>
k_diag <-
function (x, k = 0L)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$diag, args)
}


# keras$ops$diagonal
# keras.ops.diagonal
# keras.src.ops.numpy.diagonal
r"-(Return specified diagonals.

    If `x` is 2-D, returns the diagonal of `x` with the given offset, i.e., the
    collection of elements of the form `x[i, i+offset]`.

    If `x` has more than two dimensions, the axes specified by `axis1`
    and `axis2` are used to determine the 2-D sub-array whose diagonal
    is returned.

    The shape of the resulting array can be determined by removing `axis1`
    and `axis2` and appending an index to the right equal to the size of
    the resulting diagonals.

    Args:
        x: Input tensor.
        offset: Offset of the diagonal from the main diagonal.
            Can be positive or negative. Defaults to `0`.(main diagonal).
        axis1: Axis to be used as the first axis of the 2-D sub-arrays.
            Defaults to `0`.(first axis).
        axis2: Axis to be used as the second axis of the 2-D sub-arrays.
            Defaults to `1` (second axis).

    Returns:
        Tensor of diagonals.

    Examples:
    >>> from keras import ops
    >>> x = ops.arange(4).reshape((2, 2))
    >>> x
    array([[0, 1],
           [2, 3]])
    >>> x.diagonal()
    array([0, 3])
    >>> x.diagonal(1)
    array([1])

    >>> x = ops.arange(8).reshape((2, 2, 2))
    >>> x
    array([[[0, 1],
            [2, 3]],
           [[4, 5],
            [6, 7]]])
    >>> x.diagonal(0, 0, 1)
    array([[0, 6],
           [1, 7]])
    )-"

# keras.src.ops.numpy.diagonal
#' Return specified diagonals.
#'
#' @description
#' If `x` is 2-D, returns the diagonal of `x` with the given offset, i.e., the
#' collection of elements of the form `x[i, i+offset]`.
#'
#' If `x` has more than two dimensions, the axes specified by `axis1`
#' and `axis2` are used to determine the 2-D sub-array whose diagonal
#' is returned.
#'
#' The shape of the resulting array can be determined by removing `axis1`
#' and `axis2` and appending an index to the right equal to the size of
#' the resulting diagonals.
#'
#' # Returns
#' Tensor of diagonals.
#'
#' # Examples
#' ```python
#' from keras import ops
#' x = ops.arange(4).reshape((2, 2))
#' x
#' # array([[0, 1],
#' #        [2, 3]])
#' x.diagonal()
#' # array([0, 3])
#' x.diagonal(1)
#' # array([1])
#' ```
#'
#' ```python
#' x = ops.arange(8).reshape((2, 2, 2))
#' x
#' # array([[[0, 1],
#' #         [2, 3]],
#' #        [[4, 5],
#' #         [6, 7]]])
#' x.diagonal(0, 0, 1)
#' # array([[0, 6],
#' #        [1, 7]])
#' ```
#'
#' @param x Input tensor.
#' @param offset Offset of the diagonal from the main diagonal.
#'     Can be positive or negative. Defaults to `0`.(main diagonal).
#' @param axis1 Axis to be used as the first axis of the 2-D sub-arrays.
#'     Defaults to `0`.(first axis).
#' @param axis2 Axis to be used as the second axis of the 2-D sub-arrays.
#'     Defaults to `1` (second axis).
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/diagonal>
k_diagonal <-
function (x, offset = 0L, axis1 = 0L, axis2 = 1L)
{
    args <- capture_args2(list(offset = as_integer, axis1 = as_integer,
        axis2 = as_integer))
    do.call(keras$ops$diagonal, args)
}


# keras$ops$digitize
# keras.ops.digitize
# keras.src.ops.numpy.digitize
r"-(Returns the indices of the bins to which each value in `x` belongs.

    Args:
        x: Input array to be binned.
        bins: Array of bins. It has to be one-dimensional and monotonically
            increasing.

    Returns:
        Output array of indices, of same shape as `x`.

    Example:
    >>> x = np.array([0.0, 1.0, 3.0, 1.6])
    >>> bins = np.array([0.0, 3.0, 4.5, 7.0])
    >>> keras.ops.digitize(x, bins)
    array([1, 1, 2, 1])
    )-"

# keras.src.ops.numpy.digitize
#' Returns the indices of the bins to which each value in `x` belongs.
#'
#' @description
#'
#' # Returns
#' Output array of indices, of same shape as `x`.
#'
#' # Examples
#' ```python
#' x = np.array([0.0, 1.0, 3.0, 1.6])
#' bins = np.array([0.0, 3.0, 4.5, 7.0])
#' keras.ops.digitize(x, bins)
#' # array([1, 1, 2, 1])
#' ```
#'
#' @param x Input array to be binned.
#' @param bins Array of bins. It has to be one-dimensional and monotonically
#'     increasing.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/digitize>
k_digitize <-
function (x, bins)
keras$ops$digitize(x, bins)


# keras$ops$divide
# keras.ops.divide
# keras.src.ops.numpy.divide
r"-(Divide arguments element-wise.

    `keras.ops.true_divide` is an alias for this function.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, the quotient `x1/x2`, element-wise.
    )-"

# keras.src.ops.numpy.divide
#' Divide arguments element-wise.
#'
#' @description
#' `keras.ops.true_divide` is an alias for this function.
#'
#' # Returns
#'     Output tensor, the quotient `x1/x2`, element-wise.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/divide>
k_divide <-
function (x1, x2)
keras$ops$divide(x1, x2)


# keras$ops$dot
# keras.ops.dot
# keras.src.ops.numpy.dot
r"-(Dot product of two tensors.

    - If both `x1` and `x2` are 1-D tensors, it is inner product of vectors
      (without complex conjugation).
    - If both `x1` and `x2` are 2-D tensors, it is matrix multiplication.
    - If either `x1` or `x2` is 0-D (scalar), it is equivalent to `x1 * x2`.
    - If `x1` is an N-D tensor and `x2` is a 1-D tensor, it is a sum product
      over the last axis of `x1` and `x2`.
    - If `x1` is an N-D tensor and `x2` is an M-D tensor (where `M>=2`),
      it is a sum product over the last axis of `x1` and the second-to-last
      axis of `x2`: `dot(x1, x2)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])`.

    Args:
        x1: First argument.
        x2: Second argument.

    Note:
        Torch backend does not accept 0-D tensors as arguments.

    Returns:
        Dot product of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.dot
#' Dot product of two tensors.
#'
#' @description
#' - If both `x1` and `x2` are 1-D tensors, it is inner product of vectors
#'   (without complex conjugation).
#' - If both `x1` and `x2` are 2-D tensors, it is matrix multiplication.
#' - If either `x1` or `x2` is 0-D (scalar), it is equivalent to `x1 * x2`.
#' - If `x1` is an N-D tensor and `x2` is a 1-D tensor, it is a sum product
#'   over the last axis of `x1` and `x2`.
#' - If `x1` is an N-D tensor and `x2` is an M-D tensor (where `M>=2`),
#'   it is a sum product over the last axis of `x1` and the second-to-last
#'   axis of `x2`: `dot(x1, x2)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])`.
#'
#' # Note
#' Torch backend does not accept 0-D tensors as arguments.
#'
#' # Returns
#'     Dot product of `x1` and `x2`.
#'
#' @param x1 First argument.
#' @param x2 Second argument.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/dot>
k_dot <-
function (x1, x2)
keras$ops$dot(x1, x2)


# keras$ops$einsum
# keras.ops.einsum
# keras.src.ops.numpy.einsum
r"-(Evaluates the Einstein summation convention on the operands.

    Args:
        subscripts: Specifies the subscripts for summation as comma separated
            list of subscript labels. An implicit (classical Einstein
            summation) calculation is performed unless the explicit indicator
            `->` is included as well as subscript labels of the precise
            output form.
        operands: The operands to compute the Einstein sum of.

    Returns:
        The calculation based on the Einstein summation convention.

    Example:
    >>> from keras import ops
    >>> a = ops.arange(25).reshape(5, 5)
    >>> b = ops.arange(5)
    >>> c = ops.arange(6).reshape(2, 3)

    Trace of a matrix:

    >>> ops.einsum("ii", a)
    60
    >>> ops.einsum(a, [0, 0])
    60
    >>> ops.trace(a)
    60

    Extract the diagonal:

    >>> ops.einsum("ii -> i", a)
    array([ 0,  6, 12, 18, 24])
    >>> ops.einsum(a, [0, 0], [0])
    array([ 0,  6, 12, 18, 24])
    >>> ops.diag(a)
    array([ 0,  6, 12, 18, 24])

    Sum over an axis:

    >>> ops.einsum("ij -> i", a)
    array([ 10,  35,  60,  85, 110])
    >>> ops.einsum(a, [0, 1], [0])
    array([ 10,  35,  60,  85, 110])
    >>> ops.sum(a, axis=1)
    array([ 10,  35,  60,  85, 110])

    For higher dimensional tensors summing a single axis can be done
    with ellipsis:

    >>> ops.einsum("...j -> ...", a)
    array([ 10,  35,  60,  85, 110])
    >>> np.einsum(a, [..., 1], [...])
    array([ 10,  35,  60,  85, 110])

    Compute a matrix transpose or reorder any number of axes:

    >>> ops.einsum("ji", c)
    array([[0, 3],
           [1, 4],
           [2, 5]])
    >>> ops.einsum("ij -> ji", c)
    array([[0, 3],
           [1, 4],
           [2, 5]])
    >>> ops.einsum(c, [1, 0])
    array([[0, 3],
           [1, 4],
           [2, 5]])
    >>> ops.transpose(c)
    array([[0, 3],
           [1, 4],
           [2, 5]])

    Matrix vector multiplication:

    >>> ops.einsum("ij, j", a, b)
    array([ 30,  80, 130, 180, 230])
    >>> ops.einsum(a, [0, 1], b, [1])
    array([ 30,  80, 130, 180, 230])
    >>> ops.einsum("...j, j", a, b)
    array([ 30,  80, 130, 180, 230])
    )-"

# keras.src.ops.numpy.einsum
#' Evaluates the Einstein summation convention on the operands.
#'
#' @description
#'
#' # Returns
#' The calculation based on the Einstein summation convention.
#'
#' # Examples
#' ```python
#' from keras import ops
#' a = ops.arange(25).reshape(5, 5)
#' b = ops.arange(5)
#' c = ops.arange(6).reshape(2, 3)
#' ```
#'
#' Trace of a matrix:
#'
#' ```python
#' ops.einsum("ii", a)
#' # 60
#' ops.einsum(a, [0, 0])
#' # 60
#' ops.trace(a)
#' # 60
#' ```
#'
#' Extract the diagonal:
#'
#' ```python
#' ops.einsum("ii -> i", a)
#' # array([ 0,  6, 12, 18, 24])
#' ops.einsum(a, [0, 0], [0])
#' # array([ 0,  6, 12, 18, 24])
#' ops.diag(a)
#' # array([ 0,  6, 12, 18, 24])
#' ```
#'
#' Sum over an axis:
#'
#' ```python
#' ops.einsum("ij -> i", a)
#' # array([ 10,  35,  60,  85, 110])
#' ops.einsum(a, [0, 1], [0])
#' # array([ 10,  35,  60,  85, 110])
#' ops.sum(a, axis=1)
#' # array([ 10,  35,  60,  85, 110])
#' ```
#'
#' For higher dimensional tensors summing a single axis can be done
#' with ellipsis:
#'
#' ```python
#' ops.einsum("...j -> ...", a)
#' # array([ 10,  35,  60,  85, 110])
#' np.einsum(a, [..., 1], [...])
#' # array([ 10,  35,  60,  85, 110])
#' ```
#'
#' Compute a matrix transpose or reorder any number of axes:
#'
#' ```python
#' ops.einsum("ji", c)
#' # array([[0, 3],
#' #        [1, 4],
#' #        [2, 5]])
#' ops.einsum("ij -> ji", c)
#' # array([[0, 3],
#' #        [1, 4],
#' #        [2, 5]])
#' ops.einsum(c, [1, 0])
#' # array([[0, 3],
#' #        [1, 4],
#' #        [2, 5]])
#' ops.transpose(c)
#' # array([[0, 3],
#' #        [1, 4],
#' #        [2, 5]])
#' ```
#'
#' Matrix vector multiplication:
#'
#' ```python
#' ops.einsum("ij, j", a, b)
#' # array([ 30,  80, 130, 180, 230])
#' ops.einsum(a, [0, 1], b, [1])
#' # array([ 30,  80, 130, 180, 230])
#' ops.einsum("...j, j", a, b)
#' # array([ 30,  80, 130, 180, 230])
#' ```
#'
#' @param subscripts Specifies the subscripts for summation as comma separated
#'     list of subscript labels. An implicit (classical Einstein
#'     summation) calculation is performed unless the explicit indicator
#'     `->` is included as well as subscript labels of the precise
#'     output form.
#' @param ... The operands to compute the Einstein sum of.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/einsum>
k_einsum <-
function (subscripts, ...)
keras$ops$einsum(subscripts, ...)


# keras$ops$empty
# keras.ops.empty
# keras.src.ops.numpy.empty
r"-(Return a tensor of given shape and type filled with uninitialized data.

    Args:
        shape: Shape of the empty tensor.
        dtype: Desired data type of the empty tensor.

    Returns:
        The empty tensor.
    )-"

# keras.src.ops.numpy.empty
#' Return a tensor of given shape and type filled with uninitialized data.
#'
#' @description
#'
#' # Returns
#'     The empty tensor.
#'
#' @param shape Shape of the empty tensor.
#' @param dtype Desired data type of the empty tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/empty>
k_empty <-
function (shape, dtype = NULL)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$empty, args)
}


# keras$ops$equal
# keras.ops.equal
# keras.src.ops.numpy.equal
r"-(Returns `(x1 == x2)` element-wise.

    Args:
        x1: Tensor to compare.
        x2: Tensor to compare.

    Returns:
        Output tensor, element-wise comparison of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.equal
#' Returns `(x1 == x2)` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparison of `x1` and `x2`.
#'
#' @param x1 Tensor to compare.
#' @param x2 Tensor to compare.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/equal>
k_equal <-
function (x1, x2)
keras$ops$equal(x1, x2)


# keras$ops$exp
# keras.ops.exp
# keras.src.ops.numpy.exp
r"-(Calculate the exponential of all elements in the input tensor.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise exponential of `x`.
    )-"

# keras.src.ops.numpy.exp
#' Calculate the exponential of all elements in the input tensor.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise exponential of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/exp>
k_exp <-
function (x)
keras$ops$exp(x)


# keras$ops$expand_dims
# keras.ops.expand_dims
# keras.src.ops.numpy.expand_dims
r"-(Expand the shape of a tensor.

    Insert a new axis at the `axis` position in the expanded tensor shape.

    Args:
        x: Input tensor.
        axis: Position in the expanded axes where the new axis
            (or axes) is placed.

    Returns:
        Output tensor with the number of dimensions increased.
    )-"

# keras.src.ops.numpy.expand_dims
#' Expand the shape of a tensor.
#'
#' @description
#' Insert a new axis at the `axis` position in the expanded tensor shape.
#'
#' # Returns
#'     Output tensor with the number of dimensions increased.
#'
#' @param x Input tensor.
#' @param axis Position in the expanded axes where the new axis
#'     (or axes) is placed.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/expand_dims>
k_expand_dims <-
function (x, axis)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$expand_dims, args)
}


# keras$ops$expm1
# keras.ops.expm1
# keras.src.ops.numpy.expm1
r"-(Calculate `exp(x) - 1` for all elements in the tensor.

    Args:
        x: Input values.

    Returns:
        Output tensor, element-wise exponential minus one.
    )-"

# keras.src.ops.numpy.expm1
#' Calculate `exp(x) - 1` for all elements in the tensor.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise exponential minus one.
#'
#' @param x Input values.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/expm1>
k_expm1 <-
function (x)
keras$ops$expm1(x)


# keras$ops$eye
# keras.ops.eye
# keras.src.ops.numpy.eye
r"-(Return a 2-D tensor with ones on the diagonal and zeros elsewhere.

    Args:
        N: Number of rows in the output.
        M: Number of columns in the output. If `None`, defaults to `N`.
        k: Index of the diagonal: 0 (the default) refers to the main
            diagonal, a positive value refers to an upper diagonal,
            and a negative value to a lower diagonal.
        dtype: Data type of the returned tensor.

    Returns:
        Tensor with ones on the k-th diagonal and zeros elsewhere.
    )-"

# keras.src.ops.numpy.eye
#' Return a 2-D tensor with ones on the diagonal and zeros elsewhere.
#'
#' @description
#'
#' # Returns
#'     Tensor with ones on the k-th diagonal and zeros elsewhere.
#'
#' @param N Number of rows in the output.
#' @param M Number of columns in the output. If `None`, defaults to `N`.
#' @param k Index of the diagonal: 0 (the default) refers to the main
#'     diagonal, a positive value refers to an upper diagonal,
#'     and a negative value to a lower diagonal.
#' @param dtype Data type of the returned tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/eye>
k_eye <-
function (N, M = NULL, k = 0L, dtype = NULL)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$eye, args)
}


# keras$ops$flip
# keras.ops.flip
# keras.src.ops.numpy.flip
r"-(Reverse the order of elements in the tensor along the given axis.

    The shape of the tensor is preserved, but the elements are reordered.

    Args:
        x: Input tensor.
        axis: Axis or axes along which to flip the tensor. The default,
            `axis=None`, will flip over all of the axes of the input tensor.

    Returns:
        Output tensor with entries of `axis` reversed.
    )-"

# keras.src.ops.numpy.flip
#' Reverse the order of elements in the tensor along the given axis.
#'
#' @description
#' The shape of the tensor is preserved, but the elements are reordered.
#'
#' # Returns
#'     Output tensor with entries of `axis` reversed.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which to flip the tensor. The default,
#'     `axis=None`, will flip over all of the axes of the input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/flip>
k_flip <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$flip, args)
}


# keras$ops$floor
# keras.ops.floor
# keras.src.ops.numpy.floor
r"-(Return the floor of the input, element-wise.

    The floor of the scalar `x` is the largest integer `i`, such that `i <= x`.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise floor of `x`.
    )-"

# keras.src.ops.numpy.floor
#' Return the floor of the input, element-wise.
#'
#' @description
#' The floor of the scalar `x` is the largest integer `i`, such that `i <= x`.
#'
#' # Returns
#'     Output tensor, element-wise floor of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/floor>
k_floor <-
function (x)
keras$ops$floor(x)


# keras$ops$floor_divide
# keras.ops.floor_divide
# keras.src.ops.numpy.floor_divide
r"-(Returns the largest integer smaller or equal to the division of inputs.

    Args:
        x1: Numerator.
        x2: Denominator.

    Returns:
        Output tensor, `y = floor(x1/x2)`
    )-"

# keras.src.ops.numpy.floor_divide
#' Returns the largest integer smaller or equal to the division of inputs.
#'
#' @description
#'
#' # Returns
#'     Output tensor, `y = floor(x1/x2)`
#'
#' @param x1 Numerator.
#' @param x2 Denominator.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/floor_divide>
k_floor_divide <-
function (x1, x2)
keras$ops$floor_divide(x1, x2)


# keras$ops$full
# keras.ops.full
# keras.src.ops.numpy.full
r"-(Return a new tensor of given shape and type, filled with `fill_value`.

    Args:
        shape: Shape of the new tensor.
        fill_value: Fill value.
        dtype: Desired data type of the tensor.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.full
#' Return a new tensor of given shape and type, filled with `fill_value`.
#'
#' @description
#'
#' # Returns
#'     Output tensor.
#'
#' @param shape Shape of the new tensor.
#' @param fill_value Fill value.
#' @param dtype Desired data type of the tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/full>
k_full <-
function (shape, fill_value, dtype = NULL)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$full, args)
}


# keras$ops$full_like
# keras.ops.full_like
# keras.src.ops.numpy.full_like
r"-(Return a full tensor with the same shape and type as the given tensor.

    Args:
        x: Input tensor.
        fill_value: Fill value.
        dtype: Overrides data type of the result.

    Returns:
        Tensor of `fill_value` with the same shape and type as `x`.
    )-"

# keras.src.ops.numpy.full_like
#' Return a full tensor with the same shape and type as the given tensor.
#'
#' @description
#'
#' # Returns
#'     Tensor of `fill_value` with the same shape and type as `x`.
#'
#' @param x Input tensor.
#' @param fill_value Fill value.
#' @param dtype Overrides data type of the result.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/full_like>
k_full_like <-
function (x, fill_value, dtype = NULL)
keras$ops$full_like(x, fill_value, dtype)


# keras$ops$get_item
# keras.ops.get_item
# keras.src.ops.numpy.get_item
r"-(Return `x[key]`.)-"

# keras.src.ops.numpy.get_item
#' Return `x[key]`.
#'
#' @param x see description
#' @param key see description
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/get_item>
k_get_item <-
function (x, key)
keras$ops$get_item(x, key)


# keras$ops$greater
# keras.ops.greater
# keras.src.ops.numpy.greater
r"-(Return the truth value of `x1 > x2` element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise comparison of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.greater
#' Return the truth value of `x1 > x2` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparison of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/greater>
k_greater <-
function (x1, x2)
keras$ops$greater(x1, x2)


# keras$ops$greater_equal
# keras.ops.greater_equal
# keras.src.ops.numpy.greater_equal
r"-(Return the truth value of `x1 >= x2` element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise comparison of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.greater_equal
#' Return the truth value of `x1 >= x2` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparison of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/greater_equal>
k_greater_equal <-
function (x1, x2)
keras$ops$greater_equal(x1, x2)


# keras$ops$hstack
# keras.ops.hstack
# keras.src.ops.numpy.hstack
r"-(Stack tensors in sequence horizontally (column wise).

    This is equivalent to concatenation along the first axis for 1-D tensors,
    and along the second axis for all other tensors.

    Args:
        xs: Sequence of tensors.

    Returns:
        The tensor formed by stacking the given tensors.
    )-"

# keras.src.ops.numpy.hstack
#' Stack tensors in sequence horizontally (column wise).
#'
#' @description
#' This is equivalent to concatenation along the first axis for 1-D tensors,
#' and along the second axis for all other tensors.
#'
#' # Returns
#'     The tensor formed by stacking the given tensors.
#'
#' @param xs Sequence of tensors.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/hstack>
k_hstack <-
function (xs)
keras$ops$hstack(xs)


# keras$ops$identity
# keras.ops.identity
# keras.src.ops.numpy.identity
r"-(Return the identity tensor.

    The identity tensor is a square tensor with ones on the main diagonal and
    zeros elsewhere.

    Args:
        n: Number of rows (and columns) in the `n x n` output tensor.
        dtype: Data type of the output tensor.

    Returns:
        The identity tensor.
    )-"

# keras.src.ops.numpy.identity
#' Return the identity tensor.
#'
#' @description
#' The identity tensor is a square tensor with ones on the main diagonal and
#' zeros elsewhere.
#'
#' # Returns
#'     The identity tensor.
#'
#' @param n Number of rows (and columns) in the `n x n` output tensor.
#' @param dtype Data type of the output tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/identity>
k_identity <-
function (n, dtype = NULL)
keras$ops$identity(n, dtype)


# keras$ops$imag
# keras.ops.imag
# keras.src.ops.numpy.imag
r"-(Return the imaginary part of the complex argument.

    Args:
        x: Input tensor.

    Returns:
        The imaginary component of the complex argument.
    )-"

# keras.src.ops.numpy.imag
#' Return the imaginary part of the complex argument.
#'
#' @description
#'
#' # Returns
#'     The imaginary component of the complex argument.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/imag>
k_imag <-
function (x)
keras$ops$imag(x)


# keras$ops$isclose
# keras.ops.isclose
# keras.src.ops.numpy.isclose
r"-(Return whether two tensors are element-wise almost equal.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output boolean tensor.
    )-"

# keras.src.ops.numpy.isclose
#' Return whether two tensors are element-wise almost equal.
#'
#' @description
#'
#' # Returns
#'     Output boolean tensor.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/isclose>
k_isclose <-
function (x1, x2)
keras$ops$isclose(x1, x2)


# keras$ops$isfinite
# keras.ops.isfinite
# keras.src.ops.numpy.isfinite
r"-(Return whether a tensor is finite, element-wise.

    Real values are finite when they are not NaN, not positive infinity, and
    not negative infinity. Complex values are finite when both their real
    and imaginary parts are finite.

    Args:
        x: Input tensor.

    Returns:
        Output boolean tensor.
    )-"

# keras.src.ops.numpy.isfinite
#' Return whether a tensor is finite, element-wise.
#'
#' @description
#' Real values are finite when they are not NaN, not positive infinity, and
#' not negative infinity. Complex values are finite when both their real
#' and imaginary parts are finite.
#'
#' # Returns
#'     Output boolean tensor.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/isfinite>
k_isfinite <-
function (x)
keras$ops$isfinite(x)


# keras$ops$isinf
# keras.ops.isinf
# keras.src.ops.numpy.isinf
r"-(Test element-wise for positive or negative infinity.

    Args:
        x: Input tensor.

    Returns:
        Output boolean tensor.
    )-"

# keras.src.ops.numpy.isinf
#' Test element-wise for positive or negative infinity.
#'
#' @description
#'
#' # Returns
#'     Output boolean tensor.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/isinf>
k_isinf <-
function (x)
keras$ops$isinf(x)


# keras$ops$isnan
# keras.ops.isnan
# keras.src.ops.numpy.isnan
r"-(Test element-wise for NaN and return result as a boolean tensor.

    Args:
        x: Input tensor.

    Returns:
        Output boolean tensor.
    )-"

# keras.src.ops.numpy.isnan
#' Test element-wise for NaN and return result as a boolean tensor.
#'
#' @description
#'
#' # Returns
#'     Output boolean tensor.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/isnan>
k_isnan <-
function (x)
keras$ops$isnan(x)


# keras$ops$less
# keras.ops.less
# keras.src.ops.numpy.less
r"-(Return the truth value of `x1 < x2` element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise comparison of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.less
#' Return the truth value of `x1 < x2` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparison of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/less>
k_less <-
function (x1, x2)
keras$ops$less(x1, x2)


# keras$ops$less_equal
# keras.ops.less_equal
# keras.src.ops.numpy.less_equal
r"-(Return the truth value of `x1 <= x2` element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise comparison of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.less_equal
#' Return the truth value of `x1 <= x2` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparison of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/less_equal>
k_less_equal <-
function (x1, x2)
keras$ops$less_equal(x1, x2)


# keras$ops$linspace
# keras.ops.linspace
# keras.src.ops.numpy.linspace
r"-(Return evenly spaced numbers over a specified interval.

    Returns `num` evenly spaced samples, calculated over the interval
    `[start, stop]`.

    The endpoint of the interval can optionally be excluded.

    Args:
        start: The starting value of the sequence.
        stop: The end value of the sequence, unless `endpoint` is set to
            `False`. In that case, the sequence consists of all but the last
            of `num + 1` evenly spaced samples, so that `stop` is excluded.
            Note that the step size changes when `endpoint` is `False`.
        num: Number of samples to generate. Defaults to `50`. Must be
            non-negative.
        endpoint: If `True`, `stop` is the last sample. Otherwise, it is
            not included. Defaults to`True`.
        retstep: If `True`, return `(samples, step)`, where `step` is the
            spacing between samples.
        dtype: The type of the output tensor.
        axis: The axis in the result to store the samples. Relevant only if
            start or stop are array-like. Defaults to `0`.

    Note:
        Torch backend does not support `axis` argument.

    Returns:
        A tensor of evenly spaced numbers.
        If `retstep` is `True`, returns `(samples, step)`
    )-"

# keras.src.ops.numpy.linspace
#' Return evenly spaced numbers over a specified interval.
#'
#' @description
#' Returns `num` evenly spaced samples, calculated over the interval
#' `[start, stop]`.
#'
#' The endpoint of the interval can optionally be excluded.
#'
#' # Note
#' Torch backend does not support `axis` argument.
#'
#' # Returns
#' A tensor of evenly spaced numbers.
#' If `retstep` is `True`, returns `(samples, step)`
#'
#' @param start The starting value of the sequence.
#' @param stop The end value of the sequence, unless `endpoint` is set to
#'     `False`. In that case, the sequence consists of all but the last
#'     of `num + 1` evenly spaced samples, so that `stop` is excluded.
#'     Note that the step size changes when `endpoint` is `False`.
#' @param num Number of samples to generate. Defaults to `50`. Must be
#'     non-negative.
#' @param endpoint If `True`, `stop` is the last sample. Otherwise, it is
#'     not included. Defaults to`True`.
#' @param retstep If `True`, return `(samples, step)`, where `step` is the
#'     spacing between samples.
#' @param dtype The type of the output tensor.
#' @param axis The axis in the result to store the samples. Relevant only if
#'     start or stop are array-like. Defaults to `0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/linspace>
k_linspace <-
function (start, stop, num = 50L, endpoint = TRUE, retstep = FALSE,
    dtype = NULL, axis = 0L)
{
    args <- capture_args2(list(num = as_integer, axis = as_axis))
    do.call(keras$ops$linspace, args)
}


# keras$ops$log
# keras.ops.log
# keras.src.ops.numpy.log
r"-(Natural logarithm, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise natural logarithm of `x`.
    )-"

# keras.src.ops.numpy.log
#' Natural logarithm, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise natural logarithm of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log>
k_log <-
function (x)
keras$ops$log(x)


# keras$ops$log10
# keras.ops.log10
# keras.src.ops.numpy.log10
r"-(Return the base 10 logarithm of the input tensor, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise base 10 logarithm of `x`.
    )-"

# keras.src.ops.numpy.log10
#' Return the base 10 logarithm of the input tensor, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise base 10 logarithm of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log10>
k_log10 <-
function (x)
keras$ops$log10(x)


# keras$ops$log1p
# keras.ops.log1p
# keras.src.ops.numpy.log1p
r"-(Returns the natural logarithm of one plus the `x`, element-wise.

    Calculates `log(1 + x)`.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise natural logarithm of `1 + x`.
    )-"

# keras.src.ops.numpy.log1p
#' Returns the natural logarithm of one plus the `x`, element-wise.
#'
#' @description
#' Calculates `log(1 + x)`.
#'
#' # Returns
#'     Output tensor, element-wise natural logarithm of `1 + x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log1p>
k_log1p <-
function (x)
keras$ops$log1p(x)


# keras$ops$log2
# keras.ops.log2
# keras.src.ops.numpy.log2
r"-(Base-2 logarithm of `x`, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise base-2 logarithm of `x`.
    )-"

# keras.src.ops.numpy.log2
#' Base-2 logarithm of `x`, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise base-2 logarithm of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/log2>
k_log2 <-
function (x)
keras$ops$log2(x)


# keras$ops$logaddexp
# keras.ops.logaddexp
# keras.src.ops.numpy.logaddexp
r"-(Logarithm of the sum of exponentiations of the inputs.

    Calculates `log(exp(x1) + exp(x2))`.

    Args:
        x1: Input tensor.
        x2: Input tensor.

    Returns:
        Output tensor, element-wise logarithm of the sum of exponentiations
        of the inputs.
    )-"

# keras.src.ops.numpy.logaddexp
#' Logarithm of the sum of exponentiations of the inputs.
#'
#' @description
#' Calculates `log(exp(x1) + exp(x2))`.
#'
#' # Returns
#' Output tensor, element-wise logarithm of the sum of exponentiations
#' of the inputs.
#'
#' @param x1 Input tensor.
#' @param x2 Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logaddexp>
k_logaddexp <-
function (x1, x2)
keras$ops$logaddexp(x1, x2)


# keras$ops$logical_and
# keras.ops.logical_and
# keras.src.ops.numpy.logical_and
r"-(Computes the element-wise logical AND of the given input tensors.

    Zeros are treated as `False` and non-zeros are treated as `True`.

    Args:
        x1: Input tensor.
        x2: Input tensor.

    Returns:
        Output tensor, element-wise logical AND of the inputs.
    )-"

# keras.src.ops.numpy.logical_and
#' Computes the element-wise logical AND of the given input tensors.
#'
#' @description
#' Zeros are treated as `False` and non-zeros are treated as `True`.
#'
#' # Returns
#'     Output tensor, element-wise logical AND of the inputs.
#'
#' @param x1 Input tensor.
#' @param x2 Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logical_and>
k_logical_and <-
function (x1, x2)
keras$ops$logical_and(x1, x2)


# keras$ops$logical_not
# keras.ops.logical_not
# keras.src.ops.numpy.logical_not
r"-(Computes the element-wise NOT of the given input tensor.

    Zeros are treated as `False` and non-zeros are treated as `True`.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise logical NOT of the input.
    )-"

# keras.src.ops.numpy.logical_not
#' Computes the element-wise NOT of the given input tensor.
#'
#' @description
#' Zeros are treated as `False` and non-zeros are treated as `True`.
#'
#' # Returns
#'     Output tensor, element-wise logical NOT of the input.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logical_not>
k_logical_not <-
function (x)
keras$ops$logical_not(x)


# keras$ops$logical_or
# keras.ops.logical_or
# keras.src.ops.numpy.logical_or
r"-(Computes the element-wise logical OR of the given input tensors.

    Zeros are treated as `False` and non-zeros are treated as `True`.

    Args:
        x1: Input tensor.
        x2: Input tensor.

    Returns:
        Output tensor, element-wise logical OR of the inputs.
    )-"

# keras.src.ops.numpy.logical_or
#' Computes the element-wise logical OR of the given input tensors.
#'
#' @description
#' Zeros are treated as `False` and non-zeros are treated as `True`.
#'
#' # Returns
#'     Output tensor, element-wise logical OR of the inputs.
#'
#' @param x1 Input tensor.
#' @param x2 Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logical_or>
k_logical_or <-
function (x1, x2)
keras$ops$logical_or(x1, x2)


# keras$ops$logical_xor
# keras.ops.logical_xor
# keras.src.ops.numpy.logical_xor
r"-(Compute the truth value of `x1 XOR x2`, element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output boolean tensor.
    )-"

# keras.src.ops.numpy.logical_xor
#' Compute the truth value of `x1 XOR x2`, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output boolean tensor.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logical_xor>
k_logical_xor <-
function (x1, x2)
keras$ops$logical_xor(x1, x2)


# keras$ops$logspace
# keras.ops.logspace
# keras.src.ops.numpy.logspace
r"-(Returns numbers spaced evenly on a log scale.

    In linear space, the sequence starts at `base ** start` and ends with
    `base ** stop` (see `endpoint` below).

    Args:
        start: The starting value of the sequence.
        stop: The final value of the sequence, unless `endpoint` is `False`.
            In that case, `num + 1` values are spaced over the interval in
            log-space, of which all but the last (a sequence of length `num`)
            are returned.
        num: Number of samples to generate. Defaults to `50`.
        endpoint: If `True`, `stop` is the last sample. Otherwise, it is not
            included. Defaults to`True`.
        base: The base of the log space. Defaults to `10`.
        dtype: The type of the output tensor.
        axis: The axis in the result to store the samples. Relevant only
            if start or stop are array-like.

    Note:
        Torch backend does not support `axis` argument.

    Returns:
        A tensor of evenly spaced samples on a log scale.
    )-"

# keras.src.ops.numpy.logspace
#' Returns numbers spaced evenly on a log scale.
#'
#' @description
#' In linear space, the sequence starts at `base ** start` and ends with
#' `base ** stop` (see `endpoint` below).
#'
#' # Note
#' Torch backend does not support `axis` argument.
#'
#' # Returns
#'     A tensor of evenly spaced samples on a log scale.
#'
#' @param start The starting value of the sequence.
#' @param stop The final value of the sequence, unless `endpoint` is `False`.
#'     In that case, `num + 1` values are spaced over the interval in
#'     log-space, of which all but the last (a sequence of length `num`)
#'     are returned.
#' @param num Number of samples to generate. Defaults to `50`.
#' @param endpoint If `True`, `stop` is the last sample. Otherwise, it is not
#'     included. Defaults to`True`.
#' @param base The base of the log space. Defaults to `10`.
#' @param dtype The type of the output tensor.
#' @param axis The axis in the result to store the samples. Relevant only
#'     if start or stop are array-like.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/logspace>
k_logspace <-
function (start, stop, num = 50L, endpoint = TRUE, base = 10L,
    dtype = NULL, axis = 0L)
{
    args <- capture_args2(list(num = as_integer, base = as_integer,
        axis = as_axis))
    do.call(keras$ops$logspace, args)
}


# keras$ops$matmul
# keras.ops.matmul
# keras.src.ops.numpy.matmul
r"-(Matrix product of two tensors.

    - If both tensors are 1-dimensional, the dot product (scalar) is returned.
    - If either tensor is N-D, N > 2, it is treated as a stack of matrices
      residing in the last two indexes and broadcast accordingly.
    - If the first tensor is 1-D, it is promoted to a matrix by prepending
      a 1 to its dimensions. After matrix multiplication the prepended
      1 is removed.
    - If the second tensor is 1-D, it is promoted to a matrix by appending a 1
      to its dimensions. After matrix multiplication the appended 1 is removed.

    Args:
        x1: First tensor.
        x2: Second tensor.

    Returns:
        Output tensor, matrix product of the inputs.
    )-"

# keras.src.ops.numpy.matmul
#' Matrix product of two tensors.
#'
#' @description
#' - If both tensors are 1-dimensional, the dot product (scalar) is returned.
#' - If either tensor is N-D, N > 2, it is treated as a stack of matrices
#'   residing in the last two indexes and broadcast accordingly.
#' - If the first tensor is 1-D, it is promoted to a matrix by prepending
#'   a 1 to its dimensions. After matrix multiplication the prepended
#'   1 is removed.
#' - If the second tensor is 1-D, it is promoted to a matrix by appending a 1
#'   to its dimensions. After matrix multiplication the appended 1 is removed.
#'
#' # Returns
#'     Output tensor, matrix product of the inputs.
#'
#' @param x1 First tensor.
#' @param x2 Second tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/matmul>
k_matmul <-
function (x1, x2)
keras$ops$matmul(x1, x2)


# keras$ops$max
# keras.ops.max
# keras.src.ops.numpy.max
r"-(Return the maximum of a tensor or maximum along an axis.

    Args:
        x: Input tensor.
        axis: Axis or axes along which to operate. By default, flattened input
            is used.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one. Defaults to`False`.
        initial: The minimum value of an output element. Defaults to`None`.

    Returns:
        Maximum of `x`.
    )-"

# keras.src.ops.numpy.max
#' Return the maximum of a tensor or maximum along an axis.
#'
#' @description
#'
#' # Returns
#'     Maximum of `x`.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which to operate. By default, flattened input
#'     is used.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one. Defaults to`False`.
#' @param initial The minimum value of an output element. Defaults to`None`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/max>
k_max <-
function (x, axis = NULL, keepdims = FALSE, initial = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$max, args)
}


# keras$ops$maximum
# keras.ops.maximum
# keras.src.ops.numpy.maximum
r"-(Element-wise maximum of `x1` and `x2`.

    Args:
        x1: First tensor.
        x2: Second tensor.

    Returns:
        Output tensor, element-wise maximum of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.maximum
#' Element-wise maximum of `x1` and `x2`.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise maximum of `x1` and `x2`.
#'
#' @param x1 First tensor.
#' @param x2 Second tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/maximum>
k_maximum <-
function (x1, x2)
keras$ops$maximum(x1, x2)


# keras$ops$mean
# keras.ops.mean
# keras.src.ops.numpy.mean
r"-(Compute the arithmetic mean along the specified axes.

    Args:
        x: Input tensor.
        axis: Axis or axes along which the means are computed. The default
            is to compute the mean of the flattened tensor.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one.

    Returns:
        Output tensor containing the mean values.
    )-"

# keras.src.ops.numpy.mean
#' Compute the arithmetic mean along the specified axes.
#'
#' @description
#'
#' # Returns
#'     Output tensor containing the mean values.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which the means are computed. The default
#'     is to compute the mean of the flattened tensor.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/mean>
k_mean <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$mean, args)
}


# keras$ops$median
# keras.ops.median
# keras.src.ops.numpy.median
r"-(Compute the median along the specified axis.

    Args:
        x: Input tensor.
        axis: Axis or axes along which the medians are computed. Defaults to
            `axis=None` which is to compute the median(s) along a flattened
            version of the array.
        keepdims: If this is set to `True`, the axes which are reduce
            are left in the result as dimensions with size one.

    Returns:
        The output tensor.
    )-"

# keras.src.ops.numpy.median
#' Compute the median along the specified axis.
#'
#' @description
#'
#' # Returns
#'     The output tensor.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which the medians are computed. Defaults to
#'     `axis=None` which is to compute the median(s) along a flattened
#'     version of the array.
#' @param keepdims If this is set to `True`, the axes which are reduce
#'     are left in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/median>
k_median <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$median, args)
}


# keras$ops$meshgrid
# keras.ops.meshgrid
# keras.src.ops.numpy.meshgrid
r"-(Creates grids of coordinates from coordinate vectors.

    Given `N` 1-D tensors `T0, T1, ..., TN-1` as inputs with corresponding
    lengths `S0, S1, ..., SN-1`, this creates an `N` N-dimensional tensors
    `G0, G1, ..., GN-1` each with shape `(S0, ..., SN-1)` where the output
    `Gi` is constructed by expanding `Ti` to the result shape.

    Args:
        x: 1-D tensors representing the coordinates of a grid.
        indexing: Cartesian (`"xy"`, default) or matrix (`"ij"`) indexing
            of output.

    Returns:
        Sequence of N tensors.

    Example:
    >>> from keras import ops
    >>> x = ops.array([1, 2, 3])
    >>> y = ops.array([4, 5, 6])

    >>> grid_x, grid_y = ops.meshgrid(x, y, indexing="ij")
    >>> grid_x
    array([[1, 1, 1],
           [2, 2, 2],
           [3, 3, 3]])
    >>> grid_y
    array([[4, 5, 6],
           [4, 5, 6],
           [4, 5, 6]])
    )-"

# keras.src.ops.numpy.meshgrid
#' Creates grids of coordinates from coordinate vectors.
#'
#' @description
#' Given `N` 1-D tensors `T0, T1, ..., TN-1` as inputs with corresponding
#' lengths `S0, S1, ..., SN-1`, this creates an `N` N-dimensional tensors
#' `G0, G1, ..., GN-1` each with shape `(S0, ..., SN-1)` where the output
#' `Gi` is constructed by expanding `Ti` to the result shape.
#'
#' # Returns
#' Sequence of N tensors.
#'
#' # Examples
#' ```python
#' from keras import ops
#' x = ops.array([1, 2, 3])
#' y = ops.array([4, 5, 6])
#' ```
#'
#' ```python
#' grid_x, grid_y = ops.meshgrid(x, y, indexing="ij")
#' grid_x
#' # array([[1, 1, 1],
#' #        [2, 2, 2],
#' #        [3, 3, 3]])
#' grid_y
#' # array([[4, 5, 6],
#' #        [4, 5, 6],
#' #        [4, 5, 6]])
#' ```
#'
#' @param ... 1-D tensors representing the coordinates of a grid.
#' @param indexing Cartesian (`"xy"`, default) or matrix (`"ij"`) indexing
#'     of output.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/meshgrid>
k_meshgrid <-
function (..., indexing = "xy")
keras$ops$meshgrid(..., indexing)


# keras$ops$min
# keras.ops.min
# keras.src.ops.numpy.min
r"-(Return the minimum of a tensor or minimum along an axis.

    Args:
        x: Input tensor.
        axis: Axis or axes along which to operate. By default, flattened input
            is used.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one. Defaults to`False`.
        initial: The maximum value of an output element. Defaults to`None`.

    Returns:
        Minimum of `x`.
    )-"

# keras.src.ops.numpy.min
#' Return the minimum of a tensor or minimum along an axis.
#'
#' @description
#'
#' # Returns
#'     Minimum of `x`.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which to operate. By default, flattened input
#'     is used.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one. Defaults to`False`.
#' @param initial The maximum value of an output element. Defaults to`None`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/min>
k_min <-
function (x, axis = NULL, keepdims = FALSE, initial = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$min, args)
}


# keras$ops$minimum
# keras.ops.minimum
# keras.src.ops.numpy.minimum
r"-(Element-wise minimum of `x1` and `x2`.

    Args:
        x1: First tensor.
        x2: Second tensor.

    Returns:
        Output tensor, element-wise minimum of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.minimum
#' Element-wise minimum of `x1` and `x2`.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise minimum of `x1` and `x2`.
#'
#' @param x1 First tensor.
#' @param x2 Second tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/minimum>
k_minimum <-
function (x1, x2)
keras$ops$minimum(x1, x2)


# keras$ops$mod
# keras.ops.mod
# keras.src.ops.numpy.mod
r"-(Returns the element-wise remainder of division.

    Args:
        x1: First tensor.
        x2: Second tensor.

    Returns:
        Output tensor, element-wise remainder of division.
    )-"

# keras.src.ops.numpy.mod
#' Returns the element-wise remainder of division.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise remainder of division.
#'
#' @param x1 First tensor.
#' @param x2 Second tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/mod>
k_mod <-
function (x1, x2)
keras$ops$mod(x1, x2)


# keras$ops$moveaxis
# keras.ops.moveaxis
# keras.src.ops.numpy.moveaxis
r"-(Move axes of a tensor to new positions.

    Other axes remain in their original order.

    Args:
        x: Tensor whose axes should be reordered.
        source: Original positions of the axes to move. These must be unique.
        destination: Destinations positions for each of the original axes.
            These must also be unique.

    Returns:
        Tensor with moved axes.
    )-"

# keras.src.ops.numpy.moveaxis
#' Move axes of a tensor to new positions.
#'
#' @description
#' Other axes remain in their original order.
#'
#' # Returns
#'     Tensor with moved axes.
#'
#' @param x Tensor whose axes should be reordered.
#' @param source Original positions of the axes to move. These must be unique.
#' @param destination Destinations positions for each of the original axes.
#'     These must also be unique.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/moveaxis>
k_moveaxis <-
function (x, source, destination)
keras$ops$moveaxis(x, source, destination)


# keras$ops$multiply
# keras.ops.multiply
# keras.src.ops.numpy.multiply
r"-(Multiply arguments element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise product of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.multiply
#' Multiply arguments element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise product of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/multiply>
k_multiply <-
function (x1, x2)
keras$ops$multiply(x1, x2)


# keras$ops$nan_to_num
# keras.ops.nan_to_num
# keras.src.ops.numpy.nan_to_num
r"-(Replace NaN with zero and infinity with large finite numbers.

    Args:
        x: Input data.

    Returns:
        `x`, with non-finite values replaced.
    )-"

# keras.src.ops.numpy.nan_to_num
#' Replace NaN with zero and infinity with large finite numbers.
#'
#' @description
#'
#' # Returns
#'     `x`, with non-finite values replaced.
#'
#' @param x Input data.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/nan_to_num>
k_nan_to_num <-
function (x)
keras$ops$nan_to_num(x)


# keras$ops$ndim
# keras.ops.ndim
# keras.src.ops.numpy.ndim
r"-(Return the number of dimensions of a tensor.

    Args:
        x: Input tensor.

    Returns:
        The number of dimensions in `x`.
    )-"

# keras.src.ops.numpy.ndim
#' Return the number of dimensions of a tensor.
#'
#' @description
#'
#' # Returns
#'     The number of dimensions in `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/ndim>
k_ndim <-
function (x)
keras$ops$ndim(x)


# keras$ops$negative
# keras.ops.negative
# keras.src.ops.numpy.negative
r"-(Numerical negative, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, `y = -x`.
    )-"

# keras.src.ops.numpy.negative
#' Numerical negative, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, `y = -x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/negative>
k_negative <-
function (x)
keras$ops$negative(x)


# keras$ops$nonzero
# keras.ops.nonzero
# keras.src.ops.numpy.nonzero
r"-(Return the indices of the elements that are non-zero.

    Args:
        x: Input tensor.

    Returns:
        Indices of elements that are non-zero.
    )-"

# keras.src.ops.numpy.nonzero
#' Return the indices of the elements that are non-zero.
#'
#' @description
#'
#' # Returns
#'     Indices of elements that are non-zero.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/nonzero>
k_nonzero <-
function (x)
keras$ops$nonzero(x)


# keras$ops$not_equal
# keras.ops.not_equal
# keras.src.ops.numpy.not_equal
r"-(Return `(x1 != x2)` element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise comparsion of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.not_equal
#' Return `(x1 != x2)` element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise comparsion of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/not_equal>
k_not_equal <-
function (x1, x2)
keras$ops$not_equal(x1, x2)


# keras$ops$ones
# keras.ops.ones
# keras.src.ops.numpy.ones
r"-(Return a new tensor of given shape and type, filled with ones.

    Args:
        shape: Shape of the new tensor.
        dtype: Desired data type of the tensor.

    Returns:
        Tensor of ones with the given shape and dtype.
    )-"

# keras.src.ops.numpy.ones
#' Return a new tensor of given shape and type, filled with ones.
#'
#' @description
#'
#' # Returns
#'     Tensor of ones with the given shape and dtype.
#'
#' @param shape Shape of the new tensor.
#' @param dtype Desired data type of the tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/ones>
k_ones <-
function (shape, dtype = NULL)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$ones, args)
}


# keras$ops$ones_like
# keras.ops.ones_like
# keras.src.ops.numpy.ones_like
r"-(Return a tensor of ones with the same shape and type of `x`.

    Args:
        x: Input tensor.
        dtype: Overrides the data type of the result.

    Returns:
        A tensor of ones with the same shape and type as `x`.
    )-"

# keras.src.ops.numpy.ones_like
#' Return a tensor of ones with the same shape and type of `x`.
#'
#' @description
#'
#' # Returns
#'     A tensor of ones with the same shape and type as `x`.
#'
#' @param x Input tensor.
#' @param dtype Overrides the data type of the result.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/ones_like>
k_ones_like <-
function (x, dtype = NULL)
keras$ops$ones_like(x, dtype)


# keras$ops$outer
# keras.ops.outer
# keras.src.ops.numpy.outer
r"-(Compute the outer product of two vectors.

    Given two vectors `x1` and `x2`, the outer product is:

    ```
    out[i, j] = x1[i] * x2[j]
    ```

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Outer product of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.outer
#' Compute the outer product of two vectors.
#'
#' @description
#' Given two vectors `x1` and `x2`, the outer product is:
#'
#' ```
#' out[i, j] = x1[i] * x2[j]
#' ```
#'
#' # Returns
#'     Outer product of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/outer>
k_outer <-
function (x1, x2)
keras$ops$outer(x1, x2)


# keras$ops$pad
# keras.ops.pad
# keras.src.ops.numpy.pad
r"-(Pad a tensor.

    Args:
        x: Tensor to pad.
        pad_width: Number of values padded to the edges of each axis.
            `((before_1, after_1), ...(before_N, after_N))` unique pad
            widths for each axis.
            `((before, after),)` yields same before and after pad for
            each axis.
            `(pad,)` or `int` is a shortcut for `before = after = pad`
            width for all axes.
        mode: One of `"constant"`, `"edge"`, `"linear_ramp"`,
            `"maximum"`, `"mean"`, `"median"`, `"minimum"`,
            `"reflect"`, `"symmetric"`, `"wrap"`, `"empty"`,
            `"circular"`. Defaults to`"constant"`.

    Note:
        Torch backend only supports modes `"constant"`, `"reflect"`,
        `"symmetric"` and `"circular"`.
        Only Torch backend supports `"circular"` mode.

    Note:
        Tensorflow backend only supports modes `"constant"`, `"reflect"`
        and `"symmetric"`.

    Returns:
        Padded tensor.
    )-"

# keras.src.ops.numpy.pad
#' Pad a tensor.
#'
#' @description
#'
#' # Note
#' Torch backend only supports modes `"constant"`, `"reflect"`,
#'     `"symmetric"` and `"circular"`.
#'     Only Torch backend supports `"circular"` mode.
#'
#' Note:
#'     Tensorflow backend only supports modes `"constant"`, `"reflect"`
#'     and `"symmetric"`.
#'
#' # Returns
#'     Padded tensor.
#'
#' @param x Tensor to pad.
#' @param pad_width Number of values padded to the edges of each axis.
#'     `((before_1, after_1), ...(before_N, after_N))` unique pad
#'     widths for each axis.
#'     `((before, after),)` yields same before and after pad for
#'     each axis.
#'     `(pad,)` or `int` is a shortcut for `before = after = pad`
#'     width for all axes.
#' @param mode One of `"constant"`, `"edge"`, `"linear_ramp"`,
#'     `"maximum"`, `"mean"`, `"median"`, `"minimum"`,
#'     `"reflect"`, `"symmetric"`, `"wrap"`, `"empty"`,
#'     `"circular"`. Defaults to`"constant"`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/pad>
k_pad <-
function (x, pad_width, mode = "constant")
{
    args <- capture_args2(list(pad_width = as_integer))
    do.call(keras$ops$pad, args)
}


# keras$ops$power
# keras.ops.power
# keras.src.ops.numpy.power
r"-(First tensor elements raised to powers from second tensor, element-wise.

    Args:
        x1: The bases.
        x2: The exponents.

    Returns:
        Output tensor, the bases in `x1` raised to the exponents in `x2`.
    )-"

# keras.src.ops.numpy.power
#' First tensor elements raised to powers from second tensor, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, the bases in `x1` raised to the exponents in `x2`.
#'
#' @param x1 The bases.
#' @param x2 The exponents.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/power>
k_power <-
function (x1, x2)
keras$ops$power(x1, x2)


# keras$ops$prod
# keras.ops.prod
# keras.src.ops.numpy.prod
r"-(Return the product of tensor elements over a given axis.

    Args:
        x: Input tensor.
        axis: Axis or axes along which a product is performed. The default,
            `axis=None`, will compute the product of all elements
            in the input tensor.
        keepdims: If this is set to `True`, the axes which are reduce
            are left in the result as dimensions with size one.
        dtype: Data type of the returned tensor.

    Returns:
        Product of elements of `x` over the given axis or axes.
    )-"

# keras.src.ops.numpy.prod
#' Return the product of tensor elements over a given axis.
#'
#' @description
#'
#' # Returns
#'     Product of elements of `x` over the given axis or axes.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which a product is performed. The default,
#'     `axis=None`, will compute the product of all elements
#'     in the input tensor.
#' @param keepdims If this is set to `True`, the axes which are reduce
#'     are left in the result as dimensions with size one.
#' @param dtype Data type of the returned tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/prod>
k_prod <-
function (x, axis = NULL, keepdims = FALSE, dtype = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$prod, args)
}


# keras$ops$quantile
# keras.ops.quantile
# keras.src.ops.numpy.quantile
r"-(Compute the q-th quantile(s) of the data along the specified axis.

    Args:
        x: Input tensor.
        q: Probability or sequence of probabilities for the quantiles to
            compute. Values must be between 0 and 1 inclusive.
        axis: Axis or axes along which the quantiles are computed. Defaults to
            `axis=None` which is to compute the quantile(s) along a flattened
            version of the array.
        method: A string specifies the method to use for estimating the
            quantile. Available methods are `"linear"`, `"lower"`, `"higher"`,
            `"midpoint"`, and `"nearest"`. Defaults to `"linear"`.
            If the desired quantile lies between two data points `i < j`:
            - `"linear"`: `i + (j - i) * fraction`, where fraction is the
                fractional part of the index surrounded by `i` and `j`.
            - `"lower"`: `i`.
            - `"higher"`: `j`.
            - `"midpoint"`: `(i + j) / 2`
            - `"nearest"`: `i` or `j`, whichever is nearest.
        keepdims: If this is set to `True`, the axes which are reduce
            are left in the result as dimensions with size one.

    Returns:
        The quantile(s). If `q` is a single probability and `axis=None`, then
        the result is a scalar. If multiple probabilies levels are given, first
        axis of the result corresponds to the quantiles. The other axes are the
        axes that remain after the reduction of `x`.
    )-"

# keras.src.ops.numpy.quantile
#' Compute the q-th quantile(s) of the data along the specified axis.
#'
#' @description
#'
#' # Returns
#' The quantile(s). If `q` is a single probability and `axis=None`, then
#' the result is a scalar. If multiple probabilies levels are given, first
#' axis of the result corresponds to the quantiles. The other axes are the
#' axes that remain after the reduction of `x`.
#'
#' @param x Input tensor.
#' @param q Probability or sequence of probabilities for the quantiles to
#'     compute. Values must be between 0 and 1 inclusive.
#' @param axis Axis or axes along which the quantiles are computed. Defaults to
#'     `axis=None` which is to compute the quantile(s) along a flattened
#'     version of the array.
#' @param method A string specifies the method to use for estimating the
#'     quantile. Available methods are `"linear"`, `"lower"`, `"higher"`,
#'     `"midpoint"`, and `"nearest"`. Defaults to `"linear"`.
#'     If the desired quantile lies between two data points `i < j`:
#'     - `"linear"`: `i + (j - i) * fraction`, where fraction is the
#'         fractional part of the index surrounded by `i` and `j`.
#'     - `"lower"`: `i`.
#'     - `"higher"`: `j`.
#'     - `"midpoint"`: `(i + j) / 2`
#'     - `"nearest"`: `i` or `j`, whichever is nearest.
#' @param keepdims If this is set to `True`, the axes which are reduce
#'     are left in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/quantile>
k_quantile <-
function (x, q, axis = NULL, method = "linear", keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$quantile, args)
}


# keras$ops$ravel
# keras.ops.ravel
# keras.src.ops.numpy.ravel
r"-(Return a contiguous flattened tensor.

    A 1-D tensor, containing the elements of the input, is returned.

    Args:
        x: Input tensor.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.ravel
#' Return a contiguous flattened tensor.
#'
#' @description
#' A 1-D tensor, containing the elements of the input, is returned.
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/ravel>
k_ravel <-
function (x)
keras$ops$ravel(x)


# keras$ops$real
# keras.ops.real
# keras.src.ops.numpy.real
r"-(Return the real part of the complex argument.

    Args:
        x: Input tensor.

    Returns:
        The real component of the complex argument.
    )-"

# keras.src.ops.numpy.real
#' Return the real part of the complex argument.
#'
#' @description
#'
#' # Returns
#'     The real component of the complex argument.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/real>
k_real <-
function (x)
keras$ops$real(x)


# keras$ops$reciprocal
# keras.ops.reciprocal
# keras.src.ops.numpy.reciprocal
r"-(Return the reciprocal of the argument, element-wise.

    Calculates `1/x`.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, element-wise reciprocal of `x`.
    )-"

# keras.src.ops.numpy.reciprocal
#' Return the reciprocal of the argument, element-wise.
#'
#' @description
#' Calculates `1/x`.
#'
#' # Returns
#'     Output tensor, element-wise reciprocal of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/reciprocal>
k_reciprocal <-
function (x)
keras$ops$reciprocal(x)


# keras$ops$`repeat`
# keras.ops.repeat
# keras.src.ops.numpy.repeat
r"-(Repeat each element of a tensor after themselves.

    Args:
        x: Input tensor.
        repeats: The number of repetitions for each element.
        axis: The axis along which to repeat values. By default, use
            the flattened input array, and return a flat output array.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.repeat
#' Repeat each element of a tensor after themselves.
#'
#' @description
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#' @param repeats The number of repetitions for each element.
#' @param axis The axis along which to repeat values. By default, use
#'     the flattened input array, and return a flat output array.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/repeat>
k_repeat <-
function (x, repeats, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$`repeat`, args)
}


# keras$ops$reshape
# keras.ops.reshape
# keras.src.ops.numpy.reshape
r"-(Gives a new shape to a tensor without changing its data.

    Args:
        x: Input tensor.
        new_shape: The new shape should be compatible with the original shape.
            One shape dimension can be -1 in which case the value is
            inferred from the length of the array and remaining dimensions.

    Returns:
        The reshaped tensor.
    )-"

# keras.src.ops.numpy.reshape
#' Gives a new shape to a tensor without changing its data.
#'
#' @description
#'
#' # Returns
#'     The reshaped tensor.
#'
#' @param x Input tensor.
#' @param new_shape The new shape should be compatible with the original shape.
#'     One shape dimension can be -1 in which case the value is
#'     inferred from the length of the array and remaining dimensions.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/reshape>
k_reshape <-
function (x, new_shape)
keras$ops$reshape(x, new_shape)


# keras$ops$roll
# keras.ops.roll
# keras.src.ops.numpy.roll
r"-(Roll tensor elements along a given axis.

    Elements that roll beyond the last position are re-introduced at the first.

    Args:
        x: Input tensor.
        shift: The number of places by which elements are shifted.
        axis: The axis along which elements are shifted. By default, the
            array is flattened before shifting, after which the original
            shape is restored.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.roll
#' Roll tensor elements along a given axis.
#'
#' @description
#' Elements that roll beyond the last position are re-introduced at the first.
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#' @param shift The number of places by which elements are shifted.
#' @param axis The axis along which elements are shifted. By default, the
#'     array is flattened before shifting, after which the original
#'     shape is restored.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/roll>
k_roll <-
function (x, shift, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$roll, args)
}


# keras$ops$round
# keras.ops.round
# keras.src.ops.numpy.round
r"-(Evenly round to the given number of decimals.

    Args:
        x: Input tensor.
        decimals: Number of decimal places to round to. Defaults to `0`.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.round
#' Evenly round to the given number of decimals.
#'
#' @description
#'
#' # Returns
#'     Output tensor.
#'
#' @param x Input tensor.
#' @param decimals Number of decimal places to round to. Defaults to `0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/round>
k_round <-
function (x, decimals = 0L)
{
    args <- capture_args2(list(decimals = as_integer))
    do.call(keras$ops$round, args)
}


# keras$ops$sign
# keras.ops.sign
# keras.src.ops.numpy.sign
r"-(Returns a tensor with the signs of the elements of `x`.

    Args:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.sign
#' Returns a tensor with the signs of the elements of `x`.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sign>
k_sign <-
function (x)
keras$ops$sign(x)


# keras$ops$sin
# keras.ops.sin
# keras.src.ops.numpy.sin
r"-(Trigonomeric sine, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.sin
#' Trigonomeric sine, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sin>
k_sin <-
function (x)
keras$ops$sin(x)


# keras$ops$sinh
# keras.ops.sinh
# keras.src.ops.numpy.sinh
r"-(Hyperbolic sine, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.sinh
#' Hyperbolic sine, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sinh>
k_sinh <-
function (x)
keras$ops$sinh(x)


# keras$ops$size
# keras.ops.size
# keras.src.ops.numpy.size
r"-(Return the number of elements in a tensor.

    Args:
        x: Input tensor.

    Returns:
        Number of elements in `x`.
    )-"

# keras.src.ops.numpy.size
#' Return the number of elements in a tensor.
#'
#' @description
#'
#' # Returns
#'     Number of elements in `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/size>
k_size <-
function (x)
keras$ops$size(x)


# keras$ops$sort
# keras.ops.sort
# keras.src.ops.numpy.sort
r"-(Sorts the elements of `x` along a given axis in ascending order.

    Args:
        x: Input tensor.
        axis: Axis along which to sort. If `None`, the tensor is flattened
            before sorting. Defaults to `-1`; the last axis.

    Returns:
        Sorted tensor.
    )-"

# keras.src.ops.numpy.sort
#' Sorts the elements of `x` along a given axis in ascending order.
#'
#' @description
#'
#' # Returns
#'     Sorted tensor.
#'
#' @param x Input tensor.
#' @param axis Axis along which to sort. If `None`, the tensor is flattened
#'     before sorting. Defaults to `-1`; the last axis.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sort>
k_sort <-
function (x, axis = -1L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$sort, args)
}


# keras$ops$split
# keras.ops.split
# keras.src.ops.numpy.split
r"-(Split a tensor into chunks.

    Args:
        x: Input tensor.
        indices_or_sections: Either an integer indicating the number of
            sections along `axis` or a list of integers indicating the indices
            along `axis` at which the tensor is split.
        indices_or_sections: If an integer, N, the tensor will be split into N
            equal sections along `axis`. If a 1-D array of sorted integers,
            the entries indicate indices at which the tensor will be split
            along `axis`.
        axis: Axis along which to split. Defaults to `0`.

    Note:
        A split does not have to result in equal division when using
        Torch backend.

    Returns:
        A list of tensors.
    )-"

# keras.src.ops.numpy.split
#' Split a tensor into chunks.
#'
#' @description
#'
#' # Note
#' A split does not have to result in equal division when using
#' Torch backend.
#'
#' # Returns
#'     A list of tensors.
#'
#' @param x Input tensor.
#' @param indices_or_sections Either an integer indicating the number of
#'     sections along `axis` or a list of integers indicating the indices
#'     along `axis` at which the tensor is split.
#' If an integer, N, the tensor will be split into N
#'     equal sections along `axis`. If a 1-D array of sorted integers,
#'     the entries indicate indices at which the tensor will be split
#'     along `axis`.
#' @param axis Axis along which to split. Defaults to `0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/split>
k_split <-
function (x, indices_or_sections, axis = 0L)
{
    args <- capture_args2(list(indices_or_sections = as_integer,
        axis = as_axis))
    do.call(keras$ops$split, args)
}


# keras$ops$sqrt
# keras.ops.sqrt
# keras.src.ops.numpy.sqrt
r"-(Return the non-negative square root of a tensor, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, the non-negative square root of `x`.
    )-"

# keras.src.ops.numpy.sqrt
#' Return the non-negative square root of a tensor, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, the non-negative square root of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sqrt>
k_sqrt <-
function (x)
keras$ops$sqrt(x)


# keras$ops$square
# keras.ops.square
# keras.src.ops.numpy.square
r"-(Return the element-wise square of the input.

    Args:
        x: Input tensor.

    Returns:
        Output tensor, the square of `x`.
    )-"

# keras.src.ops.numpy.square
#' Return the element-wise square of the input.
#'
#' @description
#'
#' # Returns
#'     Output tensor, the square of `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/square>
k_square <-
function (x)
keras$ops$square(x)


# keras$ops$squeeze
# keras.ops.squeeze
# keras.src.ops.numpy.squeeze
r"-(Remove axes of length one from `x`.

    Args:
        x: Input tensor.
        axis: Select a subset of the entries of length one in the shape.

    Returns:
        The input tensor with all or a subset of the dimensions of
        length 1 removed.
    )-"

# keras.src.ops.numpy.squeeze
#' Remove axes of length one from `x`.
#'
#' @description
#'
#' # Returns
#' The input tensor with all or a subset of the dimensions of
#' length 1 removed.
#'
#' @param x Input tensor.
#' @param axis Select a subset of the entries of length one in the shape.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/squeeze>
k_squeeze <-
function (x, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$squeeze, args)
}


# keras$ops$stack
# keras.ops.stack
# keras.src.ops.numpy.stack
r"-(Join a sequence of tensors along a new axis.

    The `axis` parameter specifies the index of the new axis in the
    dimensions of the result.

    Args:
        x: A sequence of tensors.
        axis: Axis along which to stack. Defaults to `0`.

    Returns:
        The stacked tensor.
    )-"

# keras.src.ops.numpy.stack
#' Join a sequence of tensors along a new axis.
#'
#' @description
#' The `axis` parameter specifies the index of the new axis in the
#' dimensions of the result.
#'
#' # Returns
#'     The stacked tensor.
#'
#' @param x A sequence of tensors.
#' @param axis Axis along which to stack. Defaults to `0`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/stack>
k_stack <-
function (x, axis = 0L)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$stack, args)
}


# keras$ops$std
# keras.ops.std
# keras.src.ops.numpy.std
r"-(Compute the standard deviation along the specified axis.

    Args:
        x: Input tensor.
        axis: Axis along which to compute standard deviation.
            Default is to compute the standard deviation of the
            flattened tensor.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one.

    Returns:
        Output tensor containing the standard deviation values.
    )-"

# keras.src.ops.numpy.std
#' Compute the standard deviation along the specified axis.
#'
#' @description
#'
#' # Returns
#'     Output tensor containing the standard deviation values.
#'
#' @param x Input tensor.
#' @param axis Axis along which to compute standard deviation.
#'     Default is to compute the standard deviation of the
#'     flattened tensor.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/std>
k_std <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$std, args)
}


# keras$ops$subtract
# keras.ops.subtract
# keras.src.ops.numpy.subtract
r"-(Subtract arguments element-wise.

    Args:
        x1: First input tensor.
        x2: Second input tensor.

    Returns:
        Output tensor, element-wise difference of `x1` and `x2`.
    )-"

# keras.src.ops.numpy.subtract
#' Subtract arguments element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor, element-wise difference of `x1` and `x2`.
#'
#' @param x1 First input tensor.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/subtract>
k_subtract <-
function (x1, x2)
keras$ops$subtract(x1, x2)


# keras$ops$sum
# keras.ops.sum
# keras.src.ops.numpy.sum
r"-(Sum of a tensor over the given axes.

    Args:
        x: Input tensor.
        axis: Axis or axes along which the sum is computed. The default is to
            compute the sum of the flattened tensor.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one.

    Returns:
        Output tensor containing the sum.
    )-"

# keras.src.ops.numpy.sum
#' Sum of a tensor over the given axes.
#'
#' @description
#'
#' # Returns
#'     Output tensor containing the sum.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which the sum is computed. The default is to
#'     compute the sum of the flattened tensor.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/sum>
k_sum <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$sum, args)
}


# keras$ops$swapaxes
# keras.ops.swapaxes
# keras.src.ops.numpy.swapaxes
r"-(Interchange two axes of a tensor.

    Args:
        x: Input tensor.
        axis1: First axis.
        axis2: Second axis.

    Returns:
        A tensor with the axes swapped.
    )-"

# keras.src.ops.numpy.swapaxes
#' Interchange two axes of a tensor.
#'
#' @description
#'
#' # Returns
#'     A tensor with the axes swapped.
#'
#' @param x Input tensor.
#' @param axis1 First axis.
#' @param axis2 Second axis.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/swapaxes>
k_swapaxes <-
function (x, axis1, axis2)
keras$ops$swapaxes(x, axis1, axis2)


# keras$ops$take
# keras.ops.take
# keras.src.ops.numpy.take
r"-(Take elements from a tensor along an axis.

    Args:
        x: Source tensor.
        indices: The indices of the values to extract.
        axis: The axis over which to select values. By default, the
            flattened input tensor is used.

    Returns:
        The corresponding tensor of values.
    )-"

# keras.src.ops.numpy.take
#' Take elements from a tensor along an axis.
#'
#' @description
#'
#' # Returns
#'     The corresponding tensor of values.
#'
#' @param x Source tensor.
#' @param indices The indices of the values to extract.
#' @param axis The axis over which to select values. By default, the
#'     flattened input tensor is used.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/take>
k_take <-
function (x, indices, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$take, args)
}


# keras$ops$take_along_axis
# keras.ops.take_along_axis
# keras.src.ops.numpy.take_along_axis
r"-(Select values from `x` at the 1-D `indices` along the given axis.

    Args:
        x: Source tensor.
        indices: The indices of the values to extract.
        axis: The axis over which to select values. By default, the flattened
            input tensor is used.

    Returns:
        The corresponding tensor of values.
    )-"

# keras.src.ops.numpy.take_along_axis
#' Select values from `x` at the 1-D `indices` along the given axis.
#'
#' @description
#'
#' # Returns
#'     The corresponding tensor of values.
#'
#' @param x Source tensor.
#' @param indices The indices of the values to extract.
#' @param axis The axis over which to select values. By default, the flattened
#'     input tensor is used.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/take_along_axis>
k_take_along_axis <-
function (x, indices, axis = NULL)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$take_along_axis, args)
}


# keras$ops$tan
# keras.ops.tan
# keras.src.ops.numpy.tan
r"-(Compute tangent, element-wise.

    Args:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.tan
#' Compute tangent, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tan>
k_tan <-
function (x)
keras$ops$tan(x)


# keras$ops$tanh
# keras.ops.tanh
# keras.src.ops.numpy.tanh
r"-(Hyperbolic tangent, element-wise.

    Arguments:
        x: Input tensor.

    Returns:
        Output tensor of same shape as `x`.
    )-"

# keras.src.ops.numpy.tanh
#' Hyperbolic tangent, element-wise.
#'
#' @description
#'
#' # Returns
#'     Output tensor of same shape as `x`.
#'
#' @param x Input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tanh>
k_tanh <-
function (x)
keras$ops$tanh(x)


# keras$ops$tensordot
# keras.ops.tensordot
# keras.src.ops.numpy.tensordot
r"-(Compute the tensor dot product along specified axes.

    Args:
        x1: First tensor.
        x2: Second tensor.
        axes: - If an integer, N, sum over the last N axes of `x1` and the
                first N axes of `x2` in order. The sizes of the corresponding
                axes must match.
              - Or, a list of axes to be summed over, first sequence applying
                to `x1`, second to `x2`. Both sequences must be of the
                same length.

    Returns:
        The tensor dot product of the inputs.
    )-"

# keras.src.ops.numpy.tensordot
#' Compute the tensor dot product along specified axes.
#'
#' @description
#'
#' # Returns
#'     The tensor dot product of the inputs.
#'
#' @param x1 First tensor.
#' @param x2 Second tensor.
#' @param axes
#' - If an integer, N, sum over the last N axes of `x1` and the
#'         first N axes of `x2` in order. The sizes of the corresponding
#'         axes must match.
#'       - Or, a list of axes to be summed over, first sequence applying
#'         to `x1`, second to `x2`. Both sequences must be of the
#'         same length.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tensordot>
k_tensordot <-
function (x1, x2, axes = 2L)
{
    args <- capture_args2(list(axes = as_axis))
    do.call(keras$ops$tensordot, args)
}


# keras$ops$tile
# keras.ops.tile
# keras.src.ops.numpy.tile
r"-(Repeat `x` the number of times given by `repeats`.

    If `repeats` has length `d`, the result will have dimension of
    `max(d, x.ndim)`.

    If `x.ndim < d`, `x` is promoted to be d-dimensional by prepending
    new axes.

    If `x.ndim > d`, `repeats` is promoted to `x.ndim` by prepending 1's to it.

    Args:
        x: Input tensor.
        repeats: The number of repetitions of `x` along each axis.

    Returns:
        The tiled output tensor.
    )-"

# keras.src.ops.numpy.tile
#' Repeat `x` the number of times given by `repeats`.
#'
#' @description
#' If `repeats` has length `d`, the result will have dimension of
#' `max(d, x.ndim)`.
#'
#' If `x.ndim < d`, `x` is promoted to be d-dimensional by prepending
#' new axes.
#'
#' If `x.ndim > d`, `repeats` is promoted to `x.ndim` by prepending 1's to it.
#'
#' # Returns
#'     The tiled output tensor.
#'
#' @param x Input tensor.
#' @param repeats The number of repetitions of `x` along each axis.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tile>
k_tile <-
function (x, repeats)
keras$ops$tile(x, repeats)


# keras$ops$trace
# keras.ops.trace
# keras.src.ops.numpy.trace
r"-(Return the sum along diagonals of the tensor.

    If `x` is 2-D, the sum along its diagonal with the given offset is
    returned, i.e., the sum of elements `x[i, i+offset]` for all `i`.

    If a has more than two dimensions, then the axes specified by `axis1`
    and `axis2` are used to determine the 2-D sub-arrays whose traces are
    returned.

    The shape of the resulting tensor is the same as that of `x` with `axis1`
    and `axis2` removed.

    Args:
        x: Input tensor.
        offset: Offset of the diagonal from the main diagonal. Can be
            both positive and negative. Defaults to `0`.
        axis1: Axis to be used as the first axis of the 2-D sub-arrays.
            Defaults to `0`.(first axis).
        axis2: Axis to be used as the second axis of the 2-D sub-arrays.
            Defaults to `1` (second axis).

    Returns:
        If `x` is 2-D, the sum of the diagonal is returned. If `x` has
        larger dimensions, then a tensor of sums along diagonals is
        returned.
    )-"

# keras.src.ops.numpy.trace
#' Return the sum along diagonals of the tensor.
#'
#' @description
#' If `x` is 2-D, the sum along its diagonal with the given offset is
#' returned, i.e., the sum of elements `x[i, i+offset]` for all `i`.
#'
#' If a has more than two dimensions, then the axes specified by `axis1`
#' and `axis2` are used to determine the 2-D sub-arrays whose traces are
#' returned.
#'
#' The shape of the resulting tensor is the same as that of `x` with `axis1`
#' and `axis2` removed.
#'
#' # Returns
#' If `x` is 2-D, the sum of the diagonal is returned. If `x` has
#' larger dimensions, then a tensor of sums along diagonals is
#' returned.
#'
#' @param x Input tensor.
#' @param offset Offset of the diagonal from the main diagonal. Can be
#'     both positive and negative. Defaults to `0`.
#' @param axis1 Axis to be used as the first axis of the 2-D sub-arrays.
#'     Defaults to `0`.(first axis).
#' @param axis2 Axis to be used as the second axis of the 2-D sub-arrays.
#'     Defaults to `1` (second axis).
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/trace>
k_trace <-
function (x, offset = 0L, axis1 = 0L, axis2 = 1L)
{
    args <- capture_args2(list(offset = as_integer, axis1 = as_integer,
        axis2 = as_integer))
    do.call(keras$ops$trace, args)
}


# keras$ops$transpose
# keras.ops.transpose
# keras.src.ops.numpy.transpose
r"-(Returns a tensor with `axes` transposed.

    Args:
        x: Input tensor.
        axes: Sequence of integers. Permutation of the dimensions of `x`.
            By default, the order of the axes are reversed.

    Returns:
        `x` with its axes permuted.
    )-"

# keras.src.ops.numpy.transpose
#' Returns a tensor with `axes` transposed.
#'
#' @description
#'
#' # Returns
#'     `x` with its axes permuted.
#'
#' @param x Input tensor.
#' @param axes Sequence of integers. Permutation of the dimensions of `x`.
#'     By default, the order of the axes are reversed.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/transpose>
k_transpose <-
function (x, axes = NULL)
{
    args <- capture_args2(list(axes = as_axis))
    do.call(keras$ops$transpose, args)
}


# keras$ops$tri
# keras.ops.tri
# keras.src.ops.numpy.tri
r"-(Return a tensor with ones at and below a diagonal and zeros elsewhere.

    Args:
        N: Number of rows in the tensor.
        M: Number of columns in the tensor.
        k: The sub-diagonal at and below which the array is filled.
            `k = 0` is the main diagonal, while `k < 0` is below it, and
            `k > 0` is above. The default is 0.
        dtype: Data type of the returned tensor. The default is "float32".

    Returns:
        Tensor with its lower triangle filled with ones and zeros elsewhere.
        `T[i, j] == 1` for `j <= i + k`, 0 otherwise.
    )-"

# keras.src.ops.numpy.tri
#' Return a tensor with ones at and below a diagonal and zeros elsewhere.
#'
#' @description
#'
#' # Returns
#' Tensor with its lower triangle filled with ones and zeros elsewhere.
#' `T[i, j] == 1` for `j <= i + k`, 0 otherwise.
#'
#' @param N Number of rows in the tensor.
#' @param M Number of columns in the tensor.
#' @param k The sub-diagonal at and below which the array is filled.
#'     `k = 0` is the main diagonal, while `k < 0` is below it, and
#'     `k > 0` is above. The default is 0.
#' @param dtype Data type of the returned tensor. The default is "float32".
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tri>
k_tri <-
function (N, M = NULL, k = 0L, dtype = NULL)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$tri, args)
}


# keras$ops$tril
# keras.ops.tril
# keras.src.ops.numpy.tril
r"-(Return lower triangle of a tensor.

    For tensors with `ndim` exceeding 2, `tril` will apply to the
    final two axes.

    Args:
        x: Input tensor.
        k: Diagonal above which to zero elements. Defaults to `0`. the
            main diagonal. `k < 0` is below it, and `k > 0` is above it.

    Returns:
        Lower triangle of `x`, of same shape and data type as `x`.
    )-"

# keras.src.ops.numpy.tril
#' Return lower triangle of a tensor.
#'
#' @description
#' For tensors with `ndim` exceeding 2, `tril` will apply to the
#' final two axes.
#'
#' # Returns
#'     Lower triangle of `x`, of same shape and data type as `x`.
#'
#' @param x Input tensor.
#' @param k Diagonal above which to zero elements. Defaults to `0`. the
#'     main diagonal. `k < 0` is below it, and `k > 0` is above it.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/tril>
k_tril <-
function (x, k = 0L)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$tril, args)
}


# keras$ops$triu
# keras.ops.triu
# keras.src.ops.numpy.triu
r"-(Return upper triangle of a tensor.

    For tensors with `ndim` exceeding 2, `triu` will apply to the
    final two axes.

    Args:
        x: Input tensor.
        k: Diagonal below which to zero elements. Defaults to `0`. the
            main diagonal. `k < 0` is below it, and `k > 0` is above it.

    Returns:
        Upper triangle of `x`, of same shape and data type as `x`.
    )-"

# keras.src.ops.numpy.triu
#' Return upper triangle of a tensor.
#'
#' @description
#' For tensors with `ndim` exceeding 2, `triu` will apply to the
#' final two axes.
#'
#' # Returns
#'     Upper triangle of `x`, of same shape and data type as `x`.
#'
#' @param x Input tensor.
#' @param k Diagonal below which to zero elements. Defaults to `0`. the
#'     main diagonal. `k < 0` is below it, and `k > 0` is above it.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/triu>
k_triu <-
function (x, k = 0L)
{
    args <- capture_args2(list(k = as_integer))
    do.call(keras$ops$triu, args)
}


# keras$ops$true_divide
# keras.ops.true_divide
# keras.src.ops.numpy.true_divide
r"-(Alias for `keras.ops.divide`.)-"

# keras.src.ops.numpy.true_divide
#' Alias for `keras.ops.divide`.
#'
#' @param x1 see description
#' @param x2 see description
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/true_divide>
k_true_divide <-
function (x1, x2)
keras$ops$true_divide(x1, x2)


# keras$ops$var
# keras.ops.var
# keras.src.ops.numpy.var
r"-(Compute the variance along the specified axes.

    Args:
        x: Input tensor.
        axis: Axis or axes along which the variance is computed. The default
            is to compute the variance of the flattened tensor.
        keepdims: If this is set to `True`, the axes which are reduced are left
            in the result as dimensions with size one.

    Returns:
        Output tensor containing the variance.
    )-"

# keras.src.ops.numpy.var
#' Compute the variance along the specified axes.
#'
#' @description
#'
#' # Returns
#'     Output tensor containing the variance.
#'
#' @param x Input tensor.
#' @param axis Axis or axes along which the variance is computed. The default
#'     is to compute the variance of the flattened tensor.
#' @param keepdims If this is set to `True`, the axes which are reduced are left
#'     in the result as dimensions with size one.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/var>
k_var <-
function (x, axis = NULL, keepdims = FALSE)
{
    args <- capture_args2(list(axis = as_axis))
    do.call(keras$ops$var, args)
}


# keras$ops$vdot
# keras.ops.vdot
# keras.src.ops.numpy.vdot
r"-(Return the dot product of two vectors.

    If the first argument is complex, the complex conjugate of the first
    argument is used for the calculation of the dot product.

    Multidimensional tensors are flattened before the dot product is taken.

    Args:
        x1: First input tensor. If complex, its complex conjugate is taken
            before calculation of the dot product.
        x2: Second input tensor.

    Returns:
        Output tensor.
    )-"

# keras.src.ops.numpy.vdot
#' Return the dot product of two vectors.
#'
#' @description
#' If the first argument is complex, the complex conjugate of the first
#' argument is used for the calculation of the dot product.
#'
#' Multidimensional tensors are flattened before the dot product is taken.
#'
#' # Returns
#'     Output tensor.
#'
#' @param x1 First input tensor. If complex, its complex conjugate is taken
#'     before calculation of the dot product.
#' @param x2 Second input tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/vdot>
k_vdot <-
function (x1, x2)
keras$ops$vdot(x1, x2)


# keras$ops$vstack
# keras.ops.vstack
# keras.src.ops.numpy.vstack
r"-(Stack tensors in sequence vertically (row wise).

    Args:
        xs: Sequence of tensors.

    Returns:
        Tensor formed by stacking the given tensors.
    )-"

# keras.src.ops.numpy.vstack
#' Stack tensors in sequence vertically (row wise).
#'
#' @description
#'
#' # Returns
#'     Tensor formed by stacking the given tensors.
#'
#' @param xs Sequence of tensors.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/vstack>
k_vstack <-
function (xs)
keras$ops$vstack(xs)


# keras$ops$where
# keras.ops.where
# keras.src.ops.numpy.where
r"-(Return elements chosen from `x1` or `x2` depending on `condition`.

    Args:
        condition: Where `True`, yield `x1`, otherwise yield `x2`.
        x1: Values from which to choose when `condition` is `True`.
        x2: Values from which to choose when `condition` is `False`.

    Returns:
        A tensor with elements from `x1` where `condition` is `True`, and
        elements from `x2` where `condition` is `False`.
    )-"

# keras.src.ops.numpy.where
#' Return elements chosen from `x1` or `x2` depending on `condition`.
#'
#' @description
#'
#' # Returns
#' A tensor with elements from `x1` where `condition` is `True`, and
#' elements from `x2` where `condition` is `False`.
#'
#' @param condition Where `True`, yield `x1`, otherwise yield `x2`.
#' @param x1 Values from which to choose when `condition` is `True`.
#' @param x2 Values from which to choose when `condition` is `False`.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/where>
k_where <-
function (condition, x1 = NULL, x2 = NULL)
keras$ops$where(condition, x1, x2)


# keras$ops$zeros
# keras.ops.zeros
# keras.src.ops.numpy.zeros
r"-(Return a new tensor of given shape and type, filled with zeros.

    Args:
        shape: Shape of the new tensor.
        dtype: Desired data type of the tensor.

    Returns:
        Tensor of zeros with the given shape and dtype.
    )-"

# keras.src.ops.numpy.zeros
#' Return a new tensor of given shape and type, filled with zeros.
#'
#' @description
#'
#' # Returns
#'     Tensor of zeros with the given shape and dtype.
#'
#' @param shape Shape of the new tensor.
#' @param dtype Desired data type of the tensor.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/zeros>
k_zeros <-
function (shape, dtype = NULL)
{
    args <- capture_args2(list(shape = normalize_shape))
    do.call(keras$ops$zeros, args)
}


# keras$ops$zeros_like
# keras.ops.zeros_like
# keras.src.ops.numpy.zeros_like
r"-(Return a tensor of zeros with the same shape and type as `x`.

    Args:
        x: Input tensor.
        dtype: Overrides the data type of the result.

    Returns:
        A tensor of zeros with the same shape and type as `x`.
    )-"

# keras.src.ops.numpy.zeros_like
#' Return a tensor of zeros with the same shape and type as `x`.
#'
#' @description
#'
#' # Returns
#'     A tensor of zeros with the same shape and type as `x`.
#'
#' @param x Input tensor.
#' @param dtype Overrides the data type of the result.
#'
#' @export
#' @family ops
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/ops/zeros_like>
k_zeros_like <-
function (x, dtype = NULL)
keras$ops$zeros_like(x, dtype)
