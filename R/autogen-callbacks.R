## Autogenerated. Do not modify manually.


# keras$callbacks$BackupAndRestore
# keras.callbacks.BackupAndRestore
# keras_core.src.callbacks.backup_and_restore_callback.BackupAndRestore
r"-(Callback to back up and restore the training state.

    `BackupAndRestore` callback is intended to recover training from an
    interruption that has happened in the middle of a `Model.fit` execution, by
    backing up the training states in a temporary checkpoint file, at the end of
    each epoch. Each backup overwrites the previously written checkpoint file,
    so at any given time there is at most one such checkpoint file for
    backup/restoring purpose.

    If training restarts before completion, the training state (which includes
    the `Model` weights and epoch number) is restored to the most recently saved
    state at the beginning of a new `Model.fit` run. At the completion of a
    `Model.fit` run, the temporary checkpoint file is deleted.

    Note that the user is responsible to bring jobs back after the interruption.
    This callback is important for the backup and restore mechanism for fault
    tolerance purpose, and the model to be restored from a previous checkpoint
    is expected to be the same as the one used to back up. If user changes
    arguments passed to compile or fit, the checkpoint saved for fault tolerance
    can become invalid.

    Example:

    >>> class InterruptingCallback(keras.callbacks.Callback):
    ...   def on_epoch_begin(self, epoch, logs=None):
    ...     if epoch == 4:
    ...       raise RuntimeError('Interrupting!')
    >>> callback = keras.callbacks.BackupAndRestore(backup_dir="/tmp/backup")
    >>> model = keras.models.Sequential([keras.layers.Dense(10)])
    >>> model.compile(keras.optimizers.SGD(), loss='mse')
    >>> try:
    ...   model.fit(np.arange(100).reshape(5, 20), np.zeros(5), epochs=10,
    ...             batch_size=1, callbacks=[callback, InterruptingCallback()],
    ...             verbose=0)
    ... except:
    ...   pass
    >>> history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
    ...                     epochs=10, batch_size=1, callbacks=[callback],
    ...                     verbose=0)
    >>> # Only 6 more epochs are run, since first training got interrupted at
    >>> # zero-indexed epoch 4, second training will continue from 4 to 9.
    >>> len(history.history['loss'])
    >>> 6

    Args:
        backup_dir: String, path of directory where to store the data
            needed to restore the model. The directory
            cannot be reused elsewhere to store other files, e.g. by the
            `BackupAndRestore` callback of another training run,
            or by another callback (e.g. `ModelCheckpoint`)
            of the same training run.
        save_freq: `"epoch"`, integer, or `False`. When set to `"epoch"`
          the callback saves the checkpoint at the end of each epoch.
          When set to an integer, the callback saves the checkpoint every
          `save_freq` batches. Set `save_freq=False` only if using
          preemption checkpointing (i.e. with `save_before_preemption=True`).
        delete_checkpoint: Boolean, defaults to `True`. This `BackupAndRestore`
          callback works by saving a checkpoint to back up the training state.
          If `delete_checkpoint=True`, the checkpoint will be deleted after
          training is finished. Use `False` if you'd like to keep the checkpoint
          for future usage.
    )-"


# keras_core.src.callbacks.backup_and_restore_callback.BackupAndRestore
#' Callback to back up and restore the training state.
#'
#' @description
#' `BackupAndRestore` callback is intended to recover training from an
#' interruption that has happened in the middle of a `Model.fit` execution, by
#' backing up the training states in a temporary checkpoint file, at the end of
#' each epoch. Each backup overwrites the previously written checkpoint file,
#' so at any given time there is at most one such checkpoint file for
#' backup/restoring purpose.
#'
#' If training restarts before completion, the training state (which includes
#' the `Model` weights and epoch number) is restored to the most recently saved
#' state at the beginning of a new `Model.fit` run. At the completion of a
#' `Model.fit` run, the temporary checkpoint file is deleted.
#'
#' Note that the user is responsible to bring jobs back after the interruption.
#' This callback is important for the backup and restore mechanism for fault
#' tolerance purpose, and the model to be restored from a previous checkpoint
#' is expected to be the same as the one used to back up. If user changes
#' arguments passed to compile or fit, the checkpoint saved for fault tolerance
#' can become invalid.
#'
#' # Examples
#' ```python
#' class InterruptingCallback(keras.callbacks.Callback):
#'   def on_epoch_begin(self, epoch, logs=None):
#'     if epoch == 4:
#'       raise RuntimeError('Interrupting!')
#' callback = keras.callbacks.BackupAndRestore(backup_dir="/tmp/backup")
#' model = keras.models.Sequential([keras.layers.Dense(10)])
#' model.compile(keras.optimizers.SGD(), loss='mse')
#' try:
#'   model.fit(np.arange(100).reshape(5, 20), np.zeros(5), epochs=10,
#'             batch_size=1, callbacks=[callback, InterruptingCallback()],
#'             verbose=0)
#' except:
#'   pass
#' history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
#'                     epochs=10, batch_size=1, callbacks=[callback],
#'                     verbose=0)
#' # Only 6 more epochs are run, since first training got interrupted at
#' # zero-indexed epoch 4, second training will continue from 4 to 9.
#' len(history.history['loss'])
#' 6
#' ```
#'
#' @param backup_dir String, path of directory where to store the data
#'     needed to restore the model. The directory
#'     cannot be reused elsewhere to store other files, e.g. by the
#'     `BackupAndRestore` callback of another training run,
#'     or by another callback (e.g. `ModelCheckpoint`)
#'     of the same training run.
#' @param save_freq `"epoch"`, integer, or `False`. When set to `"epoch"`
#'   the callback saves the checkpoint at the end of each epoch.
#'   When set to an integer, the callback saves the checkpoint every
#'   `save_freq` batches. Set `save_freq=False` only if using
#'   preemption checkpointing (i.e. with `save_before_preemption=True`).
#' @param delete_checkpoint Boolean, defaults to `True`. This `BackupAndRestore`
#'   callback works by saving a checkpoint to back up the training state.
#'   If `delete_checkpoint=True`, the checkpoint will be deleted after
#'   training is finished. Use `False` if you'd like to keep the checkpoint
#'   for future usage.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/BackupAndRestore>
callback_backup_and_restore <-
function (backup_dir, save_freq = "epoch", delete_checkpoint = TRUE)
{
    args <- capture_args2(list(save_freq = as_integer))
    do.call(keras$callbacks$BackupAndRestore, args)
}


# keras$callbacks$CSVLogger
# keras.callbacks.CSVLogger
# keras_core.src.callbacks.csv_logger.CSVLogger
r"-(Callback that streams epoch results to a CSV file.

    Supports all values that can be represented as a string,
    including 1D iterables such as `np.ndarray`.

    Args:
        filename: Filename of the CSV file, e.g. `'run/log.csv'`.
        separator: String used to separate elements in the CSV file.
        append: Boolean. True: append if file exists (useful for continuing
            training). False: overwrite existing file.

    Example:

    ```python
    csv_logger = CSVLogger('training.log')
    model.fit(X_train, Y_train, callbacks=[csv_logger])
    ```
    )-"


# keras_core.src.callbacks.csv_logger.CSVLogger
#' Callback that streams epoch results to a CSV file.
#'
#' @description
#' Supports all values that can be represented as a string,
#' including 1D iterables such as `np.ndarray`.
#'
#' # Examples
#' ```python
#' csv_logger = CSVLogger('training.log')
#' model.fit(X_train, Y_train, callbacks=[csv_logger])
#' ```
#'
#' @param filename Filename of the CSV file, e.g. `'run/log.csv'`.
#' @param separator String used to separate elements in the CSV file.
#' @param append Boolean. True: append if file exists (useful for continuing
#'     training). False: overwrite existing file.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/CSVLogger>
callback_csv_logger <-
function (filename, separator = ",", append = FALSE)
{
    args <- capture_args2(NULL)
    do.call(keras$callbacks$CSVLogger, args)
}


# keras$callbacks$EarlyStopping
# keras.callbacks.EarlyStopping
# keras_core.src.callbacks.early_stopping.EarlyStopping
r"-(Stop training when a monitored metric has stopped improving.

    Assuming the goal of a training is to minimize the loss. With this, the
    metric to be monitored would be `'loss'`, and mode would be `'min'`. A
    `model.fit()` training loop will check at end of every epoch whether
    the loss is no longer decreasing, considering the `min_delta` and
    `patience` if applicable. Once it's found no longer decreasing,
    `model.stop_training` is marked True and the training terminates.

    The quantity to be monitored needs to be available in `logs` dict.
    To make it so, pass the loss or metrics at `model.compile()`.

    Args:
        monitor: Quantity to be monitored. Defaults to `"val_loss"`.
        min_delta: Minimum change in the monitored quantity to qualify as an
            improvement, i.e. an absolute change of less than min_delta, will
            count as no improvement. Defaults to `0`.
        patience: Number of epochs with no improvement after which training will
            be stopped. Defaults to `0`.
        verbose: Verbosity mode, 0 or 1. Mode 0 is silent, and mode 1 displays
            messages when the callback takes an action. Defaults to `0`.
        mode: One of `{"auto", "min", "max"}`. In `min` mode, training will stop
            when the quantity monitored has stopped decreasing; in `"max"` mode
            it will stop when the quantity monitored has stopped increasing; in
            `"auto"` mode, the direction is automatically inferred from the name
            of the monitored quantity. Defaults to `"auto"`.
        baseline: Baseline value for the monitored quantity. If not `None`,
            training will stop if the model doesn't show improvement over the
            baseline. Defaults to `None`.
        restore_best_weights: Whether to restore model weights from the epoch
            with the best value of the monitored quantity. If `False`, the model
            weights obtained at the last step of training are used. An epoch
            will be restored regardless of the performance relative to the
            `baseline`. If no epoch improves on `baseline`, training will run
            for `patience` epochs and restore weights from the best epoch in
            that set. Defaults to `False`.
        start_from_epoch: Number of epochs to wait before starting to monitor
            improvement. This allows for a warm-up period in which no
            improvement is expected and thus training will not be stopped.
            Defaults to `0`.


    Example:

    >>> callback = keras.callbacks.EarlyStopping(monitor='loss',
    ...                                               patience=3)
    >>> # This callback will stop the training when there is no improvement in
    >>> # the loss for three consecutive epochs.
    >>> model = keras.models.Sequential([keras.layers.Dense(10)])
    >>> model.compile(keras.optimizers.SGD(), loss='mse')
    >>> history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
    ...                     epochs=10, batch_size=1, callbacks=[callback],
    ...                     verbose=0)
    >>> len(history.history['loss'])  # Only 4 epochs are run.
    4
    )-"


# keras_core.src.callbacks.early_stopping.EarlyStopping
#' Stop training when a monitored metric has stopped improving.
#'
#' @description
#' Assuming the goal of a training is to minimize the loss. With this, the
#' metric to be monitored would be `'loss'`, and mode would be `'min'`. A
#' `model.fit()` training loop will check at end of every epoch whether
#' the loss is no longer decreasing, considering the `min_delta` and
#' `patience` if applicable. Once it's found no longer decreasing,
#' `model.stop_training` is marked True and the training terminates.
#'
#' The quantity to be monitored needs to be available in `logs` dict.
#' To make it so, pass the loss or metrics at `model.compile()`.
#'
#' # Examples
#' ```python
#' callback = keras.callbacks.EarlyStopping(monitor='loss',
#'                                               patience=3)
#' # This callback will stop the training when there is no improvement in
#' # the loss for three consecutive epochs.
#' model = keras.models.Sequential([keras.layers.Dense(10)])
#' model.compile(keras.optimizers.SGD(), loss='mse')
#' history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
#'                     epochs=10, batch_size=1, callbacks=[callback],
#'                     verbose=0)
#' len(history.history['loss'])  # Only 4 epochs are run.
#' # 4
#' ```
#'
#' @param monitor Quantity to be monitored. Defaults to `"val_loss"`.
#' @param min_delta Minimum change in the monitored quantity to qualify as an
#'     improvement, i.e. an absolute change of less than min_delta, will
#'     count as no improvement. Defaults to `0`.
#' @param patience Number of epochs with no improvement after which training will
#'     be stopped. Defaults to `0`.
#' @param verbose Verbosity mode, 0 or 1. Mode 0 is silent, and mode 1 displays
#'     messages when the callback takes an action. Defaults to `0`.
#' @param mode One of `{"auto", "min", "max"}`. In `min` mode, training will stop
#'     when the quantity monitored has stopped decreasing; in `"max"` mode
#'     it will stop when the quantity monitored has stopped increasing; in
#'     `"auto"` mode, the direction is automatically inferred from the name
#'     of the monitored quantity. Defaults to `"auto"`.
#' @param baseline Baseline value for the monitored quantity. If not `None`,
#'     training will stop if the model doesn't show improvement over the
#'     baseline. Defaults to `None`.
#' @param restore_best_weights Whether to restore model weights from the epoch
#'     with the best value of the monitored quantity. If `False`, the model
#'     weights obtained at the last step of training are used. An epoch
#'     will be restored regardless of the performance relative to the
#'     `baseline`. If no epoch improves on `baseline`, training will run
#'     for `patience` epochs and restore weights from the best epoch in
#'     that set. Defaults to `False`.
#' @param start_from_epoch Number of epochs to wait before starting to monitor
#'     improvement. This allows for a warm-up period in which no
#'     improvement is expected and thus training will not be stopped.
#'     Defaults to `0`.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping>
callback_early_stopping <-
function (monitor = "val_loss", min_delta = 0L, patience = 0L,
    verbose = 0L, mode = "auto", baseline = NULL, restore_best_weights = FALSE,
    start_from_epoch = 0L)
{
    args <- capture_args2(list(min_delta = as_integer, patience = as_integer,
        verbose = as_integer, start_from_epoch = as_integer))
    do.call(keras$callbacks$EarlyStopping, args)
}


# keras$callbacks$LambdaCallback
# keras.callbacks.LambdaCallback
# keras_core.src.callbacks.lambda_callback.LambdaCallback
r"-(Callback for creating simple, custom callbacks on-the-fly.

    This callback is constructed with anonymous functions that will be called
    at the appropriate time (during `Model.{fit | evaluate | predict}`).
    Note that the callbacks expects positional arguments, as:

    - `on_epoch_begin` and `on_epoch_end` expect two positional arguments:
      `epoch`, `logs`
    - `on_train_begin` and `on_train_end` expect one positional argument:
      `logs`
    - `on_train_batch_begin` and `on_train_batch_end` expect two positional
      arguments: `batch`, `logs`
    - See `Callback` class definition for the full list of functions and their
      expected arguments.

    Args:
        on_epoch_begin: called at the beginning of every epoch.
        on_epoch_end: called at the end of every epoch.
        on_train_begin: called at the beginning of model training.
        on_train_end: called at the end of model training.
        on_train_batch_begin: called at the beginning of every train batch.
        on_train_batch_end: called at the end of every train batch.
        kwargs: Any function in `Callback` that you want to override by
            passing `function_name=function`. For example,
            `LambdaCallback(.., on_train_end=train_end_fn)`. The custom function
            needs to have same arguments as the ones defined in `Callback`.

    Example:

    ```python
    # Print the batch number at the beginning of every batch.
    batch_print_callback = LambdaCallback(
        on_train_batch_begin=lambda batch,logs: print(batch))

    # Stream the epoch loss to a file in JSON format. The file content
    # is not well-formed JSON but rather has a JSON object per line.
    import json
    json_log = open('loss_log.json', mode='wt', buffering=1)
    json_logging_callback = LambdaCallback(
        on_epoch_end=lambda epoch, logs: json_log.write(
            json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '
'),
        on_train_end=lambda logs: json_log.close()
    )

    # Terminate some processes after having finished model training.
    processes = ...
    cleanup_callback = LambdaCallback(
        on_train_end=lambda logs: [
            p.terminate() for p in processes if p.is_alive()])

    model.fit(...,
              callbacks=[batch_print_callback,
                         json_logging_callback,
                         cleanup_callback])
    ```
    )-"


# keras_core.src.callbacks.lambda_callback.LambdaCallback
#' Callback for creating simple, custom callbacks on-the-fly.
#'
#' @description
#' This callback is constructed with anonymous functions that will be called
#' at the appropriate time (during `Model.{fit | evaluate | predict}`).
#' Note that the callbacks expects positional arguments, as:
#'
#' - `on_epoch_begin` and `on_epoch_end` expect two positional arguments:
#'   `epoch`, `logs`
#' - `on_train_begin` and `on_train_end` expect one positional argument:
#'   `logs`
#' - `on_train_batch_begin` and `on_train_batch_end` expect two positional
#'   arguments: `batch`, `logs`
#' - See `Callback` class definition for the full list of functions and their
#'   expected arguments.
#'
#' # Examples
#'     ```python
#'     # Print the batch number at the beginning of every batch.
#'     batch_print_callback = LambdaCallback(
#'         on_train_batch_begin=lambda batch,logs: print(batch))
#'
#'     # Stream the epoch loss to a file in JSON format. The file content
#'     # is not well-formed JSON but rather has a JSON object per line.
#'     import json
#'     json_log = open('loss_log.json', mode='wt', buffering=1)
#'     json_logging_callback = LambdaCallback(
#'         on_epoch_end=lambda epoch, logs: json_log.write(
#'             json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '
#' '),
#'         on_train_end=lambda logs: json_log.close()
#'     )
#'
#'     # Terminate some processes after having finished model training.
#'     processes = ...
#'     cleanup_callback = LambdaCallback(
#'         on_train_end=lambda logs: [
#'             p.terminate() for p in processes if p.is_alive()])
#'
#'     model.fit(...,
#'               callbacks=[batch_print_callback,
#'                          json_logging_callback,
#'                          cleanup_callback])
#'     ```
#'
#' @param on_epoch_begin called at the beginning of every epoch.
#' @param on_epoch_end called at the end of every epoch.
#' @param on_train_begin called at the beginning of model training.
#' @param on_train_end called at the end of model training.
#' @param on_train_batch_begin called at the beginning of every train batch.
#' @param on_train_batch_end called at the end of every train batch.
#' @param ... Any function in `Callback` that you want to override by
#'     passing `function_name=function`. For example,
#'     `LambdaCallback(.., on_train_end=train_end_fn)`. The custom function
#'     needs to have same arguments as the ones defined in `Callback`.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/LambdaCallback>
callback_lambda <-
function (on_epoch_begin = NULL, on_epoch_end = NULL, on_train_begin = NULL,
    on_train_end = NULL, on_train_batch_begin = NULL, on_train_batch_end = NULL,
    ...)
{
    args <- capture_args2(NULL)
    do.call(keras$callbacks$LambdaCallback, args)
}


# keras$callbacks$LearningRateScheduler
# keras.callbacks.LearningRateScheduler
# keras_core.src.callbacks.learning_rate_scheduler.LearningRateScheduler
r"-(Learning rate scheduler.

    At the beginning of every epoch, this callback gets the updated learning
    rate value from `schedule` function provided at `__init__`, with the current
    epoch and current learning rate, and applies the updated learning rate on
    the optimizer.

    Args:
        schedule: A function that takes an epoch index (integer, indexed from 0)
            and current learning rate (float) as inputs and returns a new
            learning rate as output (float).
        verbose: Integer. 0: quiet, 1: log update messages.

    Example:

    >>> # This function keeps the initial learning rate for the first ten epochs
    >>> # and decreases it exponentially after that.
    >>> def scheduler(epoch, lr):
    ...     if epoch < 10:
    ...         return lr
    ...     else:
    ...         return lr * ops.exp(-0.1)
    >>>
    >>> model = keras.models.Sequential([keras.layers.Dense(10)])
    >>> model.compile(keras.optimizers.SGD(), loss='mse')
    >>> round(model.optimizer.learning_rate, 5)
    0.01

    >>> callback = keras.callbacks.LearningRateScheduler(scheduler)
    >>> history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
    ...                     epochs=15, callbacks=[callback], verbose=0)
    >>> round(model.optimizer.learning_rate, 5)
    0.00607

    )-"


# keras_core.src.callbacks.learning_rate_scheduler.LearningRateScheduler
#' Learning rate scheduler.
#'
#' @description
#' At the beginning of every epoch, this callback gets the updated learning
#' rate value from `schedule` function provided at `__init__`, with the current
#' epoch and current learning rate, and applies the updated learning rate on
#' the optimizer.
#'
#' # Examples
#' ```python
#' # This function keeps the initial learning rate for the first ten epochs
#' # and decreases it exponentially after that.
#' def scheduler(epoch, lr):
#'     if epoch < 10:
#'         return lr
#'     else:
#'         return lr * ops.exp(-0.1)
#' # >>>
#' model = keras.models.Sequential([keras.layers.Dense(10)])
#' model.compile(keras.optimizers.SGD(), loss='mse')
#' round(model.optimizer.learning_rate, 5)
#' # 0.01
#' ```
#'
#' ```python
#' callback = keras.callbacks.LearningRateScheduler(scheduler)
#' history = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),
#'                     epochs=15, callbacks=[callback], verbose=0)
#' round(model.optimizer.learning_rate, 5)
#' # 0.00607
#' ```
#'
#' @param schedule A function that takes an epoch index (integer, indexed from 0)
#'     and current learning rate (float) as inputs and returns a new
#'     learning rate as output (float).
#' @param verbose Integer. 0: quiet, 1: log update messages.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/LearningRateScheduler>
callback_learning_rate_scheduler <-
function (schedule, verbose = 0L)
{
    args <- capture_args2(list(schedule = as_integer, verbose = as_integer))
    do.call(keras$callbacks$LearningRateScheduler, args)
}


# keras$callbacks$ModelCheckpoint
# keras.callbacks.ModelCheckpoint
# keras_core.src.callbacks.model_checkpoint.ModelCheckpoint
r"-(Callback to save the Keras model or model weights at some frequency.

    `ModelCheckpoint` callback is used in conjunction with training using
    `model.fit()` to save a model or weights (in a checkpoint file) at some
    interval, so the model or weights can be loaded later to continue the
    training from the state saved.

    A few options this callback provides include:

    - Whether to only keep the model that has achieved the "best performance" so
      far, or whether to save the model at the end of every epoch regardless of
      performance.
    - Definition of "best"; which quantity to monitor and whether it should be
      maximized or minimized.
    - The frequency it should save at. Currently, the callback supports saving
      at the end of every epoch, or after a fixed number of training batches.
    - Whether only weights are saved, or the whole model is saved.

    Example:

    ```python
    model.compile(loss=..., optimizer=...,
                  metrics=['accuracy'])

    EPOCHS = 10
    checkpoint_filepath = '/tmp/ckpt/checkpoint.model.keras'
    model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
        filepath=checkpoint_filepath,
        monitor='val_accuracy',
        mode='max',
        save_best_only=True)

    # Model is saved at the end of every epoch, if it's the best seen so far.
    model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])

    # The model (that are considered the best) can be loaded as -
    keras.models.load_model(checkpoint_filepath)

    # Alternatively, one could checkpoint just the model weights as -
    checkpoint_filepath = '/tmp/ckpt/checkpoint.weights.h5'
    model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
        filepath=checkpoint_filepath,
        save_weights_only=True,
        monitor='val_accuracy',
        mode='max',
        save_best_only=True)

    # Model weights are saved at the end of every epoch, if it's the best seen
    # so far.
    model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])

    # The model weights (that are considered the best) can be loaded as -
    model.load_weights(checkpoint_filepath)
    ```

    Args:
        filepath: string or `PathLike`, path to save the model file.
            `filepath` can contain named formatting options,
            which will be filled the value of `epoch` and keys in `logs`
            (passed in `on_epoch_end`).
            The `filepath` name needs to end with `".weights.h5"` when
            `save_weights_only=True` or should end with `".keras"` when
            checkpoint saving the whole model (default).
            For example:
            if `filepath` is `"{epoch:02d}-{val_loss:.2f}.keras"`, then the
            model checkpoints will be saved with the epoch number and the
            validation loss in the filename. The directory of the filepath
            should not be reused by any other callbacks to avoid conflicts.
        monitor: The metric name to monitor. Typically the metrics are set by
            the `Model.compile` method. Note:
            * Prefix the name with `"val_"` to monitor validation metrics.
            * Use `"loss"` or `"val_loss"` to monitor the model's total loss.
            * If you specify metrics as strings, like `"accuracy"`, pass the
                same string (with or without the `"val_"` prefix).
            * If you pass `metrics.Metric` objects, `monitor` should be set to
                `metric.name`
            * If you're not sure about the metric names you can check the
                contents of the `history.history` dictionary returned by
                `history = model.fit()`
            * Multi-output models set additional prefixes on the metric names.
        verbose: Verbosity mode, 0 or 1. Mode 0 is silent, and mode 1
            displays messages when the callback takes an action.
        save_best_only: if `save_best_only=True`, it only saves when the model
            is considered the "best" and the latest best model according to the
            quantity monitored will not be overwritten. If `filepath` doesn't
            contain formatting options like `{epoch}` then `filepath` will be
            overwritten by each new better model.
        mode: one of {`"auto"`, `"min"`, `"max"`}. If `save_best_only=True`, the
            decision to overwrite the current save file is made based on either
            the maximization or the minimization of the monitored quantity.
            For `val_acc`, this should be `"max"`, for `val_loss` this should be
            `"min"`, etc. In `"auto"` mode, the mode is set to `"max"` if the
            quantities monitored are `"acc"` or start with `"fmeasure"` and are
            set to `"min"` for the rest of the quantities.
        save_weights_only: if True, then only the model's weights will be saved
            (`model.save_weights(filepath)`), else the full model is saved
            (`model.save(filepath)`).
        save_freq: `"epoch"` or integer. When using `"epoch"`, the callback
            saves the model after each epoch. When using integer, the callback
            saves the model at end of this many batches. If the `Model` is
            compiled with `steps_per_execution=N`, then the saving criteria will
            be checked every Nth batch. Note that if the saving isn't aligned to
            epochs, the monitored metric may potentially be less reliable (it
            could reflect as little as 1 batch, since the metrics get reset
            every epoch). Defaults to `"epoch"`.
        initial_value_threshold: Floating point initial "best" value of the
            metric to be monitored. Only applies if `save_best_value=True`. Only
            overwrites the model weights already saved if the performance of
            current model is better than this value.
    )-"


# keras_core.src.callbacks.model_checkpoint.ModelCheckpoint
#' Callback to save the Keras model or model weights at some frequency.
#'
#' @description
#' `ModelCheckpoint` callback is used in conjunction with training using
#' `model.fit()` to save a model or weights (in a checkpoint file) at some
#' interval, so the model or weights can be loaded later to continue the
#' training from the state saved.
#'
#' A few options this callback provides include:
#'
#' - Whether to only keep the model that has achieved the "best performance" so
#'   far, or whether to save the model at the end of every epoch regardless of
#'   performance.
#' - Definition of "best"; which quantity to monitor and whether it should be
#'   maximized or minimized.
#' - The frequency it should save at. Currently, the callback supports saving
#'   at the end of every epoch, or after a fixed number of training batches.
#' - Whether only weights are saved, or the whole model is saved.
#'
#' # Examples
#' ```python
#' model.compile(loss=..., optimizer=...,
#'               metrics=['accuracy'])
#'
#' EPOCHS = 10
#' checkpoint_filepath = '/tmp/ckpt/checkpoint.model.keras'
#' model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
#'     filepath=checkpoint_filepath,
#'     monitor='val_accuracy',
#'     mode='max',
#'     save_best_only=True)
#'
#' # Model is saved at the end of every epoch, if it's the best seen so far.
#' model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])
#'
#' # The model (that are considered the best) can be loaded as -
#' keras.models.load_model(checkpoint_filepath)
#'
#' # Alternatively, one could checkpoint just the model weights as -
#' checkpoint_filepath = '/tmp/ckpt/checkpoint.weights.h5'
#' model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
#'     filepath=checkpoint_filepath,
#'     save_weights_only=True,
#'     monitor='val_accuracy',
#'     mode='max',
#'     save_best_only=True)
#'
#' # Model weights are saved at the end of every epoch, if it's the best seen
#' # so far.
#' model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])
#'
#' # The model weights (that are considered the best) can be loaded as -
#' model.load_weights(checkpoint_filepath)
#' ```
#'
#' @param filepath string or `PathLike`, path to save the model file.
#'     `filepath` can contain named formatting options,
#'     which will be filled the value of `epoch` and keys in `logs`
#'     (passed in `on_epoch_end`).
#'     The `filepath` name needs to end with `".weights.h5"` when
#'     `save_weights_only=True` or should end with `".keras"` when
#'     checkpoint saving the whole model (default).
#'     For example:
#'     if `filepath` is `"{epoch:02d}-{val_loss:.2f}.keras"`, then the
#'     model checkpoints will be saved with the epoch number and the
#'     validation loss in the filename. The directory of the filepath
#'     should not be reused by any other callbacks to avoid conflicts.
#' @param monitor The metric name to monitor. Typically the metrics are set by
#'     the `Model.compile` method. Note:
#'     * Prefix the name with `"val_"` to monitor validation metrics.
#'     * Use `"loss"` or `"val_loss"` to monitor the model's total loss.
#'     * If you specify metrics as strings, like `"accuracy"`, pass the
#'         same string (with or without the `"val_"` prefix).
#'     * If you pass `metrics.Metric` objects, `monitor` should be set to
#'         `metric.name`
#'     * If you're not sure about the metric names you can check the
#'         contents of the `history.history` dictionary returned by
#'         `history = model.fit()`
#'     * Multi-output models set additional prefixes on the metric names.
#' @param verbose Verbosity mode, 0 or 1. Mode 0 is silent, and mode 1
#'     displays messages when the callback takes an action.
#' @param save_best_only if `save_best_only=True`, it only saves when the model
#'     is considered the "best" and the latest best model according to the
#'     quantity monitored will not be overwritten. If `filepath` doesn't
#'     contain formatting options like `{epoch}` then `filepath` will be
#'     overwritten by each new better model.
#' @param mode one of {`"auto"`, `"min"`, `"max"`}. If `save_best_only=True`, the
#'     decision to overwrite the current save file is made based on either
#'     the maximization or the minimization of the monitored quantity.
#'     For `val_acc`, this should be `"max"`, for `val_loss` this should be
#'     `"min"`, etc. In `"auto"` mode, the mode is set to `"max"` if the
#'     quantities monitored are `"acc"` or start with `"fmeasure"` and are
#'     set to `"min"` for the rest of the quantities.
#' @param save_weights_only if True, then only the model's weights will be saved
#'     (`model.save_weights(filepath)`), else the full model is saved
#'     (`model.save(filepath)`).
#' @param save_freq `"epoch"` or integer. When using `"epoch"`, the callback
#'     saves the model after each epoch. When using integer, the callback
#'     saves the model at end of this many batches. If the `Model` is
#'     compiled with `steps_per_execution=N`, then the saving criteria will
#'     be checked every Nth batch. Note that if the saving isn't aligned to
#'     epochs, the monitored metric may potentially be less reliable (it
#'     could reflect as little as 1 batch, since the metrics get reset
#'     every epoch). Defaults to `"epoch"`.
#' @param initial_value_threshold Floating point initial "best" value of the
#'     metric to be monitored. Only applies if `save_best_value=True`. Only
#'     overwrites the model weights already saved if the performance of
#'     current model is better than this value.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/ModelCheckpoint>
callback_model_checkpoint <-
function (filepath, monitor = "val_loss", verbose = 0L, save_best_only = FALSE,
    save_weights_only = FALSE, mode = "auto", save_freq = "epoch",
    initial_value_threshold = NULL)
{
    args <- capture_args2(list(verbose = as_integer, save_freq = as_integer))
    do.call(keras$callbacks$ModelCheckpoint, args)
}


# keras$callbacks$ProgbarLogger
# keras.callbacks.ProgbarLogger
# keras_core.src.callbacks.progbar_logger.ProgbarLogger
r"-(Callback that prints metrics to stdout.

    Args:
        count_mode: One of `"steps"` or `"samples"`.
            Whether the progress bar should
            count samples seen or steps (batches) seen.

    Raises:
        ValueError: In case of invalid `count_mode`.
    )-"


# keras_core.src.callbacks.progbar_logger.ProgbarLogger
#' Callback that prints metrics to stdout.
#'
#' @description
#'
#' # Raises
#'     ValueError: In case of invalid `count_mode`.
#'
#' @param count_mode One of `"steps"` or `"samples"`.
#' Whether the progress bar should
#' count samples seen or steps (batches) seen.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/ProgbarLogger>
callback_progbar_logger <-
function (count_mode = NULL)
{
    args <- capture_args2(NULL)
    do.call(keras$callbacks$ProgbarLogger, args)
}


# keras$callbacks$ReduceLROnPlateau
# keras.callbacks.ReduceLROnPlateau
# keras_core.src.callbacks.reduce_lr_on_plateau.ReduceLROnPlateau
r"-(Reduce learning rate when a metric has stopped improving.

    Models often benefit from reducing the learning rate by a factor
    of 2-10 once learning stagnates. This callback monitors a
    quantity and if no improvement is seen for a 'patience' number
    of epochs, the learning rate is reduced.

    Example:

    ```python
    reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2,
                                  patience=5, min_lr=0.001)
    model.fit(x_train, y_train, callbacks=[reduce_lr])
    ```

    Args:
        monitor: String. Quantity to be monitored.
        factor: Float. Factor by which the learning rate will be reduced.
            `new_lr = lr * factor`.
        patience: Integer. Number of epochs with no improvement after which
            learning rate will be reduced.
        verbose: Integer. 0: quiet, 1: update messages.
        mode: String. One of `{'auto', 'min', 'max'}`. In `'min'` mode,
            the learning rate will be reduced when the
            quantity monitored has stopped decreasing; in `'max'` mode it will
            be reduced when the quantity monitored has stopped increasing; in
            `'auto'` mode, the direction is automatically inferred from the name
            of the monitored quantity.
        min_delta: Float. Threshold for measuring the new optimum, to only focus
            on significant changes.
        cooldown: Integer. Number of epochs to wait before resuming normal
            operation after the learning rate has been reduced.
        min_lr: Float. Lower bound on the learning rate.
    )-"


# keras_core.src.callbacks.reduce_lr_on_plateau.ReduceLROnPlateau
#' Reduce learning rate when a metric has stopped improving.
#'
#' @description
#' Models often benefit from reducing the learning rate by a factor
#' of 2-10 once learning stagnates. This callback monitors a
#' quantity and if no improvement is seen for a 'patience' number
#' of epochs, the learning rate is reduced.
#'
#' # Examples
#' ```python
#' reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2,
#'                               patience=5, min_lr=0.001)
#' model.fit(x_train, y_train, callbacks=[reduce_lr])
#' ```
#'
#' @param monitor String. Quantity to be monitored.
#' @param factor Float. Factor by which the learning rate will be reduced.
#'     `new_lr = lr * factor`.
#' @param patience Integer. Number of epochs with no improvement after which
#'     learning rate will be reduced.
#' @param verbose Integer. 0: quiet, 1: update messages.
#' @param mode String. One of `{'auto', 'min', 'max'}`. In `'min'` mode,
#'     the learning rate will be reduced when the
#'     quantity monitored has stopped decreasing; in `'max'` mode it will
#'     be reduced when the quantity monitored has stopped increasing; in
#'     `'auto'` mode, the direction is automatically inferred from the name
#'     of the monitored quantity.
#' @param min_delta Float. Threshold for measuring the new optimum, to only focus
#'     on significant changes.
#' @param cooldown Integer. Number of epochs to wait before resuming normal
#'     operation after the learning rate has been reduced.
#' @param min_lr Float. Lower bound on the learning rate.
#' @param ... Passed on to the Python callable
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/ReduceLROnPlateau>
callback_reduce_lr_on_plateau <-
function (monitor = "val_loss", factor = 0.1, patience = 10L,
    verbose = 0L, mode = "auto", min_delta = 1e-04, cooldown = 0L,
    min_lr = 0L, ...)
{
    args <- capture_args2(list(patience = as_integer, verbose = as_integer,
        cooldown = as_integer, min_lr = as_integer))
    do.call(keras$callbacks$ReduceLROnPlateau, args)
}


# keras$callbacks$RemoteMonitor
# keras.callbacks.RemoteMonitor
# keras_core.src.callbacks.remote_monitor.RemoteMonitor
r"-(Callback used to stream events to a server.

    Requires the `requests` library.
    Events are sent to `root + '/publish/epoch/end/'` by default. Calls are
    HTTP POST, with a `data` argument which is a
    JSON-encoded dictionary of event data.
    If `send_as_json=True`, the content type of the request will be
    `"application/json"`.
    Otherwise the serialized JSON will be sent within a form.

    Args:
        root: String; root url of the target server.
        path: String; path relative to `root` to which the events will be sent.
        field: String; JSON field under which the data will be stored.
            The field is used only if the payload is sent within a form
            (i.e. send_as_json is set to False).
        headers: Dictionary; optional custom HTTP headers.
        send_as_json: Boolean; whether the request should be
            sent as `"application/json"`.
    )-"


# keras_core.src.callbacks.remote_monitor.RemoteMonitor
#' Callback used to stream events to a server.
#'
#' @description
#' Requires the `requests` library.
#' Events are sent to `root + '/publish/epoch/end/'` by default. Calls are
#' HTTP POST, with a `data` argument which is a
#' JSON-encoded dictionary of event data.
#' If `send_as_json=True`, the content type of the request will be
#' `"application/json"`.
#' Otherwise the serialized JSON will be sent within a form.
#'
#' @param root String; root url of the target server.
#' @param path String; path relative to `root` to which the events will be sent.
#' @param field String; JSON field under which the data will be stored.
#'     The field is used only if the payload is sent within a form
#'     (i.e. send_as_json is set to False).
#' @param headers Dictionary; optional custom HTTP headers.
#' @param send_as_json Boolean; whether the request should be
#'     sent as `"application/json"`.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/RemoteMonitor>
callback_remote_monitor <-
function (root = "http://localhost:9000", path = "/publish/epoch/end/",
    field = "data", headers = NULL, send_as_json = FALSE)
{
    args <- capture_args2(NULL)
    do.call(keras$callbacks$RemoteMonitor, args)
}


# keras$callbacks$TensorBoard
# keras.callbacks.TensorBoard
# keras_core.src.callbacks.tensorboard.TensorBoard
r"-(Enable visualizations for TensorBoard.

    TensorBoard is a visualization tool provided with TensorFlow. A TensorFlow
    installation is required to use this callback.

    This callback logs events for TensorBoard, including:

    * Metrics summary plots
    * Training graph visualization
    * Weight histograms
    * Sampled profiling

    When used in `model.evaluate()` or regular validation
    in addition to epoch summaries, there will be a summary that records
    evaluation metrics vs `model.optimizer.iterations` written. The metric names
    will be prepended with `evaluation`, with `model.optimizer.iterations` being
    the step in the visualized TensorBoard.

    If you have installed TensorFlow with pip, you should be able
    to launch TensorBoard from the command line:

    ```
    tensorboard --logdir=path_to_your_logs
    ```

    You can find more information about TensorBoard
    [here](https://www.tensorflow.org/get_started/summaries_and_tensorboard).

    Args:
        log_dir: the path of the directory where to save the log files to be
            parsed by TensorBoard. e.g.,
            `log_dir = os.path.join(working_dir, 'logs')`.
            This directory should not be reused by any other callbacks.
        histogram_freq: frequency (in epochs) at which to compute
            weight histograms for the layers of the model. If set to 0,
            histograms won't be computed. Validation data (or split) must be
            specified for histogram visualizations.
        write_graph:  (Not supported at this time)
            Whether to visualize the graph in TensorBoard.
            Note that the log file can become quite large
            when `write_graph` is set to `True`.
        write_images: whether to write model weights to visualize as image in
            TensorBoard.
        write_steps_per_second: whether to log the training steps per second
            into TensorBoard. This supports both epoch and batch frequency
            logging.
        update_freq: `"batch"` or `"epoch"` or integer. When using `"epoch"`,
            writes the losses and metrics to TensorBoard after every epoch.
            If using an integer, let's say `1000`, all metrics and losses
            (including custom ones added by `Model.compile`) will be logged to
            TensorBoard every 1000 batches. `"batch"` is a synonym for 1,
            meaning that they will be written every batch.
            Note however that writing too frequently to TensorBoard can slow
            down your training, especially when used with distribution
            strategies as it will incur additional synchronization overhead.
            Batch-level summary writing is also available via `train_step`
            override. Please see
            [TensorBoard Scalars tutorial](
                https://www.tensorflow.org/tensorboard/scalars_and_keras#batch-level_logging)  # noqa: E501
            for more details.
        profile_batch: (Not supported at this time)
            Profile the batch(es) to sample compute characteristics.
            profile_batch must be a non-negative integer or a tuple of integers.
            A pair of positive integers signify a range of batches to profile.
            By default, profiling is disabled.
        embeddings_freq: frequency (in epochs) at which embedding layers will be
            visualized. If set to 0, embeddings won't be visualized.
        embeddings_metadata: Dictionary which maps embedding layer names to the
            filename of a file in which to save metadata for the embedding layer.
            In case the same metadata file is to be
            used for all embedding layers, a single filename can be passed.

    Examples:

    Basic usage:

    ```python
    tensorboard_callback = keras.callbacks.TensorBoard(log_dir="./logs")
    model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])
    # Then run the tensorboard command to view the visualizations.
    ```

    Custom batch-level summaries in a subclassed Model:

    ```python
    class MyModel(keras.Model):

        def build(self, _):
            self.dense = keras.layers.Dense(10)

        def call(self, x):
            outputs = self.dense(x)
            tf.summary.histogram('outputs', outputs)
            return outputs

    model = MyModel()
    model.compile('sgd', 'mse')

    # Make sure to set `update_freq=N` to log a batch-level summary every N
    # batches.  In addition to any `tf.summary` contained in `model.call()`,
    # metrics added in `Model.compile` will be logged every N batches.
    tb_callback = keras.callbacks.TensorBoard('./logs', update_freq=1)
    model.fit(x_train, y_train, callbacks=[tb_callback])
    ```

    Custom batch-level summaries in a Functional API Model:

    ```python
    def my_summary(x):
        tf.summary.histogram('x', x)
        return x

    inputs = keras.Input(10)
    x = keras.layers.Dense(10)(inputs)
    outputs = keras.layers.Lambda(my_summary)(x)
    model = keras.Model(inputs, outputs)
    model.compile('sgd', 'mse')

    # Make sure to set `update_freq=N` to log a batch-level summary every N
    # batches. In addition to any `tf.summary` contained in `Model.call`,
    # metrics added in `Model.compile` will be logged every N batches.
    tb_callback = keras.callbacks.TensorBoard('./logs', update_freq=1)
    model.fit(x_train, y_train, callbacks=[tb_callback])
    ```

    Profiling:

    ```python
    # Profile a single batch, e.g. the 5th batch.
    tensorboard_callback = keras.callbacks.TensorBoard(
        log_dir='./logs', profile_batch=5)
    model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])

    # Profile a range of batches, e.g. from 10 to 20.
    tensorboard_callback = keras.callbacks.TensorBoard(
        log_dir='./logs', profile_batch=(10,20))
    model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])
    ```
    )-"


# keras_core.src.callbacks.tensorboard.TensorBoard
#' Enable visualizations for TensorBoard.
#'
#' @description
#' TensorBoard is a visualization tool provided with TensorFlow. A TensorFlow
#' installation is required to use this callback.
#'
#' This callback logs events for TensorBoard, including:
#'
#' * Metrics summary plots
#' * Training graph visualization
#' * Weight histograms
#' * Sampled profiling
#'
#' When used in `model.evaluate()` or regular validation
#' in addition to epoch summaries, there will be a summary that records
#' evaluation metrics vs `model.optimizer.iterations` written. The metric names
#' will be prepended with `evaluation`, with `model.optimizer.iterations` being
#' the step in the visualized TensorBoard.
#'
#' If you have installed TensorFlow with pip, you should be able
#' to launch TensorBoard from the command line:
#'
#' ```
#' tensorboard --logdir=path_to_your_logs
#' ```
#'
#' You can find more information about TensorBoard
#' [here](https://www.tensorflow.org/get_started/summaries_and_tensorboard).
#'
#' # Examples
#' Basic usage:
#'
#' ```python
#' tensorboard_callback = keras.callbacks.TensorBoard(log_dir="./logs")
#' model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])
#' # Then run the tensorboard command to view the visualizations.
#' ```
#'
#' Custom batch-level summaries in a subclassed Model:
#'
#' ```python
#' class MyModel(keras.Model):
#'
#'     def build(self, _):
#'         self.dense = keras.layers.Dense(10)
#'
#'     def call(self, x):
#'         outputs = self.dense(x)
#'         tf.summary.histogram('outputs', outputs)
#'         return outputs
#'
#' model = MyModel()
#' model.compile('sgd', 'mse')
#'
#' # Make sure to set `update_freq=N` to log a batch-level summary every N
#' # batches.  In addition to any `tf.summary` contained in `model.call()`,
#' # metrics added in `Model.compile` will be logged every N batches.
#' tb_callback = keras.callbacks.TensorBoard('./logs', update_freq=1)
#' model.fit(x_train, y_train, callbacks=[tb_callback])
#' ```
#'
#' Custom batch-level summaries in a Functional API Model:
#'
#' ```python
#' def my_summary(x):
#'     tf.summary.histogram('x', x)
#'     return x
#'
#' inputs = keras.Input(10)
#' x = keras.layers.Dense(10)(inputs)
#' outputs = keras.layers.Lambda(my_summary)(x)
#' model = keras.Model(inputs, outputs)
#' model.compile('sgd', 'mse')
#'
#' # Make sure to set `update_freq=N` to log a batch-level summary every N
#' # batches. In addition to any `tf.summary` contained in `Model.call`,
#' # metrics added in `Model.compile` will be logged every N batches.
#' tb_callback = keras.callbacks.TensorBoard('./logs', update_freq=1)
#' model.fit(x_train, y_train, callbacks=[tb_callback])
#' ```
#'
#' Profiling:
#'
#' ```python
#' # Profile a single batch, e.g. the 5th batch.
#' tensorboard_callback = keras.callbacks.TensorBoard(
#'     log_dir='./logs', profile_batch=5)
#' model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])
#'
#' # Profile a range of batches, e.g. from 10 to 20.
#' tensorboard_callback = keras.callbacks.TensorBoard(
#'     log_dir='./logs', profile_batch=(10,20))
#' model.fit(x_train, y_train, epochs=2, callbacks=[tensorboard_callback])
#' ```
#'
#' @param log_dir the path of the directory where to save the log files to be
#'     parsed by TensorBoard. e.g.,
#'     `log_dir = os.path.join(working_dir, 'logs')`.
#'     This directory should not be reused by any other callbacks.
#' @param histogram_freq frequency (in epochs) at which to compute
#'     weight histograms for the layers of the model. If set to 0,
#'     histograms won't be computed. Validation data (or split) must be
#'     specified for histogram visualizations.
#' @param write_graph (Not supported at this time)
#'     Whether to visualize the graph in TensorBoard.
#'     Note that the log file can become quite large
#'     when `write_graph` is set to `True`.
#' @param write_images whether to write model weights to visualize as image in
#'     TensorBoard.
#' @param write_steps_per_second whether to log the training steps per second
#'     into TensorBoard. This supports both epoch and batch frequency
#'     logging.
#' @param update_freq `"batch"` or `"epoch"` or integer. When using `"epoch"`,
#'     writes the losses and metrics to TensorBoard after every epoch.
#'     If using an integer, let's say `1000`, all metrics and losses
#'     (including custom ones added by `Model.compile`) will be logged to
#'     TensorBoard every 1000 batches. `"batch"` is a synonym for 1,
#'     meaning that they will be written every batch.
#'     Note however that writing too frequently to TensorBoard can slow
#'     down your training, especially when used with distribution
#'     strategies as it will incur additional synchronization overhead.
#'     Batch-level summary writing is also available via `train_step`
#'     override. Please see
#'     [TensorBoard Scalars tutorial](
#'         https://www.tensorflow.org/tensorboard/scalars_and_keras#batch-level_logging)  # noqa: E501
#'     for more details.
#' @param profile_batch (Not supported at this time)
#'     Profile the batch(es) to sample compute characteristics.
#'     profile_batch must be a non-negative integer or a tuple of integers.
#'     A pair of positive integers signify a range of batches to profile.
#'     By default, profiling is disabled.
#' @param embeddings_freq frequency (in epochs) at which embedding layers will be
#'     visualized. If set to 0, embeddings won't be visualized.
#' @param embeddings_metadata Dictionary which maps embedding layer names to the
#'     filename of a file in which to save metadata for the embedding layer.
#'     In case the same metadata file is to be
#'     used for all embedding layers, a single filename can be passed.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/TensorBoard>
callback_tensorboard <-
function (log_dir = "logs", histogram_freq = 0L, write_graph = TRUE,
    write_images = FALSE, write_steps_per_second = FALSE, update_freq = "epoch",
    profile_batch = 0L, embeddings_freq = 0L, embeddings_metadata = NULL)
{
    args <- capture_args2(list(histogram_freq = as_integer, update_freq = as_integer,
        profile_batch = as_integer, embeddings_freq = as_integer))
    do.call(keras$callbacks$TensorBoard, args)
}


# keras$callbacks$TerminateOnNaN
# keras.callbacks.TerminateOnNaN
# keras_core.src.callbacks.terminate_on_nan.TerminateOnNaN
r"-(Callback that terminates training when a NaN loss is encountered.)-"


# keras_core.src.callbacks.terminate_on_nan.TerminateOnNaN
#' Callback that terminates training when a NaN loss is encountered.
#'
#' @export
#' @family callback
#' @seealso
#' + <https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/TerminateOnNaN>
callback_terminate_on_nan <-
function ()
{
    args <- capture_args2(NULL)
    do.call(keras$callbacks$TerminateOnNaN, args)
}
