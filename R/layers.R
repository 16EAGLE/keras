

#' Input layer
#' 
#' Layer to be used as an entry point into a graph.
#' 
#' @param shape Shapes, not including the batch size. For instance, 
#'   `shape=c(32)` indicates that the expected input will be batches of 
#'   32-dimensional vectors.
#' @param batch_shape Shapes, including the batch size. For instance, 
#'   `batch_shape= c(10, 32)` indicates that the expected input will be batches 
#'   of 10 32-dimensional vectors. batch_shape=c(NULL, 32)` indicates batches of
#'   an arbitrary number of 32-dimensional vectors.
#' @param name An optional name string for the layer. Should be unique in a 
#'   model (do not reuse the same name twice). It will be autogenerated if it 
#'   isn't provided.
#' @param dtype  The data type expected by the input, as a string (`float32`,
#'   `float64`, `int32`...)
#' @param sparse Boolean, whether the placeholder created is meant to be sparse.
#'   
#' @details It can either wrap an existing tensor (pass an `input_tensor` 
#'   argument) or create its a placeholder tensor (pass arguments `input_shape` 
#'   or `batch_input_shape` as well as `input_dtype`).
#'   
#' @export
layer_input <- function(shape = NULL, batch_shape = NULL, name = NULL,
                        dtype = "float32", sparse = FALSE) {
  keras$layers$Input(
    shape = normalize_shape(shape),
    batch_shape = normalize_shape(batch_shape),
    name = name,
    dtype = dtype,
    sparse = sparse
  )
}

#' @export
layer_dense <- function(x, output_dim, init = 'glorot_uniform', activation = NULL, weights = NULL, 
                           W_regularizer = NULL, b_regularizer = NULL, activity_regularizer = NULL, 
                           W_constraint = NULL, b_constraint = NULL, bias = TRUE, input_dim = NULL) {
  layer <- keras$layers$Dense(
    output_dim = as.integer(output_dim),
    input_dim = as.integer(input_dim),
    activation = activation
  )
  compose_layer(x, layer)
}

#' @export
layer_activation <- function(x, activation) {
  layer <- keras$layers$Activation(
    activation = activation
  )
  compose_layer(x, layer)
}



# Helper function to compose a layer with an object of type Model or Layer
compose_layer <- function(x, layer) {
  
  # if a sequential is passed then add it to the model
  if (inherits(x, "keras.models.Sequential")) {
    
    x <- clone_model_if_possible(x)
    x$add(layer)
    x
    
  # if a layer is passed then wrap the layer
  } else if (inherits(x, "tensorflow.python.framework.ops.Tensor") ||
             inherits(x, "keras.engine.topology.Layer")) {
    
    py_call(layer, list(x))
    
  # otherwie it's an unexpected type
  } else {
    
    stop("Invalid input to layer function (must be a model or a tensor)",
         call. = FALSE)
  }
}


normalize_shape <- function(shape) {
  if (is.null(shape))
    shape
  else {
    if (is.list(shape) || is.numeric(shape))
      shape <- as.integer(shape)
    tuple(shape)
  }
}


