% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autogen-layers-preprocessing.R,
%   R/layers-preprocessing.R
\name{layer_discretization}
\alias{layer_discretization}
\title{A preprocessing layer which buckets continuous features by ranges.}
\usage{
layer_discretization(
  object,
  bin_boundaries = NULL,
  num_bins = NULL,
  epsilon = 0.01,
  output_mode = "int",
  sparse = FALSE,
  dtype = NULL,
  name = NULL
)

layer_discretization(
  object,
  bin_boundaries = NULL,
  num_bins = NULL,
  epsilon = 0.01,
  output_mode = "int",
  sparse = FALSE,
  dtype = NULL,
  name = NULL
)
}
\arguments{
\item{bin_boundaries}{A list of bin boundaries.
The leftmost and rightmost bins
will always extend to \code{-inf} and \code{inf},
so \verb{bin_boundaries=[0., 1., 2.]}
generates bins \verb{(-inf, 0.)}, \verb{[0., 1.)}, \verb{[1., 2.)},
and \verb{[2., +inf)}.
If this option is set, \code{adapt()} should not be called.}

\item{num_bins}{The integer number of bins to compute.
If this option is set,
\code{adapt()} should be called to learn the bin boundaries.}

\item{epsilon}{Error tolerance, typically a small fraction
close to zero (e.g. 0.01). Higher values of epsilon increase
the quantile approximation, and hence result in more
unequal buckets, but could improve performance
and resource consumption.}

\item{output_mode}{Specification for the output of the layer.
Values can be \code{"int"}, \code{"one_hot"}, \code{"multi_hot"}, or
\code{"count"} configuring the layer as follows:
- \code{"int"}: Return the discretized bin indices directly.
- \code{"one_hot"}: Encodes each individual element in the
input into an array the same size as \code{num_bins},
containing a 1 at the input's bin
index. If the last dimension is size 1, will encode on that
dimension.  If the last dimension is not size 1,
will append a new dimension for the encoded output.
- \code{"multi_hot"}: Encodes each sample in the input into a
single array the same size as \code{num_bins},
containing a 1 for each bin index
index present in the sample.
Treats the last dimension as the sample
dimension, if input shape is \verb{(..., sample_length)},
output shape will be \verb{(..., num_tokens)}.
- \code{"count"}: As \code{"multi_hot"}, but the int array contains
a count of the number of times the bin index appeared
in the sample.
Defaults to \code{"int"}.}

\item{sparse}{Boolean. Only applicable to \code{"one_hot"}, \code{"multi_hot"},
and \code{"count"} output modes. Only supported with TensorFlow
backend. If \code{True}, returns a \code{SparseTensor} instead of
a dense \code{Tensor}. Defaults to \code{False}.}
}
\description{
This layer will place each element of its input data into one of several
contiguous ranges and output an integer index indicating which range each
element was placed in.

\strong{Note:} This layer is safe to use inside a \code{tf.data} pipeline
(independently of which backend you're using).

This layer will place each element of its input data into one of several
contiguous ranges and output an integer index indicating which range each
element was placed in.

\strong{Note:} This layer is safe to use inside a \code{tf.data} pipeline
(independently of which backend you're using).
}
\section{Input Shape}{
Any array of dimension 2 or higher.

Any array of dimension 2 or higher.
}

\section{Output Shape}{
Same as input shape.

Same as input shape.
}

\section{Examples}{
Discretize float values based on provided buckets.

\if{html}{\out{<div class="sourceCode python">}}\preformatted{input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])
layer = Discretization(bin_boundaries=[0., 1., 2.])
layer(input)
# array([[0, 2, 3, 1],
#        [1, 3, 2, 1]])
}\if{html}{\out{</div>}}

Discretize float values based on a number of buckets to compute.

\if{html}{\out{<div class="sourceCode python">}}\preformatted{input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])
layer = Discretization(num_bins=4, epsilon=0.01)
layer.adapt(input)
layer(input)
# array([[0, 2, 3, 2],
#        [1, 3, 3, 1]])
}\if{html}{\out{</div>}}

Discretize float values based on provided buckets.

\if{html}{\out{<div class="sourceCode python">}}\preformatted{input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])
layer = Discretization(bin_boundaries=[0., 1., 2.])
layer(input)
# array([[0, 2, 3, 1],
#        [1, 3, 2, 1]])
}\if{html}{\out{</div>}}

Discretize float values based on a number of buckets to compute.

\if{html}{\out{<div class="sourceCode python">}}\preformatted{input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])
layer = Discretization(num_bins=4, epsilon=0.01)
layer.adapt(input)
layer(input)
# array([[0, 2, 3, 2],
#        [1, 3, 3, 1]])
}\if{html}{\out{</div>}}
}

\seealso{
\itemize{
\item \url{https://www.tensorflow.org/api_docs/python/tf/keras/layers/Discretization}
}

\itemize{
\item \url{https://www.tensorflow.org/api_docs/python/tf/keras/layers/Discretization}
}

Other preprocessing layers: 
\code{\link{layer_category_encoding}()},
\code{\link{layer_center_crop}()},
\code{\link{layer_hashed_crossing}()},
\code{\link{layer_hashing}()},
\code{\link{layer_integer_lookup}()},
\code{\link{layer_normalization}()},
\code{\link{layer_random_brightness}()},
\code{\link{layer_random_contrast}()},
\code{\link{layer_random_crop}()},
\code{\link{layer_random_flip}()},
\code{\link{layer_random_rotation}()},
\code{\link{layer_random_translation}()},
\code{\link{layer_random_zoom}()},
\code{\link{layer_rescaling}()},
\code{\link{layer_resizing}()},
\code{\link{layer_string_lookup}()},
\code{\link{layer_text_vectorization}()}

Other preprocessing layers: 
\code{\link{layer_category_encoding}()},
\code{\link{layer_center_crop}()},
\code{\link{layer_hashed_crossing}()},
\code{\link{layer_hashing}()},
\code{\link{layer_integer_lookup}()},
\code{\link{layer_normalization}()},
\code{\link{layer_random_brightness}()},
\code{\link{layer_random_contrast}()},
\code{\link{layer_random_crop}()},
\code{\link{layer_random_flip}()},
\code{\link{layer_random_rotation}()},
\code{\link{layer_random_translation}()},
\code{\link{layer_random_zoom}()},
\code{\link{layer_rescaling}()},
\code{\link{layer_resizing}()},
\code{\link{layer_string_lookup}()},
\code{\link{layer_text_vectorization}()}
}
\concept{preprocessing layers}
