% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{layer_dense}
\alias{layer_dense}
\title{Add a densely-connected NN layer to an output}
\usage{
layer_dense(x, units, kernel_initializer = "glorot_uniform",
  activation = NULL, weights = NULL, kernel_regularizer = NULL,
  bias_regularizer = NULL, activity_regularizer = NULL,
  kernel_constraint = NULL, bias_constraint = NULL, use_bias = TRUE,
  input_dim = NULL)
}
\arguments{
\item{x}{Model or layer}

\item{units}{Output dimension}

\item{kernel_initializer}{Name of initialization function for the weights of the layer or
alternatively, function to use for weights initialization. This parameter
is only relevant if you don't pass a \code{weights} argument.}

\item{activation}{Name of activation function to use, or alternatively,
elementwise function. If you don't specify anything, no activation is
applied (ie. "linear" activation: a(x) = x).}

\item{weights}{List of vectors, matrixes, or arrays to set as initial
weights. The list should have 2 elements, of shape \code{(input_dim, output_dim)} and (output_dim,) for weights and biases respectively.}

\item{kernel_regularizer}{Weight regularizer applied to the main weights matrix.}

\item{bias_regularizer}{Weight regularizer applied to the bias.}

\item{activity_regularizer}{Activity regularizer applied to the network
output.}

\item{kernel_constraint}{Constraint applied to the main weights matrix.}

\item{bias_constraint}{Constraint applied to the bias.}

\item{use_bias}{Whether to include a bias (i.e. make the layer affine rather than
linear).}

\item{input_dim}{Dimensionality of the input (integer). This argument (or
alternatively, the keyword argument \code{input_shape}) is required when using
this layer as the first layer in a model.}
}
\description{
Add a densely-connected NN layer to an output
}
\section{Input and Output Shapes}{


Input shape: nD tensor with shape: \code{(nb_samples, ..., input_dim)}. The most
common situation would be a 2D input with shape \code{(nb_samples, input_dim)}.

Output shape: nD tensor with shape: \code{(nb_samples, ..., output_dim)}. For
instance, for a 2D input with shape \code{(nb_samples, input_dim)}, the output
would have shape \code{(nb_samples, output_dim)}.
}

