% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autogen-metrics.R
\name{metric_one_hot_iou}
\alias{metric_one_hot_iou}
\title{Computes the Intersection-Over-Union metric for one-hot encoded labels.}
\usage{
metric_one_hot_iou(
  ...,
  num_classes,
  target_class_ids,
  name = NULL,
  dtype = NULL,
  ignore_class = NULL,
  sparse_y_pred = FALSE,
  axis = -1L
)
}
\arguments{
\item{...}{Passed on to the Python callable}

\item{num_classes}{The possible number of labels the prediction task can have.}

\item{target_class_ids}{A tuple or list of target class ids for which the
metric is returned. To compute IoU for a specific class, a list
(or tuple) of a single id value should be provided.}

\item{name}{(Optional) string name of the metric instance.}

\item{dtype}{(Optional) data type of the metric result.}

\item{ignore_class}{Optional integer. The ID of a class to be ignored during
metric computation. This is useful, for example, in segmentation
problems featuring a "void" class (commonly -1 or 255) in
segmentation maps. By default (\code{ignore_class=None}), all classes are
considered.}

\item{sparse_y_pred}{Whether predictions are encoded using integers or
dense floating point vectors. If \code{False}, the \code{argmax} function
is used to determine each sample's most likely associated label.}

\item{axis}{(Optional) The dimension containing the logits. Defaults to \code{-1}.}
}
\description{
Formula:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{iou = true_positives / (true_positives + false_positives + false_negatives)
}\if{html}{\out{</div>}}

Intersection-Over-Union is a common evaluation metric for semantic image
segmentation.

To compute IoUs, the predictions are accumulated in a confusion matrix,
weighted by \code{sample_weight} and the metric is then calculated from it.

If \code{sample_weight} is \code{None}, weights default to 1.
Use \code{sample_weight} of 0 to mask values.

This class can be used to compute IoU for multi-class classification tasks
where the labels are one-hot encoded (the last axis should have one
dimension per class). Note that the predictions should also have the same
shape. To compute the IoU, first the labels and predictions are converted
back into integer format by taking the argmax over the class axis. Then the
same computation steps as for the base \code{IoU} class apply.

Note, if there is only one channel in the labels and predictions, this class
is the same as class \code{IoU}. In this case, use \code{IoU} instead.

Also, make sure that \code{num_classes} is equal to the number of classes in the
data, to avoid a "labels out of bound" error when the confusion matrix is
computed.
}
\section{Examples}{
Standalone usage:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])
y_pred = np.array([[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1],
                      [0.1, 0.4, 0.5]])
sample_weight = [0.1, 0.2, 0.3, 0.4]
m = keras.metrics.OneHotIoU(num_classes=3, target_class_ids=[0, 2])
m.update_state(
    y_true=y_true, y_pred=y_pred, sample_weight=sample_weight)
# cm = [[0, 0, 0.2+0.4],
#       [0.3, 0, 0],
#       [0, 0, 0.1]]
# sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1]
# true_positives = [0, 0, 0.1]
# single_iou = true_positives / (sum_row + sum_col - true_positives))
# mean_iou = (0 / (0.3 + 0.6 - 0) + 0.1 / (0.7 + 0.1 - 0.1)) / 2
m.result()
# 0.071
}\if{html}{\out{</div>}}

Usage with \code{compile()} API:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{model.compile(
    optimizer='sgd',
    loss='mse',
    metrics=[keras.metrics.OneHotIoU(
        num_classes=3,
        target_class_id=[1]
    )]
)
}\if{html}{\out{</div>}}
}

\seealso{
\itemize{
\item \url{https://www.tensorflow.org/api_docs/python/tf/keras/metrics/OneHotIoU}
}

Other iou metrics: 
\code{\link{metric_binary_iou}()},
\code{\link{metric_iou}()},
\code{\link{metric_mean_iou}()},
\code{\link{metric_one_hot_mean_iou}()}

Other metrics: 
\code{\link{custom_metric}()},
\code{\link{metric_auc}()},
\code{\link{metric_binary_accuracy}()},
\code{\link{metric_binary_crossentropy}()},
\code{\link{metric_binary_iou}()},
\code{\link{metric_categorical_accuracy}()},
\code{\link{metric_categorical_crossentropy}()},
\code{\link{metric_categorical_hinge}()},
\code{\link{metric_cosine_similarity}()},
\code{\link{metric_f1_score}()},
\code{\link{metric_false_negatives}()},
\code{\link{metric_false_positives}()},
\code{\link{metric_fbeta_score}()},
\code{\link{metric_hinge}()},
\code{\link{metric_iou}()},
\code{\link{metric_kl_divergence}()},
\code{\link{metric_log_cosh_error}()},
\code{\link{metric_mean_absolute_error}()},
\code{\link{metric_mean_absolute_percentage_error}()},
\code{\link{metric_mean_iou}()},
\code{\link{metric_mean_squared_error}()},
\code{\link{metric_mean_squared_logarithmic_error}()},
\code{\link{metric_mean_wrapper}()},
\code{\link{metric_mean}()},
\code{\link{metric_one_hot_mean_iou}()},
\code{\link{metric_poisson}()},
\code{\link{metric_precision_at_recall}()},
\code{\link{metric_precision}()},
\code{\link{metric_r2_score}()},
\code{\link{metric_recall_at_precision}()},
\code{\link{metric_recall}()},
\code{\link{metric_root_mean_squared_error}()},
\code{\link{metric_sensitivity_at_specificity}()},
\code{\link{metric_sparse_categorical_accuracy}()},
\code{\link{metric_sparse_categorical_crossentropy}()},
\code{\link{metric_sparse_top_k_categorical_accuracy}()},
\code{\link{metric_specificity_at_sensitivity}()},
\code{\link{metric_squared_hinge}()},
\code{\link{metric_sum}()},
\code{\link{metric_top_k_categorical_accuracy}()},
\code{\link{metric_true_negatives}()},
\code{\link{metric_true_positives}()}
}
\concept{iou metrics}
\concept{metrics}
