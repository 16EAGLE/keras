diff --git a/man-src/callback_model_checkpoint/roxygen.Rmd b/man-src/callback_model_checkpoint/roxygen.Rmd
index a16fe56a..2ad2c7b0 100644
--- a/man-src/callback_model_checkpoint/roxygen.Rmd
+++ b/man-src/callback_model_checkpoint/roxygen.Rmd
@@ -4,3 +4,3 @@ Callback to save the Keras model or model weights at some frequency.
 `ModelCheckpoint` callback is used in conjunction with training using
-`model.fit()` to save a model or weights (in a checkpoint file) at some
+`model %>% fit()` to save a model or weights (in a checkpoint file) at some
 interval, so the model or weights can be loaded later to continue the
@@ -20,28 +20,27 @@ A few options this callback provides include:
 # Examples
-```python
-model.compile(loss=..., optimizer=...,
-              metrics=['accuracy'])
+```{r}
+model %>% compile(loss = ..., optimizer = ..., metrics = c('accuracy'))
 
-EPOCHS = 10
-checkpoint_filepath = '/tmp/ckpt/checkpoint.model.keras'
-model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
-    filepath=checkpoint_filepath,
-    monitor='val_accuracy',
-    mode='max',
-    save_best_only=True)
+EPOCHS <- 10
+checkpoint_filepath <- '/tmp/ckpt/checkpoint.model.keras'
+model_checkpoint_callback <- callback_model_checkpoint(
+    filepath = checkpoint_filepath,
+    monitor = 'val_accuracy',
+    mode = 'max',
+    save_best_only = TRUE)
 
 # Model is saved at the end of every epoch, if it's the best seen so far.
-model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])
+model %>% fit(epochs = EPOCHS, callbacks = list(model_checkpoint_callback))
 
 # The model (that are considered the best) can be loaded as -
-keras.models.load_model(checkpoint_filepath)
+keras::load_model_hdf5(checkpoint_filepath)
 
 # Alternatively, one could checkpoint just the model weights as -
-checkpoint_filepath = '/tmp/ckpt/checkpoint.weights.h5'
-model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
-    filepath=checkpoint_filepath,
-    save_weights_only=True,
-    monitor='val_accuracy',
-    mode='max',
-    save_best_only=True)
+checkpoint_filepath <- '/tmp/ckpt/checkpoint.weights.h5'
+model_checkpoint_callback <- callback_model_checkpoint(
+    filepath = checkpoint_filepath,
+    save_weights_only = TRUE,
+    monitor = 'val_accuracy',
+    mode = 'max',
+    save_best_only = TRUE)
 
@@ -49,9 +48,9 @@ model_checkpoint_callback = keras.callbacks.ModelCheckpoint(
 # so far.
-model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])
+model %>% fit(epochs = EPOCHS, callbacks = list(model_checkpoint_callback))
 
 # The model weights (that are considered the best) can be loaded as -
-model.load_weights(checkpoint_filepath)
+model %>% load_model_weights_hdf5(checkpoint_filepath)
 ```
 
-@param filepath string or `PathLike`, path to save the model file.
+@param filepath string, path to save the model file.
     `filepath` can contain named formatting options,
@@ -60,3 +59,3 @@ model.load_weights(checkpoint_filepath)
     The `filepath` name needs to end with `".weights.h5"` when
-    `save_weights_only=True` or should end with `".keras"` when
+    `save_weights_only=TRUE` or should end with `".keras"` when
     checkpoint saving the whole model (default).
@@ -68,3 +67,3 @@ model.load_weights(checkpoint_filepath)
 @param monitor The metric name to monitor. Typically the metrics are set by
-    the `Model.compile` method. Note:
+    the `model %>% compile()` method. Note:
     * Prefix the name with `"val_"` to monitor validation metrics.
@@ -74,6 +73,6 @@ model.load_weights(checkpoint_filepath)
     * If you pass `metrics.Metric` objects, `monitor` should be set to
-        `metric.name`
+        `metric$name`
     * If you're not sure about the metric names you can check the
-        contents of the `history.history` dictionary returned by
-        `history = model.fit()`
+        contents of the `history$metrics` list returned by
+        `history <- model %>% fit()`
     * Multi-output models set additional prefixes on the metric names.
@@ -81,3 +80,3 @@ model.load_weights(checkpoint_filepath)
     displays messages when the callback takes an action.
-@param save_best_only if `save_best_only=True`, it only saves when the model
+@param save_best_only if `save_best_only=TRUE`, it only saves when the model
     is considered the "best" and the latest best model according to the
@@ -86,3 +85,3 @@ model.load_weights(checkpoint_filepath)
     overwritten by each new better model.
-@param mode one of {`"auto"`, `"min"`, `"max"`}. If `save_best_only=True`, the
+@param mode one of {`"auto"`, `"min"`, `"max"`}. If `save_best_only=TRUE`, the
     decision to overwrite the current save file is made based on either
@@ -93,5 +92,5 @@ model.load_weights(checkpoint_filepath)
     set to `"min"` for the rest of the quantities.
-@param save_weights_only if True, then only the model's weights will be saved
-    (`model.save_weights(filepath)`), else the full model is saved
-    (`model.save(filepath)`).
+@param save_weights_only if TRUE, then only the model's weights will be saved
+    (`model %>% save_model_weights_hdf5(filepath)`), else the full model is saved
+    (`model %>% save_model_hdf5(filepath)`).
 @param save_freq `"epoch"` or integer. When using `"epoch"`, the callback
@@ -105,3 +104,3 @@ model.load_weights(checkpoint_filepath)
 @param initial_value_threshold Floating point initial "best" value of the
-    metric to be monitored. Only applies if `save_best_value=True`. Only
+    metric to be monitored. Only applies if `save_best_value=TRUE`. Only
     overwrites the model weights already saved if the performance of
