diff --git a/man-src/callback_lambda/roxygen.Rmd b/man-src/callback_lambda/roxygen.Rmd
index 56eb7493..7f653e2f 100644
--- a/man-src/callback_lambda/roxygen.Rmd
+++ b/man-src/callback_lambda/roxygen.Rmd
@@ -17,29 +17,48 @@ Note that the callbacks expects positional arguments, as:
 # Examples
-    ```python
-    # Print the batch number at the beginning of every batch.
-    batch_print_callback = LambdaCallback(
-        on_train_batch_begin=lambda batch,logs: print(batch))
-
-    # Stream the epoch loss to a file in JSON format. The file content
-    # is not well-formed JSON but rather has a JSON object per line.
-    import json
-    json_log = open('loss_log.json', mode='wt', buffering=1)
-    json_logging_callback = LambdaCallback(
-        on_epoch_end=lambda epoch, logs: json_log.write(
-            json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '
-'),
-        on_train_end=lambda logs: json_log.close()
+
+```{r}
+# Print the batch number at the beginning of every batch.
+batch_print_callback <- callback_lambda(
+  on_train_batch_begin = function(batch, logs) {
+    print(batch)
+  }
+)
+
+# Stream the epoch loss to a file in JSON format. The file content
+# is not well-formed JSON but rather has a JSON object per line.
+json_log <- file('loss_log.json', open = 'wt', blocking = 1)
+json_logging_callback <- callback_lambda(
+  on_epoch_end = function(epoch, logs) {
+    jsonlite::write_json(
+      x = list(epoch = epoch, loss = logs$loss),
+      file = json_log,
+      append = TRUE
     )
+  },
+  on_train_end = function(logs) {
+    close(json_log)
+  }
+)
 
-    # Terminate some processes after having finished model training.
-    processes = ...
-    cleanup_callback = LambdaCallback(
-        on_train_end=lambda logs: [
-            p.terminate() for p in processes if p.is_alive()])
+# Terminate some processes after having finished model training.
+processes <- ...
+cleanup_callback <- callback_lambda(
+  on_train_end = function(logs) {
+    for (p in processes) {
+      if (is_alive(p)) {
+        terminate(p)
+      }
+    }
+  }
+)
 
-    model.fit(...,
-              callbacks=[batch_print_callback,
-                         json_logging_callback,
-                         cleanup_callback])
-    ```
+model %>% fit(
+  ...,
+  callbacks = list(
+    batch_print_callback,
+    json_logging_callback,
+    cleanup_callback
+  )
+)
+```
 
@@ -53,3 +72,3 @@ Note that the callbacks expects positional arguments, as:
     passing `function_name=function`. For example,
-    `LambdaCallback(.., on_train_end=train_end_fn)`. The custom function
+    `callback_lambda(.., on_train_end=train_end_fn)`. The custom function
     needs to have same arguments as the ones defined in `Callback`.
